<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第 4 章 指令系统 | 林岑LynnCenʘᴗʘ </title>
    <meta name="description" content="林岑的成长之路，包含前端常用知识、源码阅读笔记、各种奇淫技巧、日常提效工具等">
    <meta name="generator" content="VitePress v1.0.1">
    <link rel="preload stylesheet" href="/Lyc-notes/assets/style.BrtKRZt1.css" as="style">
    
    <script type="module" src="/Lyc-notes/assets/app.C5CU2aDz.js"></script>
    <link rel="preload" href="/Lyc-notes/assets/inter-roman-latin.Bu8hRsVA.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/framework.CAVwB9kQ.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/theme.BEWKT3XG.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/组成原理_chapter4.md.CyrBJ9a1.lean.js">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/favicon.ico">
    <link rel="mask-icon" href="/favicon.ico" color="#3eaf7c">
    <meta name="msapplication-TileImage" content="/favicon.ico">
    <meta name="msapplication-TileColor" content="#000000">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-7cb4efe6><!--[--><!--]--><!--[--><span tabindex="-1" data-v-e8152104></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-e8152104> Skip to content </a><!--]--><!----><header class="VPNav" data-v-7cb4efe6 data-v-ea148854><div class="VPNavBar has-sidebar top" data-v-ea148854 data-v-0724480d><div class="wrapper" data-v-0724480d><div class="container" data-v-0724480d><div class="title" data-v-0724480d><div class="VPNavBarTitle has-sidebar" data-v-0724480d data-v-1f66e29d><a class="title" href="/Lyc-notes/" data-v-1f66e29d><!--[--><!--]--><!--[--><img class="VPImage logo" src="/Lyc-notes/LynnCenLogo.png" alt data-v-6e5ecf35><!--]--><span data-v-1f66e29d>林岑LynnCenʘᴗʘ </span><!--[--><!--[--><!--[--><!--[--><img class="visitor" src="https://visitor-badge.laobi.icu/badge?page_id=LynnCen.Lyc-notes" onerror="this.style.display=&#39;none&#39;" data-v-124f1dab><!--]--><!--]--><!--]--><!--]--></a></div></div><div class="content" data-v-0724480d><div class="content-body" data-v-0724480d><!--[--><!--]--><div class="VPNavBarSearch search" data-v-0724480d><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-0724480d data-v-05bd997a><span id="main-nav-aria-label" class="visually-hidden" data-v-05bd997a>Main Navigation</span><!--[--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-05bd997a data-v-6dd6b830><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-6dd6b830><span class="text" data-v-6dd6b830><!----><span data-v-6dd6b830>WebFront</span><span class="vpi-chevron-down text-icon" data-v-6dd6b830></span></span></button><div class="menu" data-v-6dd6b830><div class="VPMenu" data-v-6dd6b830 data-v-f7a45937><div class="items" data-v-f7a45937><!--[--><!--[--><div class="VPMenuLink" data-v-f7a45937 data-v-4174e14e><a class="VPLink link" href="/Lyc-notes/Javascript/basic/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js" data-v-4174e14e><!--[-->Javascript基础<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-f7a45937 data-v-4174e14e><a class="VPLink link" href="/Lyc-notes/Javascript/Advance/executionContext" data-v-4174e14e><!--[-->Javascript进阶<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-f7a45937 data-v-4174e14e><a class="VPLink link" href="/Lyc-notes/typescript/%E8%AE%B0%E5%BD%95" data-v-4174e14e><!--[-->Typescript<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-f7a45937 data-v-4174e14e><a class="VPLink link" href="/Lyc-notes/browser/Chrome%E6%9E%B6%E6%9E%84" data-v-4174e14e><!--[-->浏览器原理<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-05bd997a data-v-6dd6b830><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-6dd6b830><span class="text" data-v-6dd6b830><!----><span data-v-6dd6b830>ComputerBasics</span><span class="vpi-chevron-down text-icon" data-v-6dd6b830></span></span></button><div class="menu" data-v-6dd6b830><div class="VPMenu" data-v-6dd6b830 data-v-f7a45937><div class="items" data-v-f7a45937><!--[--><!--[--><div class="VPMenuGroup" data-v-f7a45937 data-v-6f4f184d><p class="title" data-v-6f4f184d>计算机组成原理</p><!--[--><!--[--><div class="VPMenuLink" data-v-6f4f184d data-v-4174e14e><a class="VPLink link" href="/Lyc-notes/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/chapter1" data-v-4174e14e><!--[-->计算机组成原理基础<!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-f7a45937 data-v-6f4f184d><p class="title" data-v-6f4f184d>数据结构</p><!--[--><!--[--><div class="VPMenuLink" data-v-6f4f184d data-v-4174e14e><a class="VPLink link" href="/Lyc-notes/dataStructure/chapter1" data-v-4174e14e><!--[-->数据结构基础<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-6f4f184d data-v-4174e14e><a class="VPLink link" href="/Lyc-notes/dataStructure/chapter1_ex" data-v-4174e14e><!--[-->课后习题<!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-f7a45937 data-v-6f4f184d><p class="title" data-v-6f4f184d>操作系统OS</p><!--[--><!--[--><div class="VPMenuLink" data-v-6f4f184d data-v-4174e14e><a class="VPLink link" href="/Lyc-notes/os/chapter1" data-v-4174e14e><!--[-->操作系统基础<!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-f7a45937 data-v-6f4f184d><p class="title" data-v-6f4f184d>计算机网络</p><!--[--><!--[--><div class="VPMenuLink" data-v-6f4f184d data-v-4174e14e><a class="VPLink link" href="/Lyc-notes/%E8%AE%A1%E7%BD%91/chapter1" data-v-4174e14e><!--[-->计算机网络基础<!--]--></a></div><!--]--><!--]--></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-05bd997a data-v-6dd6b830><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-6dd6b830><span class="text" data-v-6dd6b830><!----><span data-v-6dd6b830>Frameworks</span><span class="vpi-chevron-down text-icon" data-v-6dd6b830></span></span></button><div class="menu" data-v-6dd6b830><div class="VPMenu" data-v-6dd6b830 data-v-f7a45937><div class="items" data-v-f7a45937><!--[--><!--[--><div class="VPMenuLink" data-v-f7a45937 data-v-4174e14e><a class="VPLink link" href="/Lyc-notes/react/core/basic" data-v-4174e14e><!--[-->React<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-f7a45937 data-v-4174e14e><a class="VPLink link" href="/Lyc-notes/Vue/basic" data-v-4174e14e><!--[-->Vue<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-05bd997a data-v-6dd6b830><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-6dd6b830><span class="text" data-v-6dd6b830><!----><span data-v-6dd6b830>Engineering</span><span class="vpi-chevron-down text-icon" data-v-6dd6b830></span></span></button><div class="menu" data-v-6dd6b830><div class="VPMenu" data-v-6dd6b830 data-v-f7a45937><div class="items" data-v-f7a45937><!--[--><!--[--><div class="VPMenuLink" data-v-f7a45937 data-v-4174e14e><a class="VPLink link" href="/Lyc-notes/webpack/performance" data-v-4174e14e><!--[-->WebPack<!--]--></a></div><!--]--><!--[--><div class="VPMenuGroup" data-v-f7a45937 data-v-6f4f184d><p class="title" data-v-6f4f184d>Vite</p><!--[--><!--]--></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Lyc-notes/interview/js" tabindex="0" data-v-05bd997a data-v-20d3dafa><!--[--><span data-v-20d3dafa>Interview</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-0724480d data-v-632dc8b9><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-632dc8b9 data-v-aefec510 data-v-45278f36><span class="check" data-v-45278f36><span class="icon" data-v-45278f36><!--[--><span class="vpi-sun sun" data-v-aefec510></span><span class="vpi-moon moon" data-v-aefec510></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-0724480d data-v-dedde283 data-v-4d9d7801><!--[--><a class="VPSocialLink no-icon" href="https://github.com/LynnCen" aria-label="github" target="_blank" rel="noopener" data-v-4d9d7801 data-v-219c289b><span class="vpi-social-github" /></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-0724480d data-v-51b1c64a data-v-6dd6b830><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-6dd6b830><span class="vpi-more-horizontal icon" data-v-6dd6b830></span></button><div class="menu" data-v-6dd6b830><div class="VPMenu" data-v-6dd6b830 data-v-f7a45937><!----><!--[--><!--[--><!----><div class="group" data-v-51b1c64a><div class="item appearance" data-v-51b1c64a><p class="label" data-v-51b1c64a>外观</p><div class="appearance-action" data-v-51b1c64a><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-51b1c64a data-v-aefec510 data-v-45278f36><span class="check" data-v-45278f36><span class="icon" data-v-45278f36><!--[--><span class="vpi-sun sun" data-v-aefec510></span><span class="vpi-moon moon" data-v-aefec510></span><!--]--></span></span></button></div></div></div><div class="group" data-v-51b1c64a><div class="item social-links" data-v-51b1c64a><div class="VPSocialLinks social-links-list" data-v-51b1c64a data-v-4d9d7801><!--[--><a class="VPSocialLink no-icon" href="https://github.com/LynnCen" aria-label="github" target="_blank" rel="noopener" data-v-4d9d7801 data-v-219c289b><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-0724480d data-v-51c438c1><span class="container" data-v-51c438c1><span class="top" data-v-51c438c1></span><span class="middle" data-v-51c438c1></span><span class="bottom" data-v-51c438c1></span></span></button></div></div></div></div><div class="divider" data-v-0724480d><div class="divider-line" data-v-0724480d></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-7cb4efe6 data-v-bc19262c><div class="container" data-v-bc19262c><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-bc19262c><span class="vpi-align-left menu-icon" data-v-bc19262c></span><span class="menu-text" data-v-bc19262c>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-bc19262c data-v-2079d3b9><button data-v-2079d3b9>返回顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-7cb4efe6 data-v-3f58d2a6><div class="curtain" data-v-3f58d2a6></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-3f58d2a6><span class="visually-hidden" id="sidebar-aria-label" data-v-3f58d2a6> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-3f58d2a6><section class="VPSidebarItem level-0 has-active" data-v-3f58d2a6 data-v-84b46cca><div class="item" role="button" tabindex="0" data-v-84b46cca><div class="indicator" data-v-84b46cca></div><h2 class="text" data-v-84b46cca>计算机组成原理</h2><!----></div><div class="items" data-v-84b46cca><!--[--><div class="VPSidebarItem level-1 is-link" data-v-84b46cca data-v-84b46cca><div class="item" data-v-84b46cca><div class="indicator" data-v-84b46cca></div><a class="VPLink link link" href="/Lyc-notes/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/chapter1" data-v-84b46cca><!--[--><p class="text" data-v-84b46cca>第一章 计算机系统概述</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-84b46cca data-v-84b46cca><div class="item" data-v-84b46cca><div class="indicator" data-v-84b46cca></div><a class="VPLink link link" href="/Lyc-notes/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/chapter2" data-v-84b46cca><!--[--><p class="text" data-v-84b46cca>第二章 数据的表示和运算</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-84b46cca data-v-84b46cca><div class="item" data-v-84b46cca><div class="indicator" data-v-84b46cca></div><a class="VPLink link link" href="/Lyc-notes/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/chapter3" data-v-84b46cca><!--[--><p class="text" data-v-84b46cca>第三章 存储系统</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-84b46cca data-v-84b46cca><div class="item" data-v-84b46cca><div class="indicator" data-v-84b46cca></div><a class="VPLink link link" href="/Lyc-notes/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/chapter4" data-v-84b46cca><!--[--><p class="text" data-v-84b46cca>第四章 指令系统</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-84b46cca data-v-84b46cca><div class="item" data-v-84b46cca><div class="indicator" data-v-84b46cca></div><a class="VPLink link link" href="/Lyc-notes/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/chapter5" data-v-84b46cca><!--[--><p class="text" data-v-84b46cca>第五章 中央处理器</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-84b46cca data-v-84b46cca><div class="item" data-v-84b46cca><div class="indicator" data-v-84b46cca></div><a class="VPLink link link" href="/Lyc-notes/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/chapter6" data-v-84b46cca><!--[--><p class="text" data-v-84b46cca>第六章 总线</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-84b46cca data-v-84b46cca><div class="item" data-v-84b46cca><div class="indicator" data-v-84b46cca></div><a class="VPLink link link" href="/Lyc-notes/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/chapter7" data-v-84b46cca><!--[--><p class="text" data-v-84b46cca>第七章 输入/输出系统</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-7cb4efe6 data-v-46f1df28><div class="VPDoc has-sidebar has-aside" data-v-46f1df28 data-v-68270971><!--[--><!--]--><div class="container" data-v-68270971><div class="aside" data-v-68270971><div class="aside-curtain" data-v-68270971></div><div class="aside-container" data-v-68270971><div class="aside-content" data-v-68270971><div class="VPDocAside" data-v-68270971 data-v-578eff5a><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" role="navigation" data-v-578eff5a data-v-645a1e5e><div class="content" data-v-645a1e5e><div class="outline-marker" data-v-645a1e5e></div><div class="outline-title" role="heading" aria-level="2" data-v-645a1e5e>本页目录</div><nav aria-labelledby="doc-outline-aria-label" data-v-645a1e5e><span class="visually-hidden" id="doc-outline-aria-label" data-v-645a1e5e> Table of Contents for current page </span><ul class="VPDocOutlineItem root" data-v-645a1e5e data-v-a088e582><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-578eff5a></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-68270971><div class="content-container" data-v-68270971><!--[--><!--]--><main class="main" data-v-68270971><div style="position:relative;" class="vp-doc _Lyc-notes_%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_chapter4" data-v-68270971><div><h1 id="第-4-章-指令系统" tabindex="-1">第 4 章 指令系统 <a class="header-anchor" href="#第-4-章-指令系统" aria-label="Permalink to &quot;第 4 章 指令系统&quot;">​</a></h1><h2 id="指令系统" tabindex="-1">指令系统 <a class="header-anchor" href="#指令系统" aria-label="Permalink to &quot;指令系统&quot;">​</a></h2><h3 id="指令集体系结构" tabindex="-1">指令集体系结构 <a class="header-anchor" href="#指令集体系结构" aria-label="Permalink to &quot;指令集体系结构&quot;">​</a></h3><p>机器指令(简称指令)是指示计算机执行某种操作的命令。一台计算机的所有指令的集合构成该机的指令系统，也称指令集。</p><p>ISA 规定的内容 主要包括:</p><ol><li><p>指令格式，指令寻址方式，操作类型，以及每种操作对应的操作数的相应规定。</p></li><li><p>操作数的类型，操作数寻址方式，以及是按大端方式还是按小端方式存放。</p></li><li><p>程序可访问的寄存器编号、个数和位数，存储空间的大小和编址方式。</p></li><li><p>指令执行过程的控制方式等，包括程序计数器、条件码定义等。</p></li></ol><h3 id="指令的基本格式" tabindex="-1">指令的基本格式 <a class="header-anchor" href="#指令的基本格式" aria-label="Permalink to &quot;指令的基本格式&quot;">​</a></h3><p>| 操作码 | 地址码字段 |</p><ul><li>操作码：指出该指令应执行什么操作以及具有何种功能。</li><li>地址码：给出被操作的信息(指令或数据)的地址，包括参加运算的一个或多个操作数的地址、运算结果的保存地址、程序的转移地址、被调用子程序的入口地址等</li><li>指令字长：是指一条指令所包含的二进制代码的位数，其取决于操作码的长度、地址码的长度 和地址码的个数。把指令长度等于机器字长的指令称为单字长指令，指令长度等于半个机器 字长的指令称为半字长指令，指令长度等于两个机器字长的指令称 双字长指令。</li></ul><p>在一个指令系统中，若所有指令的长度都是相等的，则称为定长指令字结构。定字长指令的执行速度快，控制简单。若各种指令的长度随指令功能而异，则称为变长指令字结构。然而，因为主在一般是按字节编址的，所以指令字长通常为字节的整数背。</p><p>常见指令格式：</p><ol><li>零地址指令</li><li>一地址指令</li><li>二地址指令</li><li>三地址指令</li><li>四地址指令</li></ol><h3 id="定长操作码指令格式" tabindex="-1">定长操作码指令格式 <a class="header-anchor" href="#定长操作码指令格式" aria-label="Permalink to &quot;定长操作码指令格式&quot;">​</a></h3><p>定长操作码指令在指令字的最高位部分分配固定的若干位(定长)表示操作码。一般 n 位操作码字段的指令系统量大能够表示 2^n 条指令。</p><h3 id="扩展操作码指令格式" tabindex="-1">扩展操作码指令格式 <a class="header-anchor" href="#扩展操作码指令格式" aria-label="Permalink to &quot;扩展操作码指令格式&quot;">​</a></h3><p>变长操作码 方法是扩展操作码，它使操作码 的长度随地址码的减少而增加，不同地址数的指令可具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长</p><p><img src="/Lyc-notes/assets/1694262218528.1WniC0lo.png" alt="1694262218528"></p><h3 id="指令地址码的个数" tabindex="-1">指令地址码的个数 <a class="header-anchor" href="#指令地址码的个数" aria-label="Permalink to &quot;指令地址码的个数&quot;">​</a></h3><p>一条指令中必须明确地(显示)或隐含地包含以下信息。</p><p>(1)操作码。指定操作类型，如移位、加、减、乘、除、传送等</p><p>(2)源操作数或其地址。指出一个或多个源操作数或其所在地址，可能是主(虚)存地址，寄存器编号或 I/O 端口，也可以在指令中直接给出一个立即数。</p><p>(3)结果的地址。结果所存放的地址，可以是主存地址、寄存器编号或 I/O 端口。</p><p>(4)下一条指令地址。一般隐含在 PC 中，指令按顺序执行时，只要自动将 PC 的值加上指令的长度，就可以得出下一条指令的地址，如果遇到转移指令，则需要由指令给出转移到的目标地址。</p><h3 id="指令格式设计原则" tabindex="-1">指令格式设计原则 <a class="header-anchor" href="#指令格式设计原则" aria-label="Permalink to &quot;指令格式设计原则&quot;">​</a></h3><p>(1)指令应尽量短。降低开销</p><p>(2)要有足够的操作码位数。向后兼容</p><p>(3)操作码的编码必须有唯一的解释。</p><p>(4)指令长度应是字节的整数倍。指令存放在内存中，而内存往往按字节编址，指令的长度为字节的整数倍，便于指令的读取和指令地址的计算。</p><p>(5)合理选择地址字段的个数。</p><p>(6)指令应尽量规整。</p><p><img src="/Lyc-notes/assets/1694262189366.rSJsmh6H.png" alt="1694262189366"></p><h3 id="操作类型" tabindex="-1">操作类型 <a class="header-anchor" href="#操作类型" aria-label="Permalink to &quot;操作类型&quot;">​</a></h3><ol><li>算术和逻辑运算指令</li></ol><p>加(ADD)、减(SUB)、比较(CMP)、乘(MUL)、除(DIV)、与(AND)、或(OR)、取反(NOT)、取负(NEG)、异或(XOR)、加 1(INC)、减 1(DEC)等。</p><ol start="2"><li>移位指令</li></ol><p>算术移位、逻辑移位、循环移位、半字交换。</p><p>算术左移：操作数的各位依次向左移，低位补零。有些机器将最高位移入进位标志 CF 位，这样可以通过判断符号标志和进位标志是否相等就可以判断是否发生了溢出。</p><p>算术右移：各位依次向右移，高位补符号。有些机器将最低位移入进位标志位。</p><p>逻辑左移：同算术左移。</p><p>逻辑右移：各位依次向右移，高位补零。</p><p>小循环左移：最高位移入进位标志位，同时也移入最低位。</p><p>小循环右移：最低位移入进位标志位，同时也移入最高位。</p><p>大循环左移：最高位移入进位标志位，而进位标志位移入最低位。</p><p>大循环右移：最低位移入进位标志位，而进位标志位移入最高位。</p><ol start="3"><li>传送指令</li></ol><p>传送指令通常有寄存器之间的传送 MOV、从内存单元读取数据到 CPU 寄存器 LOAD、从 CPU 寄存器写数据到内存单元 STORE 等。 4. 串指令</p><p>串指令是对字符串进行操作的指令。如串传送，串比较，检索和传送出转换等指令。</p><ol start="5"><li>顺序控制指令</li></ol><p>顺序控制指令用来控制程序执行的顺序。有条件转移 BRANCH、无条件转移 JMP、跳步 SKIP、调用 CALL、返回 RET 等指令。顺序控制类指令的功能通过将转移目标地址送到 PC 中来实现。无条件转移指令在任何情况下都执行转移操作，而条件转移指令(分支指令)仅仅在特定条件满足时才执行转移操作。 调用指令也称为转子指令，和转移指令的根本区别在于执行调用指令时必须保存下一条指令的地址（返回地址）。调用指令用于子程序调用(即过程调用或函数调用)，当子程序执行结束时，根据返回地址回到主程序继续执行；而转移指令则不返回执行，因而无法保存返回地址。返回指令的功能是在子程序执行完毕时，将事先保存的返回地址送到 PC，这样处理器就能回到原来的主程序继续执行。</p><ol start="6"><li><p>CPU 控制指令</p><p>停机、开中断、关中断、系统模式切换以及进入特殊处理程序等指令。大多数机器将这类指令划为“特权”指令(也称为管态指令)，只能在内核代码执行时使用。</p></li><li><p>输入输出指令</p><p>这类指令用户完成 CPU 与外部设备交换数据或传送控制指令及状态信息。</p></li></ol><h2 id="指令的寻址方式" tabindex="-1">指令的寻址方式 <a class="header-anchor" href="#指令的寻址方式" aria-label="Permalink to &quot;指令的寻址方式&quot;">​</a></h2><p><strong>寻址方式是指寻找指令或操作数有效地址的方式，即确定本条指令的数据地址及下一条待执行指令的地址的方法</strong>。寻址方式分为<strong>指令寻址</strong>和<strong>数据寻址</strong>两大类。</p><h3 id="指令寻址和数据寻址" tabindex="-1">指令寻址和数据寻址 <a class="header-anchor" href="#指令寻址和数据寻址" aria-label="Permalink to &quot;指令寻址和数据寻址&quot;">​</a></h3><p><strong>寻找下一条将要执行的指令地址称为指令寻址；寻找本条指令的数据地址称为数据寻址。</strong></p><ol><li><strong>指令寻址</strong></li></ol><p>指令寻址方式有两种：一种是顺序寻址，一种是跳跃寻址方式。</p><p>顺序寻址：通过程序计数器 PC 加 1（1 一条指令的长度），自动形成下一条指令的地址。</p><p>跳跃寻址：由本条指令给出下一条指令地址的计算方式。由于可能受到状态寄存器的控制，跳跃的方式分为绝对转移（地址码直接给出转移目标地址）和相对转移（地址码指出转移目标地址相对于当前 PC 的偏移量），由于 CPU 总是根据 PC 的内容去贮存取指令，因此转移指令执行结果就是修改 PC 值，下一条指令仍然通过 PC 给出。</p><p>通常把指令中给出的操作数所在的存储单元的地址称为有效地址，存储单元地址可能是主存物理地址，也可能是虚拟地址。</p><ol start="2"><li><strong>数据寻址</strong></li></ol><p>数据寻址是指如何在指令中表示 一个操作数的地址，或怎样计算出操作数的地址。数据寻址 的方式较多，为区别各种方式，通常在指令字中设置 一个寻址特征字段，用来指明属于哪种寻址 方式(其位数决定了寻址方式的种类)</p><table><thead><tr><th>操作码</th><th>寻址特征</th><th>形式地址</th></tr></thead></table><p>指令中的地址码字段并不代表操作数的真实地址，这种地址称为<strong>形式地址(A)</strong>。形式地址结合寻址方式，可以计算出操作数在存储器中的真实地址，这种地址称为<strong>有效地址(EA)</strong>。</p><ul><li>若为立即寻址，则形式地址的位数决定了操作数的范围。</li><li>若为直接寻址，则形式地址的位数决定 了可寻址的范围。</li><li>若为寄存器寻址，则形式地址的位数决定了通用寄存器的最大数量。</li><li>若为寄存器间接寻址，则寄存器的位数决定了可寻址的范围</li></ul><blockquote><p>(A)表示地址为 A 的数值，A 既可以是寄存器编号，又可以是内存地址。</p></blockquote><h3 id="常见的数据寻址方式" tabindex="-1">常见的数据寻址方式 <a class="header-anchor" href="#常见的数据寻址方式" aria-label="Permalink to &quot;常见的数据寻址方式&quot;">​</a></h3><ol><li><strong>隐含寻址</strong></li></ol><p>这种类型的指令不明显地给出操作数的地址，而是隐含操作数的地址。例如，单地址的指令 格式就隐含约定第 二个操作数由累加器(ACC)提供，指令中只明显指出第一个操作数的地址。因此，累加器(ACC)对单地址指令格式来说是隐含寻址 <img src="/Lyc-notes/assets/%E9%9A%90%E5%90%AB%E5%AF%BB%E5%9D%80.BGaYBcox.png" alt="alt text"> 优点是有利于缩短指令字长:缺点是需增加存储操作数或隐含地址的硬件。</p><ol start="2"><li><strong>立即(树数)寻址</strong></li></ol><p>指令字中的地址字段指出的不是操作数的地址，而是操作数本身，也称立即数，采用补码表 示。</p><ol start="3"><li><strong>直接寻址</strong></li></ol><p>指令中给出的地址码是操作数的有效地址，这种地址称为直接地址或绝对地址。</p><p><img src="/Lyc-notes/assets/%E7%AB%8B%E5%8D%B3_%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.B0Ilih1l.png" alt="alt text"></p><p>优点是简单，不需要专门计算操作数的地址，指令在执行阶段仅需访存一次:缺点是 A 的位数限制了该指令操作数的寻址范围，操作数的地址不易修改。</p><ol start="4"><li><strong>间接寻址</strong></li></ol><p>指令中给出的地址码是存放操作数有效地址的主存单元地址。</p><p><img src="/Lyc-notes/assets/%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.DDWdSZe8.png" alt="alt text"></p><ol start="5"><li><p><strong>寄存器寻址</strong></p><p>指令中给出的地址码是操作数所在的寄存器编号，操作数在寄存器中。</p><p>优点：</p><p>(1)寄存器数量远小于内存单元数，故寄存器编号和存储地址短，因而寄存器寻址方式的指令较短。</p><p>(2)操作数已在 CPU 中，不用访存，因而指令执行的速度快。</p></li><li><p><strong>寄存器间接寻址</strong></p><p>指令中给出的地址码是一个寄存器编号，该寄存器中存放的是操作数的有效地址。指令长度和寄存器寻址指令差不多，但由于要访存，所以寄存器间接寻址指令的执行时间比寄存器寻址指令的执行时间更长。 <img src="/Lyc-notes/assets/%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80.eb-pQN_Z.png" alt="alt text"></p></li><li><p><strong>相对寻址</strong></p></li></ol><p>相对寻址是把 PC 的内容加上指令格式中的形式地址 A 而形成操作数的有效地址，即 EA=(PC)+A，其中 A 是相对于当前 PC 值的偏移量，可正可负，补码表示</p><p>优点是操作数的地址不是固定的 ，它随 PC 值的变化而变化，且与指令地址之间总是相差一 个固定的偏移量，因此便于程序浮动。相对寻址广泛应用王转移損令。</p><p><img src="/Lyc-notes/assets/%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80.D86y2IhO.png" alt="alt text"></p><p>相对寻址方式可用来实现公共子程序的浮动或实现相对转移。</p><ol start="8"><li><strong>基址寻址</strong></li></ol><p>基址寻址方式下，指令中的地址码字段 A 给出一个偏移量，基准地址可以明显或隐含地由基址寄存器 B 给出。</p><p>操作数有效地址 EA = (B)+A</p><p><img src="/Lyc-notes/assets/%E5%9F%BA%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.SjjdFXiu.png" alt="15"></p><p>基址寄存器是<strong>面向操作系统</strong>的，其内容由操作系统或管理程序确定，主要用于解决程序逻辑 空间与存储器物理空间的无关性。在程序执行过程中，基址寄存器的内容不变(作 基地址)， 形式地址可变(作为偏移量)。采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作 为基址寄存器，但其内容仍由操作系统确定。</p><p>基址寻址的优点是可以扩大寻址范围(基址寄存器的位数大于形式地址 A 的位数);用户不必考虑自己的程序存于主存的具体位置，因此有利于多道程序设计，并可用于编制浮动程序，但偏移量(形式地址 A)的位数较短。</p><p>变址、基址和相对 3 中寻址方式，都是将某个寄存器的内容与一个形式地址相加来生成操作数的有效地址。统称为偏移寻址。</p><ol start="9"><li><strong>变址寻址</strong></li></ol><p>变址寻址方式主要是用于对线性表之类的<strong>数组元素</strong>进行方便的访问。</p><p>采用变址寻址方式时，指令中的地址码字段 A 给出的是一个基准地址，<strong>例如数组的起始地址，而数组元素相对于基准地址的偏移量在指令中明显或隐含地由变址寄存器 I 给出，这样变址寄存器(简称变址器)的内容实际上就相当于数组元素的下标，每个元素的有效地址为基准地址加变址寄存器的内容</strong>，即操作数的有效地址 EA = (I) + A 其中 I 表示变址寄存器 I 的内容</p><p>显然，变址寻址与基址寻址的有效地址形成过程极为相似。但从本质上讲，两者有较大区别。 <strong>基址寻址面向系统</strong>，主要用于为多道程序或数据分配存储空间，因此基址寄存器的内容通常由操作系统或管理程序确定，在程序的执行过程中其值不可变 ，而指令字中的 A 是可变的。变址寻址<strong>立足于用户</strong>，主要用于处理<strong>数组</strong>问题，在变址寻址中，变址寄存器的内容由用户设定，在程序执 行过程中其值可变，而指令字中的 A 是不可变的。</p><ol start="10"><li><strong>堆栈寻址</strong></li></ol><p>堆栈是存储器(或寄存器组)中一块特定的、按后进先出(LIFO)原则管理的存储区，该存储区中读/写单元的地址是用一个特定寄存器给出的，该寄存器称为堆栈指针(SP)。堆栈可分为硬堆栈和软堆栈两种。寄存器堆栈也称硬堆栈，硬堆栈的成本较高，不适合做大容量的堆栈。而从主存中划出一段区域来做堆栈是最合算且最常用的方法，这种堆栈称为软堆栈 如果某指令的操作数的有效地址或转移目标地址位于该指令所在位置的钱、后某个固定位置上，则该操作数或转移目标可用相对寻址方式。采用相对寻址方式时，指令中的地址码字段 A 给出一个偏移量，基准地址隐含由 PC 给出，即操作数有效地址或目标地址 EA=(PC)+A</p><p>在采用堆栈结构的计算机中，大部分指令表面上都表现为无操作数指令的形式，因为操作数地址都隐含使用了 SP。因此在读/写堆栈的前后都伴有自动完成对 SP 的加减操作</p><p><img src="/Lyc-notes/assets/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.Bn4ykbfn.png" alt="alt text"></p><h3 id="标志信息的生成和使用" tabindex="-1">标志信息的生成和使用 <a class="header-anchor" href="#标志信息的生成和使用" aria-label="Permalink to &quot;标志信息的生成和使用&quot;">​</a></h3><p>常用的条件转移指令： <img src="/Lyc-notes/assets/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4.DlwzvWV-.png" alt="16"></p><p>CF = Count 异或 Sub</p><h2 id="程序的机器级代码展示" tabindex="-1">程序的机器级代码展示 <a class="header-anchor" href="#程序的机器级代码展示" aria-label="Permalink to &quot;程序的机器级代码展示&quot;">​</a></h2><p>考察 x86 汇编指令</p><h3 id="常用汇编指令介绍" tabindex="-1">常用汇编指令介绍 <a class="header-anchor" href="#常用汇编指令介绍" aria-label="Permalink to &quot;常用汇编指令介绍&quot;">​</a></h3><ol><li><strong>相关寄存器</strong></li></ol><p><img src="/Lyc-notes/assets/%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8.mndZUGHT.png" alt="alt text"></p><ol start="2"><li><strong>汇编指令格式</strong></li></ol><p>AT&amp;T 格式和 Intel 格式（掌握 Intel 格式）</p><p><img src="/Lyc-notes/assets/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.CsxHqkZO.png" alt="alt text"></p><ol start="3"><li><strong>常用指令</strong></li></ol><p>数据传输指令、算数和逻辑运算指令和控制流指令</p><h4 id="数据传送指令" tabindex="-1">数据传送指令 <a class="header-anchor" href="#数据传送指令" aria-label="Permalink to &quot;数据传送指令&quot;">​</a></h4><p>（1）<strong>mov 指令</strong></p><p>将第二个操作数(寄存器的内容、内存中的内容或常数值)复制到第一个操作数(寄存器或内存)。</p><div class="language-c++ vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mov </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">reg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">reg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mov </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mem</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mem</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mov eax, ebx.</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 将ebx值复制到eax</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mov byte ptr [var], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 将5保存到var值指示的内存地址的一字节中</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>双操作数不能都是内存，即 mov 指令不能直接将内存复制到内存，需进行中间转换，从内存到寄存器再到内存。</p><p>（2）<strong>push 指令</strong></p><p>将操作数压入内存的栈，常用于函数调用。ESP 是栈顶，入栈前先将 ESP 值减 4（栈增长方向与内存地址增长方向相反），然后将将操作数压入 ESP 指示的地址</p><div class="language-c++ vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">push </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">reg32</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">push </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mem</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">push </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">con32</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">push eax</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 将eax值入栈</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">push [var]</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 将var指示的内存地址的4字节入栈</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>（3）<strong>pop 指令</strong></p><p>pop 指令执行的是出栈工作，出栈前先将 ESP 指示的地址中的内容出栈，然后将 ESP 值加 4</p><div class="language-c++ vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pop eax</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 弹出栈顶元素送到eax</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pop 【ebx】</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 弹出栈顶元素送到ebx指示的内存地址的4字节中</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="算数和逻辑指令" tabindex="-1">算数和逻辑指令 <a class="header-anchor" href="#算数和逻辑指令" aria-label="Permalink to &quot;算数和逻辑指令&quot;">​</a></h4><p>（1）<strong>add/sub 指令</strong></p><p>add 指令将两个操作数相加，相加的结果保存到第一个操作数中。sub 指令用于两个操作数相减，相减的结果保存到第一个操作数中。</p><div class="language-c++ vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">add</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">reg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">reg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sub</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">reg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，regy</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">add</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">reg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，smem</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sub</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">reg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，mem</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">add‹mem</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">reg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sub‹mem</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">reg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">add‹reg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,‹con</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sub</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">reg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,‹con</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">add‹mem</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,‹con</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sub‹mem</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">con</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sub eax , </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // eax &lt;- eax - 10</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">add byte ptr [var], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 10 与var指示的内存地址一字节相加，并将结果保存到var指示的内存地址字节中</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>（2）<strong>inc/dec 指令</strong></p><p>inc 、dec 指令分别表示将操作数自加 1、自減 1。</p><p>（3）<strong>imul 指令</strong></p><p>有符号整数乘法指令，有两种格式:1 两个操作数，将两个操作数相乘，将结果保存在第一个操作数中，第一个操作数必须为寄存器;2 三个操作数，将第 二个和 第三个操作数相乘，将结果保存在第一个操作数中，第一个操作数必须为寄存器</p><p>（4）<strong>idiv 指令</strong></p><p>有符号整数除法指令，它只有一个操作数，即除数，而被除数则为 e dx&quot;cax 中 的内容(共 64 位)，操作结果有两部分:商和余数，商送到 eax，余数则送到 edx</p><p>（5）<strong>and/or/xor 指令</strong></p><p>and 、or、xor 指令分别是逻辑与、逻辑或、逻辑异或操作指令，用于操作数的位操作，操作结果放在第一个操作数中</p><p>（6）<strong>not 指令</strong></p><p>位翻转指令，将操作数中的每一位翻转，即 0-&gt;1、1-&gt;0</p><p>（7）<strong>neg 指令</strong></p><p>取负指令</p><p>（8）<strong>shl/shr 指令</strong></p><p>逻辑移位指令，shl 为逻辑左移，shr 为逻辑右移，第一个操作数表示被操作数，第二个操作数指示移位的位数</p><h4 id="控制流指令" tabindex="-1">控制流指令 <a class="header-anchor" href="#控制流指令" aria-label="Permalink to &quot;控制流指令&quot;">​</a></h4><p>（1）<strong>jmp 指令</strong></p><p>jmp 指令控制 IP 转移到 label 所指示的地址（从 label 中取出指令执行）</p><div class="language-c++ vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">jmp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">label</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">jmp begin</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 跳转到begin标记的指令执行</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>（2）<strong>jcondition 指令</strong></p><p>条件转移指令 依据 CPU 状态字中的一系列条件状态转移。CPU 状态字中包括中指示最后一个算数运算结果是否为 0 等。</p><div class="language-c++ vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">je</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">label</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; (jump when equal)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">jz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">label</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; (jump when last result was zero)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">jne</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">label</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; (jump when </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> equal)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">jg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">label</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; (jump when greater than)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">jge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">label</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; (jump when greater than </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">or</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> equal to)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">jl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">label</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; (jump when less than)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">jle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">label</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; (jump when less than </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">or</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> equal to)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cmp eax , ebx</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">jle done</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 若eax值 &lt;= ebx值 则跳转done 执行，否则执行下一条</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>（3）<strong>cmp/test 指令</strong></p><p>cmp 指令的功能相当于 sub 指令，用于比较两个操作数的值。test 指令的 功能相当于 and 指令，对两个操作数进行逐位与运算。与 sub 和 and 指令不同的是，这两 类指令都不保存操作结果，仅根据运算结果设置 CPU 状态字中的条件码。</p><p>cmp 和 test 指令通常和 jcondition 指令搭配使用，举例</p><div class="language-c++ vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cmp dword ptr [var] , </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 将var指示的主存地址的4字节内容，与10相比较</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">jne loop</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                 // 若相等则继续顺序执行；否则跳转到loop处执行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">test eax , eax</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           // 测试test是否为零</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">jz xxxx</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                  // 为零则置标志位ZF为1，则跳转到xxx出执行</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>（4）<strong>call/ret 指令</strong></p><p>分别用于实现子程序(过程、函数等)的调用及返回`</p><div class="language-c++ vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">call </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">label</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ret</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>call 指令首先将当前执行指令地址入栈，然后无条件转移到由标签指示的指令。与其他简单的跳转指令不同，call 指令保存调用之前的地址信息(当 call 指令结束后，返回调用之前的地址)。ret 指令实现子程序的返回机制，ret 指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址执行。call 和 ret 是程序(函数)调用中最关键的两条指令</p><p><img src="/Lyc-notes/assets/1694518313870.DHMFYwiL.png" alt="1694518313870"></p><p><img src="/Lyc-notes/assets/1694518290426.BnbhMpSI.png" alt="1694518290426"></p><h3 id="选择语句的机器级表示" tabindex="-1">选择语句的机器级表示 <a class="header-anchor" href="#选择语句的机器级表示" aria-label="Permalink to &quot;选择语句的机器级表示&quot;">​</a></h3><p>常见的选择结构语句有 if-then、if-then-else 等。编译器通过条件码 (标志位)设置指令和各 类转移指令来实现程序中的选择结构语句。条件码描述了最近的算术或逻辑运算操作的属性，可 以检测这些寄存器来执行条件分支指令，最常用的条件码有 CF、ZF、SF 和 OF。</p><p>常见的算术逻辑运算指令(add,sub,imul,or,and,shl,inc,dec,not,sal 等)会设置条件码，还有 cmp 和 test 指令只设置条件码而不改变任何其他寄存器</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get_cont</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">p1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">p2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p2){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p2;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p1;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>已知 p1 和 p2 对应的实参已被压入调用函数的栈帧，它们对应的存储地址分别为<code>R[ebp]+8、R[ebp]+12</code>(EBP 指向当前栈帧底部)，返回结果存放在 EAX 中。对应的汇编代码:</p><div class="language-c++ vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mov eax , dword ptr [ebp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // R[eax] &lt;- M[R[ebp] + 8], 即R[eax] = p1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mov edx , dword ptr [ebp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // R[edx] &lt;- M[R[ebp] + 8], 即R[edx] = p2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cmp eax , edx</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // 比较p1和p2，即根据p1-p2的结果置标志</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">jbe .L1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                      // 若p1&lt;=p2 ， 则转标记L1处执行 jbe? &lt;= less than or equal to</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mov eax , dword ptr [edx]</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // R[eax]&lt;-M[R[edx]].  R[eax] = M[p2]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">jmp .L2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                      // 无条件跳转至标记L2执行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.L1:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mov eax , dword ptr [eax]</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // R[eax] &lt;- M[R[eax]] 即R[eax] = M[p1]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.L2;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>PI 和 p2 是指针型参数，所以在 32 位机中的长度是 dwordptr，比较指令 cmp 的两个操作数都 应来自寄存器，因此应先将 p1 和 p2 对应的实参从栈中取到通用寄存器，比较指令执行后得到各个 条件码，然后根据各条件码值的组合选择执行不同的指令，因此需要用到条件转移指令 <img src="/Lyc-notes/assets/1694518331921.BDIdxgBX.png" alt="1694518331921"></p><p><img src="/Lyc-notes/assets/1694518364500.TaUh7ihq.png" alt="1694518364500"><img src="/Lyc-notes/assets/1694518374706.DbnSwzxi.png" alt="1694518374706"></p><h3 id="循环语句的机器级表达" tabindex="-1">循环语句的机器级表达 <a class="header-anchor" href="#循环语句的机器级表达" aria-label="Permalink to &quot;循环语句的机器级表达&quot;">​</a></h3><p>常见的循环语句<code>do while</code>,<code>while</code>,<code>for</code>。汇编指令中没有对应的指令，可以用条件测试和跳转组合起来实现效果，大多数编译器都将这三种循环结构都转为<code>do-while</code>形式来产生机器代码。在循环结构中，通常使用条件转移指令来判断循环条件的结束。</p><p>下面是一个用 for 循环写的自然数求和的函数：</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sum_for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">n;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这段代码中的 for 循环的不同组成部分：</p><div class="language-c++ vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">init_expr      i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">test_expr      i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">n</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">update_expr    i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">body_statement result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>将这个函数翻译为 goto 语句代码后，得到其过程体的汇编代码：</p><div class="language-asm vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mov</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ecx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">dword</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ptr [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ebp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # R[ecx] &lt;- M[R[ebp]+8] 即R[ecxx] = n</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mov</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> eax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    # R[eax] &lt;- 0  即result=0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mov</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> edx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    # R[edx] &lt;- 1  即i=1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">cmp</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> edx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ecx</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                  # Compare R[edx]:R[ecx] 即比较i：n</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">jg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .L2                       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # If greater，则跳转到L2执行</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">L1:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                           # loop:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">add</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> eax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">edx</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                  # R[eax] &lt;- R[eax] + R[edx]，即result += 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">add</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> edx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    # R[edx] &lt;- R[edx] + 1 即i++</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">cmp</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> edx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ecx</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                  # Compare R[edx]:R[ecx] 即比较i：n</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">jle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .L1                       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # If less or equal，则跳转到L1执行</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">L2:</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>已知 n 对应的实参已被压入调用函数的栈帧，其对应的存储地址为<code>R[ebp]+8</code> ，过程<code>nsum_for</code>中 的局部变量 i 和 result 被分别分配到寄存器 EDX 和 EAX 中，返回参数在 EAX 中。</p><p><img src="/Lyc-notes/assets/1694601803725.Bgd5IhnA.png" alt="1694601803725"></p><h3 id="过程调用的机器级表示" tabindex="-1">过程调用的机器级表示 <a class="header-anchor" href="#过程调用的机器级表示" aria-label="Permalink to &quot;过程调用的机器级表示&quot;">​</a></h3><p>前面提到的<code>call/ret</code>指令主要用于过程调用，它们都是属于一种无条件转移指令。</p><p>假定过程 P 调用过程 Q，过程调用的执行步骤如下：</p><p>（1）P 将入口参数（实参）放到 Q 能访问到的地方。</p><p>（2）P 将返回地址存到特定的地方，然后将控制转移到 Q。</p><p>（3）Q 保存 P 的现场（通用寄存器的内容），并为自己的非静态局部变量分配空间。</p><p>（4）执行过程 Q。</p><p>（5）Q 恢复 P 的现场，将返回结果放到 P 能访问到的地方，并释放局部变量所占空间</p><p>（6）Q 取出返回地址，将控制转移到 P。</p><p>步骤 2 是 call 指令实现的，步骤 6 是 ret 指令返回到过程 P。在上述步骤中，需要为入口参数、返回地址、过程 P 的现场、过程 Q 的局部变量、返回结果找到存放空间。</p><p>用户可见的寄存器数量有限，调用者和被调用者需要共享寄存器，若直接覆盖对方的寄存器，则会导致程序出错，故有一下规范：寄存器 EAX、ECX 和 EDX 是调用者保存寄存器，当 P 调用 Q 时，若 Q 需要用到这些寄存器，则由 P 将这些寄存器的内容保存到栈中，并在返回后由 P 恢复它们的值。寄存器 EBX、ESI、EDI 是被调用者保存寄存器，当 P 调用时，Q 必须先将这些寄存器的内容保存在栈中才能使用它们，并在返回 P 之前先恢复它们的值。</p><p>每个过程都有自己的栈区，称为栈帧，因此，一个栈由若干栈帧组成，寄存器 EBP 指示栈帧的起始位置，寄存器 ESP 指示栈顶，栈从高地址向低地址增长。过程执行时，ESP 会随着数据的入栈而动态变化，而 EBP 固定不变。当前栈帧的范围在 EBP 和 ESP 指向的区域之间。</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> caller</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> temp1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 125</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> temp2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 80</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(temp1 , temp2);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>经过 GCC 编译后，caller 过程独赢的代码如下：</p><div class="language-asm vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">caller:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    push</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ebp</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    mov</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ebp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">esp</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    sub</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> esp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                 # GCC为caller的参数分配了24字节的空间</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    mov</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ebp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> - </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] , </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">125</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         # M[R[ebp - 12]] &lt;- 125 即temp1 = 125</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    mov</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ebp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> - </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]  , </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          # M[R[ebp -8]]  &lt;- 80  即temp2 = 80</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    mov</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> eax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">dword</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ptr [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ebp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # R[eax] &lt;- M[R[ebp] -8], 即R[eax]=temp2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    mov</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">esp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> + </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] ,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">eax</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           # M[R[esp + 4]] &lt;- R[eax], 即temp2入栈</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    mov</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> eax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">dword</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ptr [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ebp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # R[eax] &lt;- M[R[ebp] -12], 即R[eax]=temp1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    mov</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">esp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] ,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">eax</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">               # M[R[esp + 4]] &lt;- R[eax], 即temp1入栈</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    call</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> add</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                     # 调用add，将返回结果保存在eax中</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    mov</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ebp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">eax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">             #M[R[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ebp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] &lt;- R[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">eax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]     即add返回值送sum</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    mov</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> eax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">dword</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ptr [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ebp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # R[eax] &lt;- M[R[ebp]-4]    即sum作为返回值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    leave</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ret</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>图 4.12 给出了 caller 栈帧的状态，假定 caller 被过程 P 调用。执行第 4 行的指令后，ESP 所指的位置如图中所示，可以看出 GCC 为 caller 的参数分配了 24 字节的空间。从汇编代码中可以看出，caller 中只使用了调用者保存寄存器 EAX，没有使用任何被调用者保存寄存器，因此在 caller 栈帧中无须保存除 EBP 外的任何寄存器的值;caller 有三个局部变量 templ、temp2 和 sum，皆被分配在栈帧中;在用 call 指令调用 add 函数之前，caller 先将入又参数从右向左依次将 temp2 和 templ 的值(即 80 和 125)保存到栈中。在执行 call 指令时再把返回地址压入栈中。此外，在最初进入 caller 时，还将 EBP 的值压入了栈，因此 caller 的栈帧中用到的空间占 4+12+8+4=28 字节。但是，caller 的栈帧共有 4+24+4=32 字节，其中浪费了 4 字节的空间(未使用)。这是因为 GCC 为保证数据的严格对齐而规定每个函数的栈帧大小必须是 16 字节的倍数</p><p>call 指令执行后，add 函数的返回参数存放在 EAX 中，因此 call 指令后面的两条指令中，指令<code>“mov[ebp-4]，eax”</code>将 add 的结果存入 sum 变量的存储空间，该变量的地址为<code>R[ebp]-4</code>;指令<code>“movcax,dwordptr[ebp-4]”</code>将 sum 变量的值作为返回值送到寄存器 EAX 中。</p><p><img src="/Lyc-notes/assets/call_add%E7%9A%84%E6%A0%88%E5%B8%A7.C8QW9k_w.png" alt="alt text"></p><h2 id="cisc-和-risc-的基本概念" tabindex="-1">CISC 和 RISC 的基本概念 <a class="header-anchor" href="#cisc-和-risc-的基本概念" aria-label="Permalink to &quot;CISC 和 RISC 的基本概念&quot;">​</a></h2><ol><li>按操作数位置指定风格来分</li></ol><p>1）累加器型指令系统</p><p>总是把其中一个操作数隐含在累加器(一般用 AC 表示)中，指令执行的结果也总是送到累加器中。</p><p>2） 栈型指令系统</p><p>JAVA 虚拟机采用的是栈型指令系统。FILO。操作数总是来自栈顶。通常是零地址或异地址指令。</p><p>3）通用寄存器型指令系统</p><p>使用通用寄存器而不是累加寄存器。其指令的操作数可以是立即数，或来自通用寄存器(R)，或来自存储单元(S)。</p><p>4）load/Store 型指令系统</p><p>也是通过使用通用寄存器来来存放运算过程中的临时数据。只有取数指令和存数指令才可以访问存储器，运算类指令不能访存。</p><ol start="2"><li>指令格式的复杂程度来分</li></ol><p>1）CISC 风格指令系统(complex Instruction Set Computer )</p><p>特点：</p><p>（1）指令系统复杂。指令多，寻址方式多，指令格式多。</p><p>（2）指令周期长。绝大多数指令需要多个时钟周期才能完成。</p><p>（3）指令周期差距大。各种指令都能访问存储器，使得简单指令和复杂指令所用的时钟周期数相差很大，不利于指令流水线。</p><p>（4）采用微程序控制。</p><p>（5）难以进行编译优化。</p><p>2）RISC 风格指令系统 (Reduced Instruction Set Computer)</p><p>（1）指令数目少，只包含使用频度高的简单指令。</p><p>（2）指令格式规整。寻址方式少，指令格式少，指令长度一致</p><p>（3）采用 Load/Store 型指令设计风格。</p><p>（4）采用流水线方式执行指令。</p><p>（5）采用大量通用寄存器。</p><p>（6）采用硬连线控制器。</p><p>（7）采用优化的编译系统。</p><p><strong>CISC 和 RISC 的比较</strong></p><p><img src="/Lyc-notes/assets/CISC%E5%92%8CRISC%E7%9A%84%E6%AF%94%E8%BE%83.CWTWUkCw.png" alt="alt text"></p><h2 id="强化" tabindex="-1">强化 <a class="header-anchor" href="#强化" aria-label="Permalink to &quot;强化&quot;">​</a></h2><ol><li>指令地址的格式</li></ol><p>操作码 地址</p><p>操作码用来标识进行何种操作 地址字段给出进行该操作所需要的数据等信息</p><ol start="2"><li>指令字长</li></ol><p>单字长 半字长 双字长指令（针对于机器字长）</p><ol start="3"><li>指令格式</li></ol><p>零地址：空操作、中断隐指令</p><p>一地址、二地址、三地址、四地址</p><p>根据各地址格式分析访存次数</p><ol start="4"><li>拓展指令格式</li></ol><p>采用可变操作码进行拓展指令格式</p><p>主要思想和计算机网络的子网划分一致，任何短码不不是长码的前缀</p><p>零地址、一地址...对应子网号</p><ol start="5"><li>操作码类型</li></ol><p>数据传送、算术和逻辑运算、移位取反、转移等</p><ol start="6"><li>指令的寻址方式</li></ol><p>寻址方式：确定本条指令的数据地址（解析地址码字段含义即数据寻址）以及下一条待执行指令的地址（指令寻址）</p><ol start="7"><li>指令寻址</li></ol><p>顺序寻址： PC+1（此处的1应为一条指令的长度 所以得确定编址方式 例如按字节编址 指令字长16 则pc+2）</p><p>跳跃寻址：使用转移指令实现，分为绝对转移（直接给出地址），相对转移（PC+偏移），目的都是修改pc的值，下一条指令的地址仍然由pc给出</p><ol start="8"><li>数据寻址</li></ol><p>计算操作数的地址，使用寻址特征字段来表示属于那种寻址方式。</p><p>操作码 寻址特征 形式地址A</p><p>隐含寻址：隐含操作数的地址</p><p>立即数寻址：A即为操作数本身</p><p>直接寻址：A的操作的内存地址 需要访存1次</p><p>间接寻址：A给的操作数地址的地址 需要访存2次</p><p>寄存器寻址：A给出的是寄存器的编号 寄存器内的内容即为操作数 不需要访存</p><p>寄存器间接寻址：A给出的是寄存器的编号 寄存器内的内容为操作数的地址 需要访存1次</p><p>相对寻址：pc + 相对偏移量（补码给出）（计算偏移量和目标地址） <code>pc + “1” + A</code></p><p>基址寻址：基址寄存器BR的内容 + A （基址寄存器的内容不变 由os指定 A可变 一般用于多道程序设计） ` 变址寻址：变址寄存器IX的内容 + A （变址寄存器的内容可变 由用户指定 A不变 一般用于循环和数组）</p><p>相对、基址、变址称为偏移寻址</p><p>堆栈寻址：硬堆栈（寄存器）和软堆栈（内存）堆栈指针SP</p><ol start="9"><li>汇编指令</li></ol><p>常见的寄存器表示 E开头 EAX EBX</p><p>汇编指令的格式 AT&amp;T和Intel格式 （只需要掌握Intel）</p><p>不区分大小写</p><p>第一个为源操作数、第二个为目的操作数 从左到右</p><p>表示寄存器和立即数不需要加前缀</p><p>内存寻址<code>[x]</code> <code>[edx + eax*2 + 8]</code></p><p>指定数据长度b、w、l、（byte ptr word ptr dword ptr）</p><p>mov</p><p>push 将操作数压入内存的栈，ESP代表栈顶，入栈前，ESP先减“4”（栈的增长方向和内存地址增长方向相反）</p><p>pop指令 出栈 ESP +</p><p>add/sub指令</p><p>shl/shr 逻辑移位</p><p>jump 转移指令 IP（指定位置）</p><p>jcondition 条件转移指令</p><p>cmp/test指令</p><p>call/ret</p><p>选择语句的机器级表示 jump 跳转指令 cmp指令</p><p>循环语句的机器级表示 cmp jd</p><p>过程调用的机器级表示：（王道视频课二刷）</p><p>准备阶段 上一个栈的esp指针放入ebp中 完成清栈 指向栈底 方便获取入口参数</p><p>过程体</p><p>结束阶段</p></div></div></main><footer class="VPDocFooter" data-v-68270971 data-v-f4c4c115><!--[--><!--[--><!--[--><!--[--><div class="doc-comments"><!----></div><!--]--><!--]--><!--]--><!--]--><div class="edit-info" data-v-f4c4c115><!----><div class="last-updated" data-v-f4c4c115><p class="VPLastUpdated" data-v-f4c4c115 data-v-270fbc60>上次更新: <time datetime="2024-09-25T09:05:51.000Z" data-v-270fbc60></time></p></div></div><nav class="prev-next" data-v-f4c4c115><div class="pager" data-v-f4c4c115><a class="VPLink link pager-link prev" href="/Lyc-notes/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/chapter3" data-v-f4c4c115><!--[--><span class="desc" data-v-f4c4c115>上一篇</span><span class="title" data-v-f4c4c115>第三章 存储系统</span><!--]--></a></div><div class="pager" data-v-f4c4c115><a class="VPLink link pager-link next" href="/Lyc-notes/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/chapter5" data-v-f4c4c115><!--[--><span class="desc" data-v-f4c4c115>下一篇</span><span class="title" data-v-f4c4c115>第五章 中央处理器</span><!--]--></a></div></nav></footer><!--[--><!--[--><!--[--><div style="" class="m-doc-footer" data-v-694eb995><div class="m-doc-footer-message" data-v-694eb995><img class="visitor" src="https://visitor-badge.laobi.icu/badge?page_id=LynnCen.Lyc-notes./%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/chapter4" title="当前页面累计访问数" onerror="this.style.display=&#39;none&#39;" data-v-694eb995><p data-v-694eb995>如有转载或 CV 的请标注本站原文地址</p></div><p class="m-doc-footer-copyright" data-v-694eb995>Copyright © 2024-present LynnCen</p></div><!--]--><!--]--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-7cb4efe6 data-v-9980e494><div class="container" data-v-9980e494><p class="message" data-v-9980e494>如有转载或 CV 的请标注本站原文地址</p><p class="copyright" data-v-9980e494>Copyright © 2024-present LynnCen</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"javascript_basic_你不知道的js.md\":\"BZ60Fk2L\",\"vue_basic.md\":\"Bio5oO-F\",\"todo_index.md\":\"BpUBnCGX\",\"architecture_jp架构.md\":\"BHCDF8AB\",\"browser_chrome架构.md\":\"BzfQ_QPZ\",\"postgraduate_school.md\":\"DZe2KIT6\",\"browser_导航流程.md\":\"Cgd7QoQK\",\"javascript_advance_browser.md\":\"C0vUJMwn\",\"browser_dom树.md\":\"CDfJbFl1\",\"javascript_advance_executionstack.md\":\"BnvFsaAu\",\"browser_加载阶段性能.md\":\"Cgv0y_Mu\",\"browser_分层和合成.md\":\"CpIZEzfB\",\"browser_变量提升.md\":\"CsvPjOAV\",\"nav_index.md\":\"Ck7vIg4f\",\"index.md\":\"C9PANpb2\",\"interview_browser.md\":\"n2bdMGiX\",\"interview_project.md\":\"SePxsYDx\",\"interview_react.md\":\"QdXhMHDS\",\"interview_typescript.md\":\"DWzsxhVN\",\"interview_webpack.md\":\"-Bcqf521\",\"mobile_pha.md\":\"CnJSH5QF\",\"interview_coding.md\":\"BITuYqez\",\"react_utils_type.md\":\"DxBkvgxq\",\"record_tallking.md\":\"D6WuWj_U\",\"javascript_advance_execution.md\":\"Bh20Vp4H\",\"browser_https.md\":\"BbLOz3pc\",\"browser_performance.md\":\"BsGca_jB\",\"browser_http3.md\":\"DOkfxlge\",\"browser_http1.md\":\"3DqVq762\",\"browser_页面性能.md\":\"ucMSxadT\",\"datastructure_chapter1.md\":\"DMItT4wl\",\"browser_渲染流水线.md\":\"CXw92fg_\",\"browser_调用栈.md\":\"F1as1v-3\",\"browser_跨站脚本攻击xss.md\":\"Su0n5QsI\",\"browser_编译器和解释器.md\":\"Dn-VCFiE\",\"browser_http2.md\":\"BDC6ZWX6\",\"datastructure_chapter2_ex.md\":\"C7CTdNfO\",\"browser_浏览上下文组.md\":\"DEHOdvLj\",\"javascript_advance_executioncontext.md\":\"BxvDROxy\",\"browser_渐进式网页应用pwa.md\":\"CzyHWSGz\",\"browser_作用域链和闭包.md\":\"BbAESXJ6\",\"browser_ introduce.md\":\"DlomH7jB\",\"browser_chrome开发者工具.md\":\"B_7g98pj\",\"browser_消息队列和事件循环.md\":\"BW2uEJT8\",\"architecture_base.md\":\"Ci-iERLM\",\"datastructure_chapter1_ex.md\":\"BL5vloSO\",\"datastructure_chapter2.md\":\"9Ydea7cR\",\"browser_performance中的main指标.md\":\"BBRmiRXm\",\"browser_栈和堆.md\":\"0M7xweVY\",\"browser_虚拟dom.md\":\"DunG3MIG\",\"browser_promise.md\":\"BfDyvCg_\",\"browser_csrf攻击.md\":\"DTtZ_e87\",\"browser_块级作用域.md\":\"C85hu1y4\",\"os_chapter4.md\":\"C0k6q52D\",\"os_chapter2.md\":\"C3j8kc9L\",\"os_chapter3.md\":\"Di9fvqdT\",\"react_core_basic.md\":\"hkdwlWhA\",\"组成原理_chapter7.md\":\"Bcn4-3Lt\",\"browser_http.md\":\"DWA2fezt\",\"browser_同源策略.md\":\"Dpq2i_pq\",\"interview_html.md\":\"CE45tvOD\",\"interview_css.md\":\"V1BUCjqK\",\"react_core_前端ui框架简史.md\":\"DOEw66dR\",\"组成原理_chapter5.md\":\"CZ-ALiPV\",\"react_core_innercore.md\":\"B2vKpcun\",\"react_core_设计理念.md\":\"BzU6bn94\",\"record_amap.md\":\"CE4y0pU0\",\"record_nvm.md\":\"KfXM6OCD\",\"react_record_thinking.md\":\"_3sqF1OF\",\"test.md\":\"fi6TLgn2\",\"typescript_记录.md\":\"CxkuGEdK\",\"typescript_costums.md\":\"B__cDoix\",\"react_core_核心原理.md\":\"OBYNhesJ\",\"browser_垃圾回收.md\":\"DvOcdtgq\",\"utils_utils.md\":\"BGjBO8fP\",\"组成原理_chapter4.md\":\"CyrBJ9a1\",\"webpack_unocss.md\":\"BEXpJARr\",\"webpack_埋点.md\":\"CYIB6Y_d\",\"welcome.md\":\"_pyk8yOH\",\"组成原理_chapter1.md\":\"CNies1jh\",\"browser_this.md\":\"CHPmB-_w\",\"组成原理_chapter2.md\":\"B31zFlYa\",\"组成原理_chapter3.md\":\"ezE0WAb5\",\"react_customhook_hooks.md\":\"BRJajaHb\",\"webpack_performance.md\":\"CftaNsHl\",\"browser_tcp协议.md\":\"CMAW8k9G\",\"datastructure_chapter4.md\":\"BqjEO9iX\",\"datastructure_chapter5.md\":\"B7uGTaGM\",\"组成原理_chapter6.md\":\"BooUDrCT\",\"datastructure_强化.md\":\"B2NxjpOj\",\"docs_hello.md\":\"DtkAFhUR\",\"browser_rendersec.md\":\"CrncNfkj\",\"browser_renderfirst.md\":\"Ck0jIHvo\",\"browser_安全沙箱.md\":\"1DY_gzcs\",\"browser_宏任务和微任务.md\":\"DkLqBMIo\",\"browser_settimeout如何实现.md\":\"B_AakyZY\",\"browser_async_await.md\":\"DCw5BcLG\",\"architecture_iconfont.md\":\"nU-J2ovU\",\"计网_强化.md\":\"BN-ZdDlC\",\"os_chapter1.md\":\"DK_gzIZA\",\"计网_chapter2.md\":\"Zvhf73m9\",\"interview_network.md\":\"Cw3EAr_v\",\"计网_chapter3.md\":\"Bq4PQskG\",\"计网_chapter1.md\":\"BlHdkb27\",\"组成原理_强化.md\":\"BwvE5uDa\",\"datastructure_chapter3.md\":\"DUR1WyjH\",\"os_强化.md\":\"C7I7lcvT\",\"react_core_basestruct.md\":\"rMwgNlqa\",\"browser_xmlhttprequest.md\":\"BBXjuDBz\",\"datastructure_chapter6.md\":\"4nJM1u4r\",\"browser_任务调度.md\":\"BNNvng6r\",\"datastructure_chapter7.md\":\"BN0l65Rp\",\"os_chapter5.md\":\"-m6BRJbG\",\"datastructure_chapter8.md\":\"B5UfN8Ck\",\"interview_js.md\":\"DgOxON88\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"zh-CN\",\"dir\":\"ltr\",\"title\":\"林岑LynnCenʘᴗʘ \",\"description\":\"林岑的成长之路，包含前端常用知识、源码阅读笔记、各种奇淫技巧、日常提效工具等\",\"base\":\"/Lyc-notes/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"i18nRouting\":false,\"logo\":\"/LynnCenLogo.png\",\"nav\":[{\"text\":\"WebFront\",\"items\":[{\"text\":\"Javascript基础\",\"activeMatch\":\"Javascript/basic/\",\"link\":\"Javascript/basic/你不知道的js\"},{\"text\":\"Javascript进阶\",\"activeMatch\":\"Javascript/Advance/\",\"link\":\"Javascript/Advance/executionContext\"},{\"text\":\"Typescript\",\"activeMatch\":\"/typescript/\",\"link\":\"/typescript/记录\"},{\"text\":\"浏览器原理\",\"activeMatch\":\"/browser/\",\"link\":\"/browser/Chrome架构\"}]},{\"text\":\"ComputerBasics\",\"items\":[{\"text\":\"计算机组成原理\",\"items\":[{\"text\":\"计算机组成原理基础\",\"link\":\"/组成原理/chapter1\"}]},{\"text\":\"数据结构\",\"items\":[{\"text\":\"数据结构基础\",\"link\":\"/dataStructure/chapter1\"},{\"text\":\"课后习题\",\"link\":\"/dataStructure/chapter1_ex\"}]},{\"text\":\"操作系统OS\",\"items\":[{\"text\":\"操作系统基础\",\"link\":\"/os/chapter1\"}]},{\"text\":\"计算机网络\",\"items\":[{\"text\":\"计算机网络基础\",\"link\":\"/计网/chapter1\"}]}]},{\"text\":\"Frameworks\",\"items\":[{\"text\":\"React\",\"activeMatch\":\"/react/\",\"link\":\"react/core/basic\"},{\"text\":\"Vue\",\"link\":\"Vue/basic\"}]},{\"text\":\"Engineering\",\"items\":[{\"text\":\"WebPack\",\"activeMatch\":\"/webpack/\",\"link\":\"webpack/performance\"},{\"text\":\"Vite\",\"items\":[]}]},{\"text\":\"Interview\",\"activeMatch\":\"/interview/\",\"link\":\"/interview/js\"}],\"sidebar\":{\"/Javascript/\":[{\"text\":\"JS引擎\",\"link\":\"Javascript/Advance/execution\"},{\"text\":\"调用堆栈\",\"items\":[{\"text\":\"执行上下文和执行栈\",\"link\":\"Javascript/Advance/executionContext\"},{\"text\":\"执行上下文栈和变量对象\",\"link\":\"Javascript/Advance/executionStack\"}]}],\"/react/\":[{\"text\":\"React源码\",\"items\":[{\"text\":\"核心概念\",\"link\":\"/react/core/basic\"},{\"text\":\"设计理念\",\"link\":\"/react/core/设计理念\"},{\"text\":\"内核关系\",\"link\":\"/react/core/innerCore\"},{\"text\":\"基本数据结构\",\"link\":\"/react/core/baseStruct\"}]},{\"text\":\"React实践\",\"items\":[{\"text\":\"思考\",\"link\":\"/react/record/thinking\"},{\"text\":\"自定义Hooks\",\"link\":\"/react/customHook/hooks\"},{\"text\":\"React with TS\",\"link\":\"/react/utils/type\"}]}],\"/interview/\":[{\"text\":\"HTML\",\"link\":\"/interview/html\"},{\"text\":\"CSS\",\"link\":\"/interview/css\"},{\"text\":\"Javascript\",\"link\":\"/interview/js\"},{\"text\":\"React\",\"link\":\"/interview/react\"},{\"text\":\"Typescript\",\"link\":\"/interview/typescript\"},{\"text\":\"WebPack\",\"link\":\"/interview/webpack\"},{\"text\":\"浏览器\",\"link\":\"/interview/browser\"},{\"text\":\"网络\",\"link\":\"/interview/network\"},{\"text\":\"项目总结\",\"link\":\"/project\"},{\"text\":\"笔试题\",\"link\":\"/interview/coding\"}],\"/os/\":[{\"text\":\"操作系统基础\",\"items\":[{\"text\":\"第一章 操作系统引论\",\"link\":\"/os/chapter1\"},{\"text\":\"第二章 进程与线程\",\"link\":\"/os/chapter2\"},{\"text\":\"第三章 内存管理\",\"link\":\"/os/chapter3\"},{\"text\":\"第四章 文件管理\",\"link\":\"/os/chapter4\"},{\"text\":\"第五章 磁盘和固态硬盘\",\"link\":\"/os/chapter5\"}]}],\"/dataStructure/\":[{\"text\":\"数据结构\",\"items\":[{\"text\":\"第一章 绪论\",\"link\":\"/dataStructure/chapter1\"},{\"text\":\"第二章 线性表\",\"link\":\"/dataStructure/chapter2\"},{\"text\":\"第三章 栈、队列和数组\",\"link\":\"/dataStructure/chapter3\"},{\"text\":\"第四章 串\",\"link\":\"/dataStructure/chapter4\"},{\"text\":\"第五章 树与二叉树\",\"link\":\"/dataStructure/chapter5\"},{\"text\":\"第六章 图\",\"link\":\"/dataStructure/chapter6\"},{\"text\":\"第七章 查找\",\"link\":\"/dataStructure/chapter7\"},{\"text\":\"第八章 排序\",\"link\":\"/dataStructure/chapter8\"}]},{\"text\":\"课后习题\",\"items\":[{\"text\":\"第一章 绪论\",\"link\":\"/dataStructure/chapter1_ex\"},{\"text\":\"第二章 线性表\",\"link\":\"/dataStructure/chapter2_ex\"},{\"text\":\"强化\",\"link\":\"/dataStructure/强化\"}]}],\"/组成原理/\":[{\"text\":\"计算机组成原理\",\"items\":[{\"text\":\"第一章 计算机系统概述\",\"link\":\"/组成原理/chapter1\"},{\"text\":\"第二章 数据的表示和运算\",\"link\":\"/组成原理/chapter2\"},{\"text\":\"第三章 存储系统\",\"link\":\"/组成原理/chapter3\"},{\"text\":\"第四章 指令系统\",\"link\":\"/组成原理/chapter4\"},{\"text\":\"第五章 中央处理器\",\"link\":\"/组成原理/chapter5\"},{\"text\":\"第六章 总线\",\"link\":\"/组成原理/chapter6\"},{\"text\":\"第七章 输入/输出系统\",\"link\":\"/组成原理/chapter7\"}]}],\"/webpack/\":[{\"text\":\"WebPack性能优化\",\"link\":\"/webpack/performance\"},{\"text\":\"原子化Css\",\"link\":\"/webpack/unocss\"}],\"/browser/\":[{\"text\":\"宏观视角下的浏览器\",\"items\":[{\"text\":\"Chorme架构\",\"link\":\"/browser/Chrome架构\"},{\"text\":\"TCP协议\",\"link\":\"/browser/TCP协议\"},{\"text\":\"HTTP协议\",\"link\":\"/browser/HTTP\"},{\"text\":\"导航流程\",\"link\":\"/browser/导航流程\"},{\"text\":\"渲染流程（上）\",\"link\":\"/browser/renderfirst\"},{\"text\":\"渲染流程（下）\",\"link\":\"/browser/rendersec\"}]},{\"text\":\"Javascript中的执行机制\",\"items\":[{\"text\":\"变量提升\",\"link\":\"/browser/变量提升\"},{\"text\":\"调用栈\",\"link\":\"/browser/调用栈\"},{\"text\":\"块级作用域\",\"link\":\"/browser/块级作用域\"},{\"text\":\"作用域链和闭包\",\"link\":\"/browser/作用域链和闭包\"},{\"text\":\"This\",\"link\":\"/browser/this\"}]},{\"text\":\"V8工作原理\",\"items\":[{\"text\":\"栈空间和堆空间\",\"link\":\"/browser/栈和堆\"},{\"text\":\"垃圾回收\",\"link\":\"/browser/垃圾回收\"},{\"text\":\"编译器和解释器\",\"link\":\"/browser/编译器和解释器\"}]},{\"text\":\"浏览器中的页面循环系统\",\"items\":[{\"text\":\"消息队列和事件循环\",\"link\":\"/browser/消息队列和事件循环\"},{\"text\":\"setTimeout 是如何实现的？\",\"link\":\"/browser/setTimeout如何实现\"},{\"text\":\"XMLHttpRequest 是怎么实现的？\",\"link\":\"/browser/XMLHttpRequest\"},{\"text\":\"宏任务和微任务\",\"link\":\"/browser/宏任务和微任务\"},{\"text\":\"Promise\",\"link\":\"/browser/Promise\"},{\"text\":\"async/await\",\"link\":\"/browser/async&await\"}]},{\"text\":\"浏览器中的页面\",\"items\":[{\"text\":\"Chrome开发者工具\",\"link\":\"/browser/Chrome开发者工具\"},{\"text\":\"DOM树\",\"link\":\"/browser/DOM树\"},{\"text\":\"渲染流水线\",\"link\":\"/browser/渲染流水线\"},{\"text\":\"分层和合成机制\",\"link\":\"/browser/分层和合成\"},{\"text\":\"页面性能\",\"link\":\"/browser/页面性能\"},{\"text\":\"虚拟DOM\",\"link\":\"/browser/虚拟DOM\"},{\"text\":\"渐进式网页应用PWA\",\"link\":\"/browser/渐进式网页应用PWA\"}]},{\"text\":\"浏览器中的网络\",\"items\":[{\"text\":\"HTTP1\",\"link\":\"/browser/HTTP1\"},{\"text\":\"HTTP2\",\"link\":\"/browser/HTTP2\"},{\"text\":\"HTTP3\",\"link\":\"/browser/HTTP3\"}]},{\"text\":\"浏览器安全\",\"items\":[{\"text\":\"同源策略\",\"link\":\"/browser/同源策略\"},{\"text\":\"跨站脚本攻击XSS\",\"link\":\"/browser/跨站脚本攻击XSS\"},{\"text\":\"CSRF攻击\",\"link\":\"/browser/CSRF攻击\"},{\"text\":\"安全沙箱\",\"link\":\"/browser/安全沙箱\"},{\"text\":\"HTTPS\",\"link\":\"/browser/HTTPS\"}]},{\"text\":\"浏览上下文组\",\"link\":\"/browser/浏览上下文组\"},{\"text\":\"任务调度\",\"link\":\"/browser/任务调度\"},{\"text\":\"加载阶段性能\",\"link\":\"/browser/加载阶段性能\"},{\"text\":\"Performance\",\"link\":\"/browser/Performance\"},{\"text\":\"Performance中的Main指标\",\"link\":\"/browser/Performance中的Main指标\"}],\"/计网/\":[{\"text\":\"计算机组成原理\",\"items\":[{\"text\":\"第一章 计算机网络体系结构\",\"link\":\"/计网/chapter1\"},{\"text\":\"第二章 物理层\",\"link\":\"/计网/chapter2\"},{\"text\":\"第三章 数据链路层\",\"link\":\"/计网/chapter3\"}]}]},\"search\":{\"provider\":\"local\"},\"outline\":{\"level\":\"deep\",\"label\":\"本页目录\"},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/LynnCen\"}],\"footer\":{\"message\":\"如有转载或 CV 的请标注本站原文地址\",\"copyright\":\"Copyright © 2024-present LynnCen\"},\"darkModeSwitchLabel\":\"外观\",\"returnToTopLabel\":\"返回顶部\",\"lastUpdatedText\":\"上次更新\",\"docFooter\":{\"prev\":\"上一篇\",\"next\":\"下一篇\"},\"visitor\":{\"badgeId\":\"LynnCen.Lyc-notes\"},\"comment\":{\"repo\":\"LynnCen/Lyc-notes\",\"repoId\":\"R_kgDOLsOwUg\",\"category\":\"Announcements\",\"categoryId\":\"DIC_kwDOLsOwUs4CenzY\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":true}");</script>
    
  </body>
</html>