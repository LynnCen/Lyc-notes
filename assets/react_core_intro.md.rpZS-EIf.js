import{_ as o,C as p,c as B,o as a,a8 as A,b as n,j as l,w as i,a as e,G as E,a9 as r}from"./chunks/framework.5lfeZbzV.js";const C=JSON.parse('{"title":"⚛️ React 全流程深度解析","description":"","frontmatter":{},"headers":[],"relativePath":"react/core/intro.md","filePath":"react/core/intro.md","lastUpdated":1745249207000}'),k={name:"react/core/intro.md"};function h(d,s,c,g,f,u){const t=p("Mermaid");return a(),B("div",null,[s[11]||(s[11]=A('<h1 id="⚛️-react-全流程深度解析" tabindex="-1">⚛️ React 全流程深度解析 <a class="header-anchor" href="#⚛️-react-全流程深度解析" aria-label="Permalink to &quot;⚛️ React 全流程深度解析&quot;">​</a></h1><p>React 以其声明式编程、组件化和高效的 DOM 更新机制，彻底改变了现代前端开发。但你是否曾好奇，从你写下 <code>&lt;MyComponent /&gt;</code> 到用户在屏幕上与之交互，这背后究竟发生了一场怎样精密而高效的&quot;演出&quot;？</p><p>本文旨在为你揭开 React 的神秘面纱，完整地梳理一个 React 应用从源代码到最终在浏览器中呈现并响应用户交互的<strong>全流程</strong>。无论你是希望巩固基础的 React 新手，还是寻求更深层次理解的资深开发者，这篇文章都将带你领略 React 工作流的每个关键环节。</p><p><strong>我们将一起探索：</strong></p><ol><li><strong>开发与构建阶段：</strong> JSX 如何变成浏览器能理解的代码？</li><li><strong>浏览器加载阶段：</strong> HTML 和 JavaScript 如何被加载和执行？</li><li><strong>首次渲染（Mount）阶段：</strong> React 如何将组件&quot;绘制&quot;到屏幕上？</li><li><strong>状态更新与触发：</strong> <code>setState</code> 或 <code>useState</code> 如何启动更新流程？</li><li><strong>重新渲染与协调（Reconciliation）阶段：</strong> React 如何高效地更新变化的部分？</li><li><strong>卸载（Unmount）阶段：</strong> 组件消失时会发生什么？</li><li><strong>现代特性概览：</strong> 并发模式、SSR/Streaming 等如何融入流程？</li></ol><h2 id="react-生态系统与包结构" tabindex="-1">React 生态系统与包结构 <a class="header-anchor" href="#react-生态系统与包结构" aria-label="Permalink to &quot;React 生态系统与包结构&quot;">​</a></h2><p>在深入流程之前，让我们先了解 React 的核心包结构。React 采用模块化设计，由多个专注于特定功能的包组成。</p>',7)),(a(),n(r,null,{default:i(()=>[E(t,{id:"mermaid-55",class:"mermaid",graph:"graph%20TD%0A%20%20%20%20A%5BReact%E5%BA%94%E7%94%A8%5D%20--%3E%20B%5Breact%5D%0A%20%20%20%20A%20--%3E%20C%5Breact-dom%5D%0A%20%20%20%20A%20--%3E%20D%5Breact-native%5D%0A%20%20%20%20%0A%20%20%20%20B%20--%3E%20E%5Breact-reconciler%5D%0A%20%20%20%20C%20--%3E%20E%0A%20%20%20%20D%20--%3E%20E%0A%20%20%20%20%0A%20%20%20%20E%20--%3E%20F%5Bscheduler%5D%0A%20%20%20%20%0A%20%20%20%20B%20--%3E%20G%5Breact-events%5D%0A%20%20%20%20%0A%20%20%20%20style%20B%20fill%3A%2361dafb%2Cstroke%3A%23282c34%2Ccolor%3A%23282c34%0A%20%20%20%20style%20C%20fill%3A%2361dafb%2Cstroke%3A%23282c34%2Ccolor%3A%23282c34%0A%20%20%20%20style%20D%20fill%3A%2361dafb%2Cstroke%3A%23282c34%2Ccolor%3A%23282c34%0A%20%20%20%20style%20E%20fill%3A%238ed6fb%2Cstroke%3A%23282c34%2Ccolor%3A%23282c34%0A%20%20%20%20style%20F%20fill%3A%238ed6fb%2Cstroke%3A%23282c34%2Ccolor%3A%23282c34%0A%20%20%20%20style%20G%20fill%3A%238ed6fb%2Cstroke%3A%23282c34%2Ccolor%3A%23282c34%0A"})]),fallback:i(()=>[...s[0]||(s[0]=[e(" Loading... ",-1)])]),_:1})),s[12]||(s[12]=A(`<p><strong>核心包及其职责：</strong></p><ul><li><strong>react</strong>: 定义核心API，如React.createElement、Hooks等，但不含具体平台渲染逻辑</li><li><strong>react-dom</strong>: 针对浏览器环境的渲染器，将React组件渲染为DOM</li><li><strong>react-native</strong>: 针对移动平台的渲染器，将React组件渲染为原生视图</li><li><strong>react-reconciler</strong>: 实现协调算法，构建和比较Fiber树</li><li><strong>scheduler</strong>: 调度系统，根据优先级调度不同的工作</li><li><strong>react-events</strong>: 管理合成事件系统</li></ul><hr><h2 id="阶段一-编写代码与构建打包" tabindex="-1">阶段一：编写代码与构建打包 <a class="header-anchor" href="#阶段一-编写代码与构建打包" aria-label="Permalink to &quot;阶段一：编写代码与构建打包&quot;">​</a></h2><p>一切始于开发者编写的代码。</p><ol><li><strong>编写组件与 JSX:</strong><ul><li>开发者使用 JavaScript (或 TypeScript) 编写 React 组件（函数组件或类组件）。</li><li>使用 JSX 这种类似 HTML 的语法糖来声明式地描述 UI 结构。</li></ul></li></ol><div class="language-jsx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // src/MyComponent.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React, { useState } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">message</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> className</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;my-component&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{message}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Count: {count}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">c</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            Increment</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MyComponent;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><ol start="2"><li><strong>编译转换 (Transpilation):</strong><ul><li>由于浏览器不认识 JSX 和可能使用的现代 JavaScript 语法（如 ES6+），我们需要<strong>编译器</strong>（通常是 <strong>Babel</strong>）介入。</li><li>Babel 将 JSX 转换为 <code>React.createElement()</code> 函数调用。</li><li>同时，它也会将 ES6+ 语法转换为浏览器兼容性更好的 ES5 语法（根据配置）。</li></ul></li></ol><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // JSX 转换示例 (概念性)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // &lt;h1 className=&quot;greeting&quot;&gt;Hello&lt;/h1&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 编译为 -&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;h1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { className: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;greeting&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol start="3"><li><strong>模块打包 (Bundling):</strong><ul><li>现代前端项目通常由许多模块（JS 文件、CSS 文件、图片等）组成。</li><li><strong>打包工具</strong>（如 <strong>Webpack</strong>, <strong>Vite</strong>, <strong>Parcel</strong>, <strong>Rollup</strong>）会分析项目依赖关系，将所有需要的模块打包成一个或多个优化过的静态资源文件（通常称为 Bundles），主要是 JavaScript 和 CSS 文件。</li><li>打包过程还可能包括代码压缩、混淆、代码分割（Code Splitting）、Tree Shaking（移除未使用的代码）等优化步骤。</li></ul></li></ol><p>产出： 最终生成 index.html 文件以及一个或多个 JavaScript 和 CSS 文件（Bundles），准备部署到服务器。</p>`,11)),(a(),n(r,null,{default:i(()=>[E(t,{id:"mermaid-170",class:"mermaid",graph:"flowchart%20LR%0A%20%20%20%20A1%5BReact%20Components%5CnJSX%20%26%20ES6%2B%5D%0A%20%20%20%20A2%5BCSS%2FSCSS%5D%0A%20%20%20%20A3%5BAssets%5D%0A%20%20%20%20B1%5BBabel%5D%0A%20%20%20%20B2%5BCSS%20Processor%5D%0A%20%20%20%20C%5BWebpack%2FVite%5D%0A%20%20%20%20D1%5BJS%20Bundles%5D%0A%20%20%20%20D2%5BCSS%20Bundle%5D%0A%20%20%20%20D3%5BAssets%5D%0A%20%20%20%20D4%5Bindex.html%5D%0A%0A%20%20%20%20A1%20--%3E%20B1%0A%20%20%20%20A2%20--%3E%20B2%0A%20%20%20%20A3%20--%3E%20C%0A%20%20%20%20B1%20--%3E%20C%0A%20%20%20%20B2%20--%3E%20C%0A%20%20%20%20C%20--%3E%20D1%0A%20%20%20%20C%20--%3E%20D2%0A%20%20%20%20C%20--%3E%20D3%0A%20%20%20%20C%20--%3E%20D4%0A%0A%20%20%20%20style%20A1%20fill%3A%23e1f5fe%2Cstroke%3A%2301579b%0A%20%20%20%20style%20A2%20fill%3A%23e1f5fe%2Cstroke%3A%2301579b%0A%20%20%20%20style%20A3%20fill%3A%23e1f5fe%2Cstroke%3A%2301579b%0A%20%20%20%20style%20B1%20fill%3A%23fff3e0%2Cstroke%3A%23ff6f00%0A%20%20%20%20style%20B2%20fill%3A%23fff3e0%2Cstroke%3A%23ff6f00%0A%20%20%20%20style%20C%20fill%3A%23f3e5f5%2Cstroke%3A%237b1fa2%0A%20%20%20%20style%20D1%20fill%3A%23e8f5e9%2Cstroke%3A%232e7d32%0A%20%20%20%20style%20D2%20fill%3A%23e8f5e9%2Cstroke%3A%232e7d32%0A%20%20%20%20style%20D3%20fill%3A%23e8f5e9%2Cstroke%3A%232e7d32%0A%20%20%20%20style%20D4%20fill%3A%23e8f5e9%2Cstroke%3A%232e7d32%0A"})]),fallback:i(()=>[...s[1]||(s[1]=[e(" Loading... ",-1)])]),_:1})),s[13]||(s[13]=A('<h2 id="阶段二-浏览器加载与执行" tabindex="-1">阶段二：浏览器加载与执行 <a class="header-anchor" href="#阶段二-浏览器加载与执行" aria-label="Permalink to &quot;阶段二：浏览器加载与执行&quot;">​</a></h2><p>用户访问应用时，浏览器开始工作。</p><ol><li><strong>请求 HTML</strong>: 浏览器向服务器请求入口 index.html 文件。</li><li><strong>解析 HTML</strong>: 浏览器接收并开始解析 HTML。遇到 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt; </code>时，会异步下载 CSS 文件。遇到 <code>&lt;script src=&quot;...&quot;&gt; </code>时（如果不是 defer 或 async），会暂停 HTML 解析，下载并执行 JavaScript。现代实践通常将 <code>&lt;script&gt; </code>标签放在 <code>&lt;body&gt; </code>底部或使用 defer 属性，以避免阻塞页面渲染。</li><li><strong>下载资源</strong>: 浏览器下载 HTML 中引用的 CSS 和 JavaScript Bundles。</li><li><strong>构建 DOM 和 CSSOM</strong>: 浏览器解析 HTML 构建 DOM (Document Object Model) 树，解析 CSS 构建 CSSOM (CSS Object Model) 树。两者结合形成 Render Tree（渲染树）。</li><li><strong>执行 JavaScript</strong>: 下载完成后，浏览器执行 JavaScript Bundles。React 的代码开始运行！</li></ol>',3)),(a(),n(r,null,{default:i(()=>[E(t,{id:"mermaid-204",class:"mermaid",graph:"sequenceDiagram%0A%20%20%20%20participant%20Browser%0A%20%20%20%20participant%20Server%0A%20%20%20%20participant%20DOM%0A%20%20%20%20participant%20JS%0A%20%20%20%20%0A%20%20%20%20Browser-%3E%3EServer%3A%20%E8%AF%B7%E6%B1%82HTML%0A%20%20%20%20Server-%3E%3EBrowser%3A%20%E8%BF%94%E5%9B%9EHTML%0A%20%20%20%20Browser-%3E%3EDOM%3A%20%E5%BC%80%E5%A7%8B%E8%A7%A3%E6%9E%90HTML%0A%20%20%20%20Browser-%3E%3EServer%3A%20%E8%AF%B7%E6%B1%82CSS%E5%92%8CJS%E8%B5%84%E6%BA%90%0A%20%20%20%20Server-%3E%3EBrowser%3A%20%E8%BF%94%E5%9B%9E%E8%B5%84%E6%BA%90%0A%20%20%20%20Browser-%3E%3EDOM%3A%20%E6%9E%84%E5%BB%BADOM%E6%A0%91%0A%20%20%20%20Browser-%3E%3EDOM%3A%20%E6%9E%84%E5%BB%BACSSOM%E6%A0%91%0A%20%20%20%20Browser-%3E%3EJS%3A%20%E6%89%A7%E8%A1%8CJavaScript%0A%20%20%20%20JS-%3E%3EDOM%3A%20React%E6%8E%A5%E7%AE%A1%E6%8C%87%E5%AE%9ADOM%E8%8A%82%E7%82%B9%0A%20%20%20%20%0A%20%20%20%20Note%20over%20JS%3A%20React%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BC%80%E5%A7%8B%0A"})]),fallback:i(()=>[...s[2]||(s[2]=[e(" Loading... ",-1)])]),_:1})),s[14]||(s[14]=A(`<h2 id="阶段三-首次渲染-mount-react接管ui" tabindex="-1">阶段三：首次渲染（Mount）- React接管UI <a class="header-anchor" href="#阶段三-首次渲染-mount-react接管ui" aria-label="Permalink to &quot;阶段三：首次渲染（Mount）- React接管UI&quot;">​</a></h2><p>这是 React 展示其魔法的第一个关键阶段。通常由入口文件（如 src/index.js）中的代码启动。</p><ol><li>调用 <code>createRoot().render()</code>：</li></ol><ul><li>React 18+ 的标准入口方式。<code>ReactDOM.createRoot(container)</code> 选择一个 DOM 容器节点，并创建一个 React 根。</li><li><code>root.render(&lt;App /&gt;) </code>指示 React 将 <code>&lt;App /&gt; </code>组件渲染到这个根中</li></ul><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// src/index.js (或类似入口文件)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ReactDOM </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react-dom/client&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> App </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./App&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 根组件</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> container</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;root&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> root</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ReactDOM.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createRoot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(container);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">root.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">App</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ol start="2"><li><strong>创建 React Element 树 (Virtual DOM):</strong></li></ol><ul><li><code>render()</code> 函数接收到 <code>&lt;App /&gt;</code> 这个 <code>React Element</code>。</li><li>React 开始调用组件（如 App 函数）并执行其代码。</li><li>组件返回 JSX，通过 <code>React.createElement()</code>（或编译器优化后的 jsx() 函数）创建描述 UI 结构的 React Element 对象树。这就是我们常说的 <strong>Virtual DOM</strong> 的一种内存表示。它只是普通的 JavaScript 对象，非常轻量。</li></ul><ol start="3"><li><strong>进入协调阶段 (Reconciliation) - 构建 Fiber 树:</strong></li></ol><ul><li><strong>Fiber 架构:</strong> React 使用称为 Fiber 的内部架构来管理渲染工作。Fiber 节点不仅包含了组件类型、props、state 等信息，还维护了组件之间的关系（child, sibling, return 指针），并作为可中断、可恢复的工作单元。</li><li><strong>首次挂载:</strong> React 从根节点开始，遍历 React Element 树，为每个 Element 创建一个对应的 Fiber 节点，构建起<strong>第一个 Fiber 树 (Work-in-Progress Tree)</strong>。这个过程发生在 Render 阶段。</li><li>在此过程中，如果是类组件，会创建实例；如果是函数组件，会执行函数。</li></ul><ol start="4"><li><strong>提交阶段 (Commit):</strong></li></ol><ul><li>当整个 Fiber 树构建（或更新）完成后，React 进入 <strong>Commit 阶段</strong>。这个阶段是<strong>同步且不可中断</strong>的。</li><li><strong>DOM 操作:</strong> React 根据 Fiber 树的信息，计算出需要执行的所有 DOM 操作（因为是首次渲染，主要是创建节点、设置属性）。</li><li><strong>真实 DOM 构建:</strong> React 调用浏览器 DOM API (如 document.createElement, appendChild, setAttribute 等) 将 Fiber 节点映射为<strong>真实的 DOM 节点</strong>，并将它们插入到 createRoot 指定的容器中。</li><li><strong>生命周期/Effect 执行:</strong><ul><li>componentDidMount (类组件) 被调用。</li><li>useLayoutEffect 的回调函数同步执行。</li><li>useEffect 的回调函数被调度在稍后（浏览器绘制之后）异步执行。</li><li>ref 被附加到对应的 DOM 节点或类组件实例上。</li></ul></li></ul>`,11)),(a(),n(r,null,{default:i(()=>[E(t,{id:"mermaid-330",class:"mermaid",graph:"flowchart%20TD%0A%20%20%20%20A%5BcreateRoot().render()%5D%20--%3E%20B%5B%E5%88%9B%E5%BB%BAReact%20Element%E6%A0%91%5D%0A%20%20%20%20B%20--%3E%20C%5BReact%E5%8D%8F%E8%B0%83%E8%BF%87%E7%A8%8B%5D%0A%20%20%20%20C%20--%3E%20D%5B%E6%9E%84%E5%BB%BAFiber%E6%A0%91%5D%0A%20%20%20%20D%20--%3E%20E%5Bcommit%E9%98%B6%E6%AE%B5%20-%20DOM%E6%9B%B4%E6%96%B0%5D%0A%20%20%20%20E%20--%3E%20F%5B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2FEffect%E6%89%A7%E8%A1%8C%5D%0A%20%20%20%20F%20--%3E%20G%5B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%98%E5%88%B6%5D%0A%20%20%20%20%0A%20%20%20%20C%20-.-%3E%20H%5BFiber%E6%A0%91%E7%BC%93%E5%AD%98%5D%0A%20%20%20%20%0A%20%20%20%20style%20A%20fill%3A%23e8f5e9%2Cstroke%3A%232e7d32%0A%20%20%20%20style%20B%20fill%3A%23e8f5e9%2Cstroke%3A%232e7d32%0A%20%20%20%20style%20C%20fill%3A%23fff3e0%2Cstroke%3A%23ff6f00%0A%20%20%20%20style%20D%20fill%3A%23fff3e0%2Cstroke%3A%23ff6f00%0A%20%20%20%20style%20E%20fill%3A%23e1f5fe%2Cstroke%3A%2301579b%0A%20%20%20%20style%20F%20fill%3A%23e1f5fe%2Cstroke%3A%2301579b%0A%20%20%20%20style%20G%20fill%3A%23f3e5f5%2Cstroke%3A%237b1fa2%0A%20%20%20%20style%20H%20fill%3A%23fff3e0%2Cstroke%3A%23ff6f00%2Cstroke-dasharray%3A%205%205%0A"})]),fallback:i(()=>[...s[3]||(s[3]=[e(" Loading... ",-1)])]),_:1})),s[15]||(s[15]=A('<h2 id="阶段四-状态更新与触发" tabindex="-1">阶段四：状态更新与触发 <a class="header-anchor" href="#阶段四-状态更新与触发" aria-label="Permalink to &quot;阶段四：状态更新与触发&quot;">​</a></h2><p>React 应用是动态的，需要响应用户交互或其他事件。当状态发生变化时，React 需要高效地更新 UI。</p><ol><li><p><strong>更新触发方式:</strong></p><ul><li>类组件: <code>this.setState()</code></li><li>函数组件: <code>useState</code> 的 setter 函数、<code>useReducer</code> 的 dispatch</li><li>Context: <code>Context.Provider</code> 的 value 变化</li><li>强制更新: <code>forceUpdate()</code> 或 reducer 返回完全相同的状态</li></ul></li><li><p><strong>事件处理系统:</strong></p><ul><li>React 实现了合成事件（Synthetic Events）系统，它是原生 DOM 事件系统的跨浏览器包装器</li><li>事件委托: React 会把几乎所有事件都委托到 document 级别（React 17+改为 root 容器级别）</li><li>事件处理程序中调用的状态更新会触发重新渲染</li></ul></li></ol>',3)),(a(),n(r,null,{default:i(()=>[E(t,{id:"mermaid-388",class:"mermaid",graph:"sequenceDiagram%0A%20%20%20%20participant%20User%0A%20%20%20%20participant%20Event%20as%20%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F%0A%20%20%20%20participant%20Component%20as%20React%E7%BB%84%E4%BB%B6%0A%20%20%20%20participant%20Scheduler%20as%20%E8%B0%83%E5%BA%A6%E5%99%A8%0A%20%20%20%20participant%20Queue%20as%20%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97%0A%20%20%20%20%0A%20%20%20%20User-%3E%3EEvent%3A%20%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6(%E7%82%B9%E5%87%BB%E7%AD%89)%0A%20%20%20%20Event-%3E%3EComponent%3A%20%E8%B0%83%E7%94%A8%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%0A%20%20%20%20Component-%3E%3EQueue%3A%20%E8%B0%83%E7%94%A8setState%2FuseState%20setter%0A%20%20%20%20Queue-%3E%3EScheduler%3A%20%E5%88%9B%E5%BB%BA%E6%9B%B4%E6%96%B0%EF%BC%8C%E5%8A%A0%E5%85%A5%E9%98%9F%E5%88%97%0A%20%20%20%20Scheduler-%3E%3EComponent%3A%20%E8%B0%83%E5%BA%A6%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93%0A%20%20%20%20Note%20over%20Queue%2CScheduler%3A%20%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%0A"})]),fallback:i(()=>[...s[4]||(s[4]=[e(" Loading... ",-1)])]),_:1})),s[16]||(s[16]=A('<h2 id="阶段五-重新渲染与协调-高效更新" tabindex="-1">阶段五：重新渲染与协调 - 高效更新 <a class="header-anchor" href="#阶段五-重新渲染与协调-高效更新" aria-label="Permalink to &quot;阶段五：重新渲染与协调 - 高效更新&quot;">​</a></h2><p>当状态更新后，React 会启动重新渲染流程。这一流程与首次渲染类似，但包含一个关键差异：React 会比较新旧两棵树，只更新必要的部分。</p><ol><li><p><strong>启动更新:</strong></p><ul><li>状态更新会被加入队列，并触发调度器进行调度</li><li>根据更新的优先级决定何时处理（并发特性）</li></ul></li><li><p><strong>Render 阶段:</strong></p><ul><li>重新执行对应组件的渲染函数，生成新的 React Elements 树</li><li>创建一棵新的 &quot;work-in-progress&quot; Fiber 树</li><li>执行 <strong>协调算法 (Reconciliation)</strong> 来比较当前Fiber树与新的Elements树</li></ul></li><li><p><strong>Diffing 算法:</strong></p><ul><li>基于两个假设: <ol><li>不同类型的元素会产生不同的树</li><li>开发者可以通过 <code>key</code> 属性暗示哪些子元素在不同渲染中保持稳定</li></ol></li><li>逐层比较: <ul><li>不同类型的元素: 拆除旧树，建立新树</li><li>相同类型的DOM元素: 只更新改变的属性</li><li>相同类型的组件元素: 更新props，并递归继续比较</li></ul></li><li>列表diffing: 使用key高效识别移动、添加或删除的项</li></ul></li><li><p><strong>Commit 阶段:</strong></p><ul><li>与首次渲染类似，但只对需要更新的部分执行DOM操作</li><li>可能涉及的操作: <ul><li>更新现有DOM节点属性</li><li>插入新DOM节点</li><li>移动或删除现有DOM节点</li></ul></li><li>执行更新相关的生命周期/Effect: <ul><li>componentDidUpdate</li><li>useLayoutEffect (同步执行)</li><li>useEffect (稍后异步执行)</li></ul></li></ul></li></ol>',3)),(a(),n(r,null,{default:i(()=>[E(t,{id:"mermaid-543",class:"mermaid",graph:"flowchart%20TD%0A%20%20%20%20A%5B%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%5D%20--%3E%20B%5B%E8%B0%83%E5%BA%A6%E6%9B%B4%E6%96%B0%5D%0A%20%20%20%20B%20--%3E%20C%5BRender%E9%98%B6%E6%AE%B5%5D%0A%20%20%20%20C%20--%3E%20D%5B%E6%89%A7%E8%A1%8C%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%5Cn%E7%94%9F%E6%88%90%E6%96%B0Elements%5D%0A%20%20%20%20D%20--%3E%20E%5B%E6%9E%84%E5%BB%BA%E6%96%B0%E7%9A%84WIP%20Fiber%E6%A0%91%5D%0A%20%20%20%20E%20--%3E%20F%5BDiffing%E7%AE%97%E6%B3%95%5Cn%E6%AF%94%E8%BE%83%E6%96%B0%E6%97%A7Fiber%5D%0A%20%20%20%20F%20--%3E%20G%5B%E6%94%B6%E9%9B%86%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84DOM%E6%93%8D%E4%BD%9C%5D%0A%20%20%20%20G%20--%3E%20H%5BCommit%E9%98%B6%E6%AE%B5%5D%0A%20%20%20%20H%20--%3E%20I%5B%E6%89%A7%E8%A1%8CDOM%E6%9B%B4%E6%96%B0%5D%0A%20%20%20%20I%20--%3E%20J%5B%E8%B0%83%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2FEffect%5D%0A%20%20%20%20%0A%20%20%20%20subgraph%20%22Diffing%E7%AD%96%E7%95%A5%22%0A%20%20%20%20%20%20%20%20K%5B%E6%AF%94%E8%BE%83%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B%5D%0A%20%20%20%20%20%20%20%20L%5B%E6%AF%94%E8%BE%83%E5%B1%9E%E6%80%A7%5D%0A%20%20%20%20%20%20%20%20M%5B%E5%A4%84%E7%90%86%E5%AD%90%E5%85%83%E7%B4%A0(key)%5D%0A%20%20%20%20end%0A%20%20%20%20%0A%20%20%20%20F%20-.-%3E%20K%0A%20%20%20%20%0A%20%20%20%20style%20A%20fill%3A%23e8f5e9%2Cstroke%3A%232e7d32%0A%20%20%20%20style%20B%20fill%3A%23e8f5e9%2Cstroke%3A%232e7d32%0A%20%20%20%20style%20C%20fill%3A%23fff3e0%2Cstroke%3A%23ff6f00%0A%20%20%20%20style%20F%20fill%3A%23f44336%2Cstroke%3A%23b71c1c%2Ccolor%3Awhite%0A%20%20%20%20style%20H%20fill%3A%23e1f5fe%2Cstroke%3A%2301579b%0A%20%20%20%20style%20K%20fill%3A%23fff3e0%2Cstroke%3A%23ff6f00%2Cstroke-dasharray%3A%205%205%0A%20%20%20%20style%20L%20fill%3A%23fff3e0%2Cstroke%3A%23ff6f00%2Cstroke-dasharray%3A%205%205%0A%20%20%20%20style%20M%20fill%3A%23fff3e0%2Cstroke%3A%23ff6f00%2Cstroke-dasharray%3A%205%205%0A"})]),fallback:i(()=>[...s[5]||(s[5]=[e(" Loading... ",-1)])]),_:1})),s[17]||(s[17]=A('<h2 id="阶段六-卸载-unmount-阶段" tabindex="-1">阶段六：卸载（Unmount）阶段 <a class="header-anchor" href="#阶段六-卸载-unmount-阶段" aria-label="Permalink to &quot;阶段六：卸载（Unmount）阶段&quot;">​</a></h2><p>在某些情况下，组件需要从UI中移除。例如：</p><ul><li>条件渲染的条件改变</li><li>组件被从列表中移除</li><li>用户导航到另一个页面</li><li>整个应用程序关闭</li></ul><p>卸载过程：</p><ol><li><p><strong>触发卸载:</strong></p><ul><li>父组件决定不再渲染某个子组件</li><li>在Diffing过程中，React发现某个元素不再存在</li></ul></li><li><p><strong>清理工作:</strong></p><ul><li>递归处理组件树，对每个需要卸载的组件： <ul><li>类组件: 调用 <code>componentWillUnmount</code> 生命周期</li><li>函数组件: 执行 <code>useEffect</code> 返回的清理函数</li></ul></li><li>解除引用，避免内存泄漏</li><li>移除事件监听器和订阅</li></ul></li><li><p><strong>DOM移除:</strong></p><ul><li>在commit阶段，从DOM中移除对应的节点</li><li>移除与该节点相关的所有事件处理程序</li></ul></li></ol>',5)),(a(),n(r,null,{default:i(()=>[E(t,{id:"mermaid-645",class:"mermaid",graph:"sequenceDiagram%0A%20%20%20%20participant%20Component%20as%20React%E7%BB%84%E4%BB%B6%0A%20%20%20%20participant%20Fiber%20as%20Fiber%E8%8A%82%E7%82%B9%0A%20%20%20%20participant%20Effect%20as%20Effect%E6%B8%85%E7%90%86%0A%20%20%20%20participant%20DOM%20as%20DOM%E6%A0%91%0A%20%20%20%20%0A%20%20%20%20Note%20over%20Component%3A%20%E5%8D%B8%E8%BD%BD%E6%9D%A1%E4%BB%B6%E6%88%90%E7%AB%8B%0A%20%20%20%20Component-%3E%3EFiber%3A%20%E6%A0%87%E8%AE%B0%E9%9C%80%E8%A6%81%E5%88%A0%E9%99%A4%0A%20%20%20%20Fiber-%3E%3EEffect%3A%20%E6%89%A7%E8%A1%8C%E6%B8%85%E7%90%86%E5%87%BD%E6%95%B0%2F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%0A%20%20%20%20Effect-%3E%3EFiber%3A%20%E6%B8%85%E7%90%86%E5%AE%8C%E6%88%90%0A%20%20%20%20Fiber-%3E%3EDOM%3A%20%E7%A7%BB%E9%99%A4DOM%E8%8A%82%E7%82%B9%0A%20%20%20%20DOM-%3E%3EDOM%3A%20%E8%A7%A3%E9%99%A4%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%0A"})]),fallback:i(()=>[...s[6]||(s[6]=[e(" Loading... ",-1)])]),_:1})),s[18]||(s[18]=l("h2",{id:"阶段七-现代特性概览",tabindex:"-1"},[e("阶段七：现代特性概览 "),l("a",{class:"header-anchor",href:"#阶段七-现代特性概览","aria-label":'Permalink to "阶段七：现代特性概览"'},"​")],-1)),s[19]||(s[19]=l("p",null,"React 不断发展，引入了许多现代特性以提升性能和开发体验。",-1)),s[20]||(s[20]=l("h3",{id:"并发模式-concurrent-mode",tabindex:"-1"},[e("并发模式 (Concurrent Mode) "),l("a",{class:"header-anchor",href:"#并发模式-concurrent-mode","aria-label":'Permalink to "并发模式 (Concurrent Mode)"'},"​")],-1)),s[21]||(s[21]=l("p",null,"React 18 引入的最重要特性，使 React 能够准备多个版本的 UI，而不阻塞主线程。",-1)),(a(),n(r,null,{default:i(()=>[E(t,{id:"mermaid-658",class:"mermaid",graph:"flowchart%20TD%0A%20%20%20%20A%5B%E5%B9%B6%E5%8F%91%E7%89%B9%E6%80%A7%5D%20--%3E%20B%5B%E6%97%B6%E9%97%B4%E5%88%87%E7%89%87%5D%0A%20%20%20%20A%20--%3E%20C%5B%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%5D%0A%20%20%20%20A%20--%3E%20D%5B%E5%8F%AF%E4%B8%AD%E6%96%AD%E6%B8%B2%E6%9F%93%5D%0A%20%20%20%20%0A%20%20%20%20B%20--%3E%20E%5B%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92%E4%BF%9D%E6%8C%81%E5%93%8D%E5%BA%94%5D%0A%20%20%20%20C%20--%3E%20F%5B%E9%87%8D%E8%A6%81%E6%9B%B4%E6%96%B0%E4%BC%98%E5%85%88%E5%A4%84%E7%90%86%5D%0A%20%20%20%20D%20--%3E%20G%5B%E5%8F%AF%E4%BB%A5%E6%9A%82%E5%81%9C%E5%B9%B6%E6%81%A2%E5%A4%8D%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%5D%0A%20%20%20%20%0A%20%20%20%20style%20A%20fill%3A%2361dafb%2Cstroke%3A%23282c34%2Ccolor%3A%23282c34%0A"})]),fallback:i(()=>[...s[7]||(s[7]=[e(" Loading... ",-1)])]),_:1})),s[22]||(s[22]=A('<p>核心机制：</p><ul><li><strong>时间切片：</strong> 将长任务分割成小片段执行，每执行一小段就检查是否有高优先级工作</li><li><strong>优先级系统：</strong> 不同的更新有不同的优先级 <ul><li>Urgent: 需要同步处理（如用户输入）</li><li>High: 用户交互（如点击）</li><li>Normal: 普通更新</li><li>Low: 可以延迟的工作（如屏幕外数据）</li></ul></li><li><strong>启用方式：</strong> 使用 <code>createRoot</code> (React 18 默认)</li></ul><h3 id="服务端渲染-ssr-与流式渲染" tabindex="-1">服务端渲染（SSR）与流式渲染 <a class="header-anchor" href="#服务端渲染-ssr-与流式渲染" aria-label="Permalink to &quot;服务端渲染（SSR）与流式渲染&quot;">​</a></h3>',3)),(a(),n(r,null,{default:i(()=>[E(t,{id:"mermaid-704",class:"mermaid",graph:"flowchart%20LR%0A%20%20%20%20A%5B%E6%9C%8D%E5%8A%A1%E5%99%A8%5D%20--%3E%20B%5B%E7%94%9F%E6%88%90HTML%5D%0A%20%20%20%20B%20--%3E%20C%5B%E5%8F%91%E9%80%81HTML%5D%0A%20%20%20%20C%20--%3E%20D%5B%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A5%E6%94%B6%5D%0A%20%20%20%20D%20--%3E%20E%5BHydration%5D%0A%20%20%20%20E%20--%3E%20F%5B%E4%BA%A4%E4%BA%92%E5%BC%8FUI%5D%0A%20%20%20%20%0A%20%20%20%20subgraph%20%22%E6%B5%81%E5%BC%8FSSR%22%0A%20%20%20%20%20%20%20%20G%5B%E9%80%90%E6%AD%A5%E5%8F%91%E9%80%81HTML%E7%89%87%E6%AE%B5%5D%0A%20%20%20%20%20%20%20%20H%5B%E5%85%B3%E9%94%AE%E5%86%85%E5%AE%B9%E4%BC%98%E5%85%88%5D%0A%20%20%20%20%20%20%20%20I%5BSelective%20Hydration%5D%0A%20%20%20%20end%0A%20%20%20%20%0A%20%20%20%20style%20E%20fill%3A%23f44336%2Cstroke%3A%23b71c1c%2Ccolor%3Awhite%0A%20%20%20%20style%20G%20fill%3A%2361dafb%2Cstroke%3A%23282c34%2Ccolor%3A%23282c34%0A"})]),fallback:i(()=>[...s[8]||(s[8]=[e(" Loading... ",-1)])]),_:1})),s[23]||(s[23]=A('<ul><li><strong>传统SSR：</strong> 服务器生成完整HTML，客户端加载React后进行hydration</li><li><strong>流式SSR (React 18)：</strong><ul><li><code>renderToPipeableStream</code>: 服务器生成HTML流，可以逐步发送</li><li>与Suspense集成，允许部分UI先加载，部分等待数据</li><li>Selective Hydration: 用户交互的部分优先激活</li></ul></li></ul><h3 id="其他关键特性" tabindex="-1">其他关键特性 <a class="header-anchor" href="#其他关键特性" aria-label="Permalink to &quot;其他关键特性&quot;">​</a></h3><ul><li><strong>Automatic Batching:</strong> 自动批处理多个状态更新，减少渲染次数</li><li><strong>Transitions:</strong> 将UI更新标记为非紧急，允许保持当前UI响应</li><li><strong>Suspense for Data Fetching:</strong> 声明式地指定加载状态</li><li><strong>Server Components:</strong> 只在服务器运行、不增加客户端bundle大小的组件</li></ul>',3)),(a(),n(r,null,{default:i(()=>[E(t,{id:"mermaid-759",class:"mermaid",graph:"flowchart%20TD%0A%20%20%20%20A%5BReact%E7%8E%B0%E4%BB%A3%E7%89%B9%E6%80%A7%5D%20--%3E%20B%5BConcurrent%20Mode%5D%0A%20%20%20%20A%20--%3E%20C%5B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%A2%9E%E5%BC%BA%5D%0A%20%20%20%20A%20--%3E%20D%5B%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86%2F%E6%87%92%E5%8A%A0%E8%BD%BD%5D%0A%20%20%20%20A%20--%3E%20E%5BServer%20Components%5D%0A%20%20%20%20A%20--%3E%20F%5BSuspense%5D%0A%20%20%20%20A%20--%3E%20G%5BTransitions%5D%0A%20%20%20%20%0A%20%20%20%20style%20A%20fill%3A%2361dafb%2Cstroke%3A%23282c34%2Ccolor%3A%23282c34%0A%20%20%20%20style%20B%20fill%3A%23e1f5fe%2Cstroke%3A%2301579b%0A%20%20%20%20style%20C%20fill%3A%23e1f5fe%2Cstroke%3A%2301579b%0A%20%20%20%20style%20D%20fill%3A%23e1f5fe%2Cstroke%3A%2301579b%0A%20%20%20%20style%20E%20fill%3A%23e1f5fe%2Cstroke%3A%2301579b%0A%20%20%20%20style%20F%20fill%3A%23e1f5fe%2Cstroke%3A%2301579b%0A%20%20%20%20style%20G%20fill%3A%23e1f5fe%2Cstroke%3A%2301579b%0A"})]),fallback:i(()=>[...s[9]||(s[9]=[e(" Loading... ",-1)])]),_:1})),s[24]||(s[24]=l("h2",{id:"总结-react工作流全景图",tabindex:"-1"},[e("总结: React工作流全景图 "),l("a",{class:"header-anchor",href:"#总结-react工作流全景图","aria-label":'Permalink to "总结: React工作流全景图"'},"​")],-1)),s[25]||(s[25]=l("p",null,"以下是React从代码到屏幕的完整流程总览：",-1)),(a(),n(r,null,{default:i(()=>[E(t,{id:"mermaid-766",class:"mermaid",graph:"flowchart%20TD%0A%20%20%20%20A%5B%E5%BC%80%E5%8F%91%E9%98%B6%E6%AE%B5%5D%20--%3E%20A1%5BJSX%E7%BC%96%E5%86%99%5D%0A%20%20%20%20A1%20--%3E%20A2%5BBabel%E7%BC%96%E8%AF%91%5D%0A%20%20%20%20A2%20--%3E%20A3%5BWebpack%E6%89%93%E5%8C%85%5D%0A%20%20%20%20%0A%20%20%20%20A3%20--%3E%20B%5B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD%5D%0A%20%20%20%20B%20--%3E%20B1%5BHTML%E8%A7%A3%E6%9E%90%5D%0A%20%20%20%20B1%20--%3E%20B2%5BJS%E6%89%A7%E8%A1%8C%5D%0A%20%20%20%20%0A%20%20%20%20B2%20--%3E%20C%5BReact%E5%88%9D%E5%A7%8B%E5%8C%96%5D%0A%20%20%20%20C%20--%3E%20C1%5BcreateRoot%5D%0A%20%20%20%20C1%20--%3E%20C2%5B%E9%A6%96%E6%AC%A1%E6%B8%B2%E6%9F%93%5D%0A%20%20%20%20%0A%20%20%20%20C2%20--%3E%20D%5B%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%5D%0A%20%20%20%20D%20--%3E%20D1%5BMount%5D%0A%20%20%20%20D1%20--%3E%20D2%5BUpdate%5D%0A%20%20%20%20D2%20--%3E%20D3%5BUnmount%5D%0A%20%20%20%20%0A%20%20%20%20D2%20-.-%3E%20E%5B%E7%8A%B6%E6%80%81%E5%8F%98%E6%9B%B4%E8%A7%A6%E5%8F%91%5D%0A%20%20%20%20E%20--%3E%20E1%5B%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%5D%0A%20%20%20%20E1%20--%3E%20E2%5BsetState%2FuseState%5D%0A%20%20%20%20E2%20--%3E%20E3%5B%E8%B0%83%E5%BA%A6%E6%9B%B4%E6%96%B0%5D%0A%20%20%20%20%0A%20%20%20%20E3%20--%3E%20F%5B%E6%B8%B2%E6%9F%93%E9%98%B6%E6%AE%B5%5D%0A%20%20%20%20F%20--%3E%20F1%5B%E5%8D%8F%E8%B0%83%E7%AE%97%E6%B3%95%5D%0A%20%20%20%20F1%20--%3E%20F2%5BDiffing%5D%0A%20%20%20%20F2%20--%3E%20F3%5B%E6%9E%84%E5%BB%BAFiber%E6%A0%91%5D%0A%20%20%20%20%0A%20%20%20%20F3%20--%3E%20G%5B%E6%8F%90%E4%BA%A4%E9%98%B6%E6%AE%B5%5D%0A%20%20%20%20G%20--%3E%20G1%5BDOM%E6%93%8D%E4%BD%9C%5D%0A%20%20%20%20G1%20--%3E%20G2%5BEffect%E6%89%A7%E8%A1%8C%5D%0A%20%20%20%20%0A%20%20%20%20G2%20-.-%3E%20D2%0A%20%20%20%20%0A%20%20%20%20style%20A%20fill%3A%23e8f5e9%2Cstroke%3A%232e7d32%0A%20%20%20%20style%20B%20fill%3A%23e1f5fe%2Cstroke%3A%2301579b%0A%20%20%20%20style%20C%20fill%3A%23fff3e0%2Cstroke%3A%23ff6f00%0A%20%20%20%20style%20D%20fill%3A%23f3e5f5%2Cstroke%3A%237b1fa2%0A%20%20%20%20style%20E%20fill%3A%23e1f5fe%2Cstroke%3A%2301579b%0A%20%20%20%20style%20F%20fill%3A%23fff3e0%2Cstroke%3A%23ff6f00%0A%20%20%20%20style%20G%20fill%3A%23e8f5e9%2Cstroke%3A%232e7d32%0A%20%20%20%20style%20F1%20fill%3A%23f44336%2Cstroke%3A%23b71c1c%2Ccolor%3Awhite%0A"})]),fallback:i(()=>[...s[10]||(s[10]=[e(" Loading... ",-1)])]),_:1})),s[26]||(s[26]=l("p",null,"本文提供了React工作流程的高层次理解。在后续文章中，我们将深入探讨各个关键环节的实现细节，包括：",-1)),s[27]||(s[27]=l("ul",null,[l("li",null,"Fiber架构深度解析"),l("li",null,"协调算法的实现机制"),l("li",null,"Hook原理与内部实现"),l("li",null,"并发模式的技术细节"),l("li",null,"服务端渲染的全流程"),l("li",null,"性能优化技巧与最佳实践")],-1)),s[28]||(s[28]=l("p",null,"通过理解React的工作原理，你将能够更有效地使用它，编写更高效、更可维护的代码，并更好地解决实际开发中遇到的问题。",-1))])}const m=o(k,[["render",h]]);export{C as __pageData,m as default};
