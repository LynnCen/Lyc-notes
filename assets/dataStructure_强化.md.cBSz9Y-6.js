import{_ as a,c as e,o as p,aa as r}from"./chunks/framework.CAVwB9kQ.js";const f=JSON.parse('{"title":"数据结构强化","description":"","frontmatter":{},"headers":[],"relativePath":"dataStructure/强化.md","filePath":"dataStructure/强化.md","lastUpdated":1725848588000}'),t={name:"dataStructure/强化.md"},o=r('<h1 id="数据结构强化" tabindex="-1">数据结构强化 <a class="header-anchor" href="#数据结构强化" aria-label="Permalink to &quot;数据结构强化&quot;">​</a></h1><h2 id="第一章" tabindex="-1">第一章 <a class="header-anchor" href="#第一章" aria-label="Permalink to &quot;第一章&quot;">​</a></h2><p><strong>时间复杂度和空间复杂度的计算</strong></p><p><strong>时间复杂度</strong>：一个语句在算法中被重复执行的<strong>次数</strong></p><p>常见形式：</p><p>1️⃣ 阶乘n!：1<em>2</em>...*n ，时间复杂度O(n)</p><p>2️⃣ 单个循环++：O(n)</p><p>3️⃣ 单个循环i*2: O(logn)</p><p>4️⃣ 双循环i与j无关联：O(n^2)</p><p>5️⃣ 双循环i与j关联：计算总次数</p><p>无论哪种形式 穷举各层的执行次数即可</p><h2 id="第二章-线性表" tabindex="-1">第二章 线性表 <a class="header-anchor" href="#第二章-线性表" aria-label="Permalink to &quot;第二章 线性表&quot;">​</a></h2><p>大题算法题的重点！首选暴力解</p><h3 id="线性表-顺序表示" tabindex="-1">线性表（顺序表示） <a class="header-anchor" href="#线性表-顺序表示" aria-label="Permalink to &quot;线性表（顺序表示）&quot;">​</a></h3><p>线性表的数据结构定义</p><p>插入、删除和查找</p><p>位序和数组下标的区别</p><p>带头节点和不带头节点的区别</p><h3 id="链式表示" tabindex="-1">链式表示 <a class="header-anchor" href="#链式表示" aria-label="Permalink to &quot;链式表示&quot;">​</a></h3><p>单链表的定义、双链表的定义、循环单链表、循环双链表、静态链表</p><p>基本操作：插入、删除和查找</p><h2 id="第三章-栈和队列" tabindex="-1">第三章 栈和队列 <a class="header-anchor" href="#第三章-栈和队列" aria-label="Permalink to &quot;第三章 栈和队列&quot;">​</a></h2><p>选择题和应用题</p><h3 id="栈" tabindex="-1">栈 <a class="header-anchor" href="#栈" aria-label="Permalink to &quot;栈&quot;">​</a></h3><p>栈的基本概念 LIFO</p><p>栈的顺序存储数据结构</p><p>栈的基本操作：</p><p>入栈先++ 再入栈</p><p>出栈先弹出栈顶元素，后--</p><p>栈满和栈空判断</p><p>共享栈（判断栈满）</p><p>栈的链式存储数据结构</p><h3 id="队列" tabindex="-1">队列 <a class="header-anchor" href="#队列" aria-label="Permalink to &quot;队列&quot;">​</a></h3><p>基本概念（FIFO）</p><p>队列的顺序存储数据结构</p><p>入队：先送值到队尾元素，再将队尾指针加1 rear++</p><p>出队：先取队尾元素，再将队头指针++</p><p>判断队空和队满（什么是假溢出）</p><p>循环队列（解决假溢出）</p><p>循环队列判断队空：<code>Q.front == Q.rear</code></p><p>循环队列判断队满的三种方式 <code>(Q.rear+1)% MaxSize == Q.front</code></p><p>循环队列入队：<code>Q.rear = (Q.rear + 1)% MaxSize</code></p><p>循环队列出队：<code>Q.front == (Q.front + 1)% MaxSize</code></p><p>队列的链式存储（带头节点和不带头节点）</p><p>双端队列</p><h3 id="栈和队列的应用" tabindex="-1">栈和队列的应用 <a class="header-anchor" href="#栈和队列的应用" aria-label="Permalink to &quot;栈和队列的应用&quot;">​</a></h3><p>栈在括号匹配中的应用</p><p>栈在表达式求值中的应用（计算栈的深度和栈中元素）</p><p>中缀转后缀、后缀表达式求值</p><p>栈在递归中的应用</p><p>队列在层次遍历中的应用</p><p>队列在计算机系统中的应用（buffer、就绪队列、阻塞队列）</p><h2 id="数组和特殊矩阵" tabindex="-1">数组和特殊矩阵 <a class="header-anchor" href="#数组和特殊矩阵" aria-label="Permalink to &quot;数组和特殊矩阵&quot;">​</a></h2><p>特殊矩阵的压缩存储</p><p>按行或列优先存储，计算下标（不用背公式，直接穷举），注意区分下标从0还是从1开始</p><p>三角矩阵和三对角矩阵存储</p><p>稀疏矩阵的存储：三元组（行标i，列标j，值a；还需要保存稀疏矩阵的行数、列数和非零元素的个数），十字链表存储</p>',57),n=[o];function i(d,h,l,c,s,u){return p(),e("div",null,n)}const b=a(t,[["render",i]]);export{f as __pageData,b as default};
