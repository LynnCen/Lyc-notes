import{_ as a,c as i,o as n,a8 as t}from"./chunks/framework.CrIyVKdD.js";const l="/Lyc-notes/assets/%E6%A0%88%E6%BA%A2%E5%87%BA.DUh5vhsI.png",p="/Lyc-notes/assets/stack1.DByjGQpa.png",e="/Lyc-notes/assets/stackfull.BwMggGlU.png",h="/Lyc-notes/assets/stackdemo.B6s6VwH4.png",r="/Lyc-notes/assets/callstack1.Dh-nWb77.png",k="/Lyc-notes/assets/callstack2.2DA7clnj.png",d="/Lyc-notes/assets/callstack3.CN9ae1is.png",c="/Lyc-notes/assets/callstack4.D9XQggat.png",o="/Lyc-notes/assets/callstack5.DIwFcWgm.png",g="/Lyc-notes/assets/callstack6.DF5TcCIy.png",E="/Lyc-notes/assets/callstacksource.BQ1fu1TQ.png",y="/Lyc-notes/assets/consoletrace.B3nI0hFD.png",u="/Lyc-notes/assets/callstackerror.CpMawaVi.png",D=JSON.parse('{"title":"调用栈","description":"","frontmatter":{},"headers":[],"relativePath":"browser/调用栈.md","filePath":"browser/调用栈.md","lastUpdated":1718593383000}'),b={name:"browser/调用栈.md"};function F(m,s,v,A,C,_){return n(),i("div",null,[...s[0]||(s[0]=[t('<h1 id="调用栈" tabindex="-1">调用栈 <a class="header-anchor" href="#调用栈" aria-label="Permalink to &quot;调用栈&quot;">​</a></h1><p>为什么 JavaScript 代码会出现栈溢出？</p><p>在上篇文章中，我们讲到了，当一段代码被执行时，<strong>JavaScript 引擎先会对其进行编译，并创建执行上下文</strong>。但是并没有明确说明到底什么样的代码才算符合规范。</p><p>那么接下来我们就来明确下，哪些情况下代码才算是“一段”代码，才会在执行之前就进行编译并创建执行上下文。一般说来，有这么三种情况：</p><ul><li>当 JavaScript 执行全局代码的时候，会编译全局代码并创建<strong>全局执行上下文</strong>，而且在整个页面的生存周期内，全局执行上下文只有一份。</li><li>当调用一个函数的时候，函数体内的代码会被编译，并创建<strong>函数执行上下文</strong>，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。</li><li>当使用 <code>eval</code> 函数的时候，<code>eval</code> 的代码也会被编译，并创建<strong>执行上下文</strong>。</li></ul><p>你在写 JavaScript 代码的时候，有时候可能会遇到栈溢出的错误，如下图所示：</p><p><img src="'+l+`" alt="alt text"> 栈溢出的错误 那为什么会出现这种错误呢？这就涉及到了<strong>调用栈</strong>的内容。你应该知道 JavaScript 中有很多函数，经常会出现在一个函数中调用另外一个函数的情况，<strong>调用栈就是用来管理函数调用关系的一种数据结构</strong>。因此要讲清楚调用栈，你还要先弄明白<strong>函数调用</strong>和<strong>栈结构</strong>。</p><h2 id="什么是函数调用" tabindex="-1">什么是函数调用 <a class="header-anchor" href="#什么是函数调用" aria-label="Permalink to &quot;什么是函数调用&quot;">​</a></h2><p>函数调用就是运行一个函数，具体使用方式是使用函数名称跟着一对小括号。下面我们看个简单的示例代码：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这段代码很简单，先是创建了一个 add 函数，接着在代码的最下面又调用了该函数。</p><p>那么下面我们就利用这段简单的代码来解释下函数调用的过程。</p><p>在执行到函数 add()之前，JavaScript 引擎会为上面这段代码创建全局执行上下文，包含了声明的函数和变量，你可以参考下图：</p><p><img src="`+p+'" alt="alt text"></p><p>全局执行上下文 从图中可以看出，代码中全局变量和函数都保存在全局上下文的变量环境中。</p><p>执行上下文准备好之后，便开始执行全局代码，当执行到 add 这儿时，JavaScript 判断这是一个函数调用，那么将执行以下操作：</p><ul><li>首先，从全局执行上下文中，取出 add 函数代码。</li><li>其次，对 add 函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码。</li><li>最后，执行代码，输出结果。</li></ul><p>完整流程你可以参考下图：</p><p><img src="'+e+'" alt="alt text"></p><p>函数调用过程 就这样，当执行到 add 函数的时候，我们就有了两个执行上下文了——全局执行上下文和 add 函数的执行上下文。</p><p>也就是说在执行 JavaScript 时，可能会存在多个执行上下文，那么 JavaScript 引擎是如何管理这些执行上下文的呢？</p><p>答案是通过一种叫栈的数据结构来管理的。那什么是栈呢？它又是如何管理这些执行上下文呢？</p><h2 id="什么是栈" tabindex="-1">什么是栈 <a class="header-anchor" href="#什么是栈" aria-label="Permalink to &quot;什么是栈&quot;">​</a></h2><p>栈就是类似于一端被堵住的单行线，车子类似于栈中的元素，栈中的元素满足后进先出(LIFO)的特点。你可以参看下图: <img src="'+h+`" alt="alt text"></p><h2 id="什么是-javascript-的调用栈" tabindex="-1">什么是 JavaScript 的调用栈 <a class="header-anchor" href="#什么是-javascript-的调用栈" aria-label="Permalink to &quot;什么是 JavaScript 的调用栈&quot;">​</a></h2><p>avaScript 引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为<strong>执行上下文栈</strong>，又称<strong>调用栈</strong>。</p><p>为便于你更好地理解调用栈，下面我们再来看段稍微复杂点的示例代码：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b, c)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在上面这段代码中，你可以看到它是在 <code>addAll</code> 函数中调用了 <code>add</code> 函数，那在整个代码的执行过程中，调用栈是怎么变化的呢</p><p><strong>第一步，创建全局上下文，并将其压入栈底。</strong></p><p><img src="`+r+'" alt="alt text"> 全局执行上下文压栈 从图中你也可以看出，变量 <code>a</code>、函数 <code>add</code> 和 <code>addAll</code> 都保存到了全局上下文的变量环境对象中。</p><p>全局执行上下文压入到调用栈后，JavaScript 引擎便开始执行全局代码了。首先会执行 <code>a=2</code> 的赋值操作，执行该语句会将全局上下文变量环境中 <code>a </code>的值设置为 2。设置后的全局上下文的状态如下图所示： <img src="'+k+'" alt="alt text"> 赋值操作改变执行上下文中的值</p><p><strong>第二步是调用 <code>addAll</code> 函数</strong></p><p>当调用该函数时，JavaScript 引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中，如下图所示： <img src="'+d+'" alt="alt text"> 执行 <code>addAll</code> 函数时的调用栈</p><p><code>addAll</code> 函数的执行上下文创建好之后，便进入了函数代码的执行阶段了，这里先执行的是 <code>d=10</code> 的赋值操作，执行语句会将 <code>addAll</code> 函数执行上下文中的 d 由 undefined 变成了 10。</p><p><strong>第三步，执行到 add 函数调用语句</strong></p><p>为其创建执行上下文，并将其压入调用栈，如下图所示： <img src="'+c+'" alt="alt text"> 执行 <code>add</code> 函数时的调用栈 当 <code>add</code> 函数返回时，该函数的执行上下文就会从栈顶弹出，并将 <code>result</code> 的值设置为 add 函数的返回值，也就是 9。如下图所示： <img src="'+o+'" alt="alt text"><code>add</code> 函数执行结束时的调用栈</p><p>紧接着 <code>addAll</code> 执行最后一个相加操作后并返回，<code>addAll</code> 的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。最终如下图所示：</p><p><img src="'+g+'" alt="alt text"></p><p><code>addAll</code>函数执行结束时的调用栈 至此，整个 JavaScript 流程执行结束了。</p><p>好了，现在你应该知道了<strong>调用栈是 JavaScript 引擎追踪函数执行的一个机制</strong>，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。</p><h2 id="在开发中-如何利用好调用栈" tabindex="-1">在开发中，如何利用好调用栈 <a class="header-anchor" href="#在开发中-如何利用好调用栈" aria-label="Permalink to &quot;在开发中，如何利用好调用栈&quot;">​</a></h2><h4 id="如何利用浏览器查看调用栈的信息" tabindex="-1">如何利用浏览器查看调用栈的信息 <a class="header-anchor" href="#如何利用浏览器查看调用栈的信息" aria-label="Permalink to &quot;如何利用浏览器查看调用栈的信息&quot;">​</a></h4><p>当你执行一段复杂的代码时，你可能很难从代码文件中分析其调用关系，这时候你可以在你想要查看的函数中加入断点，然后当执行到该函数时，就可以查看该函数的调用栈了。</p><p>这么说可能有点抽象，这里我们拿上面的那段代码做个演示，你可以打开“开发者工具”，点击“Source”标签，选择 JavaScript 代码的页面，然后在第 3 行加上断点，并刷新页面。你可以看到执行到 add 函数时，执行流程就暂停了，这时可以通过右边“call stack”来查看当前的调用栈的情况，如下图：</p><p><img src="'+E+'" alt="alt text"> 查看函数调用关系</p><p>从图中可以看出，右边的<code>“call stack”</code>下面显示出来了函数的调用关系：栈的最底部是<code>anonymous</code>，也就是全局的函数入口；中间是<code>addAll</code>函数；顶部是<code>add</code>函数。这就清晰地反映了函数的调用关系，所以<strong>在分析复杂结构代码，或者检查 Bug 时，调用栈都是非常有用的</strong>。</p><p>除了通过断点来查看调用栈，你还可以使用<code>console.trace()</code>来输出当前的函数调用关系，比如在示例代码中的 add 函数里面加上了<code>console.trace()</code>，你就可以看到控制台输出的结果，如下图： <img src="'+y+`" alt="alt text"> 使用 <code>trace</code> 函数输出当前调用栈信息</p><h4 id="栈溢出-stack-overflow" tabindex="-1">栈溢出（Stack Overflow） <a class="header-anchor" href="#栈溢出-stack-overflow" aria-label="Permalink to &quot;栈溢出（Stack Overflow）&quot;">​</a></h4><p>现在你知道了调用栈是一种用来管理执行上下文的数据结构，符合后进先出的规则。不过还有一点你要注意，<strong>调用栈是有大小的</strong>，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做<strong>栈溢出</strong>。</p><p>特别是在你写递归代码的时候，就很容易出现栈溢出的情况。比如下面这段代码：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> division</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> division</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a, b)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">division</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><img src="`+u+`" alt="alt text"></p><p>从上图你可以看到，抛出的错误信息为：<strong>超过了最大栈调用大小（Maximum call stack size exceeded）</strong>。</p><p>那为什么会出现这个问题呢？这是因为当 JavaScript 引擎开始执行这段代码时，它首先调用函数 division，并创建执行上下文，压入栈中；然而，这个函数是<strong>递归的，并且没有任何终止条件</strong>，所以它会一直创建新的函数执行上下文，并反复将其压入栈中，但栈是有容量限制的，超过最大数量后就会出现栈溢出的错误。</p><p>理解了栈溢出原因后，你就可以使用一些方法来避免或者解决栈溢出的问题，比如把递归调用的形式改造成其他形式，或者使用加入定时器的方法来把当前任务拆分为其他很多小任务。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ul><li>每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。</li><li>如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。</li><li>当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。</li><li>当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。</li></ul><h2 id="思考时间" tabindex="-1">思考时间 <a class="header-anchor" href="#思考时间" aria-label="Permalink to &quot;思考时间&quot;">​</a></h2><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runStack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runStack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">runStack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这是一段递归代码，可以通过传入参数 n，让代码递归执行 n 次，也就意味着调用栈的深度能达到 n，当输入一个较大的数时，比如 50000，就会出现栈溢出的问题，那么你能优化下这段代码，以解决栈溢出的问题吗？</p>`,61)])])}const S=a(b,[["render",F]]);export{D as __pageData,S as default};
