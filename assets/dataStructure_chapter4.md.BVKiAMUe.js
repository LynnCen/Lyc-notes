import{_ as i,c as a,o as n,a8 as l}from"./chunks/framework.B1xsROTH.js";const t="/Lyc-notes/assets/%E4%B8%B2%E9%83%A8%E5%88%86%E5%8C%B9%E9%85%8D.B5cx3Euy.png",p="/Lyc-notes/assets/kmp.DZRM4Mnw.png",o=JSON.parse('{"title":"第 4 章 串","description":"","frontmatter":{},"headers":[],"relativePath":"dataStructure/chapter4.md","filePath":"dataStructure/chapter4.md","lastUpdated":1717752830000}'),h={name:"dataStructure/chapter4.md"};function e(k,s,r,E,d,g){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="第-4-章-串" tabindex="-1">第 4 章 串 <a class="header-anchor" href="#第-4-章-串" aria-label="Permalink to &quot;第 4 章 串&quot;">​</a></h1><h2 id="串的定义和实现" tabindex="-1">串的定义和实现 <a class="header-anchor" href="#串的定义和实现" aria-label="Permalink to &quot;串的定义和实现&quot;">​</a></h2><h4 id="串的存储结构" tabindex="-1">串的存储结构 <a class="header-anchor" href="#串的存储结构" aria-label="Permalink to &quot;串的存储结构&quot;">​</a></h4><ol><li>定长顺序存储表示</li></ol><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MAXLEN</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  char</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> ch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[MAXLEN];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length ;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} SString;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="串的模式匹配" tabindex="-1">串的模式匹配 <a class="header-anchor" href="#串的模式匹配" aria-label="Permalink to &quot;串的模式匹配&quot;">​</a></h2><h4 id="简单的模式匹配算法" tabindex="-1">简单的模式匹配算法 <a class="header-anchor" href="#简单的模式匹配算法" aria-label="Permalink to &quot;简单的模式匹配算法&quot;">​</a></h4><p>子串的定位操作通常称为串的模式匹配，它求的是子串(常称模式串)在主串中的位置。这 里采用定长顺序存储结构，给出一种不依赖于其他串操作的暴力匹配算法。</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (SString </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , SString </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> S.length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T.length){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(S.ch[i]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T.ch[j]){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      ++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      ++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">j;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T.length) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T.length;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>时间复杂度 O(nm)</p><blockquote><p>:note 需要多次指针回溯</p></blockquote><h4 id="串的模式匹配算法-—kmp-算法" tabindex="-1">串的模式匹配算法-—KMP 算法 <a class="header-anchor" href="#串的模式匹配算法-—kmp-算法" aria-label="Permalink to &quot;串的模式匹配算法-—KMP 算法&quot;">​</a></h4><ol><li><strong>字符串的前缀、后缀和部分匹配值</strong></li></ol><p><strong>前缀</strong>指除最后一个字符以外，字符串的所有头部子串; <strong>后缀</strong>指除第一个字符外，字符串的所有尾部子串; <strong>部分匹配值</strong>则为字符串的前缀和后缀的最长相等前后缀长度。</p><p><img src="`+t+'" alt="alt text"></p><p>这个部分匹配值有什么作用呢?</p><p><strong>移动位数=已匹配的字符数- 对应的部分匹配值</strong></p><ol start="2"><li>KMP 算法的原理是什么</li></ol><p>求部分匹配值、next 数组、nextval</p><p><img src="'+p+'" alt="alt text"></p>',20)]))}const y=i(h,[["render",e]]);export{o as __pageData,y as default};
