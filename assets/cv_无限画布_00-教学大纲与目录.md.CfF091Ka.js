import{_ as i,c as a,o as n,a7 as s}from"./chunks/framework.BQb8NfN9.js";const h=JSON.parse('{"title":"无限画布技术深度解析 - 教学大纲","description":"","frontmatter":{},"headers":[],"relativePath":"cv/无限画布/00-教学大纲与目录.md","filePath":"cv/无限画布/00-教学大纲与目录.md","lastUpdated":1769693499000}'),e={name:"cv/无限画布/00-教学大纲与目录.md"};function r(o,l,p,t,u,c){return n(),a("div",null,l[0]||(l[0]=[s(`<h1 id="无限画布技术深度解析-教学大纲" tabindex="-1">无限画布技术深度解析 - 教学大纲 <a class="header-anchor" href="#无限画布技术深度解析-教学大纲" aria-label="Permalink to &quot;无限画布技术深度解析 - 教学大纲&quot;">​</a></h1><blockquote><p>本系列文档旨在系统性地讲解无限画布（Infinite Canvas）的设计理念、核心架构和实现细节，帮助读者从零开始理解并掌握这一复杂的图形编辑器核心技术。</p></blockquote><hr><h2 id="📚-系列文档结构" tabindex="-1">📚 系列文档结构 <a class="header-anchor" href="#📚-系列文档结构" aria-label="Permalink to &quot;📚 系列文档结构&quot;">​</a></h2><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>无限画布/</span></span>
<span class="line"><span>├── 00-教学大纲与目录.md           ← 当前文档</span></span>
<span class="line"><span>├── 01-代码路径与模块映射.md        ← 功能-代码对照表</span></span>
<span class="line"><span>├── 02-基础概念与技术选型.md        ← 入门必读</span></span>
<span class="line"><span>├── 03-坐标系统与矩阵变换.md        ← 数学基础</span></span>
<span class="line"><span>├── 04-Surface画布表面层.md        ← 核心架构</span></span>
<span class="line"><span>├── 05-Viewport视口管理.md         ← 视口控制</span></span>
<span class="line"><span>├── 06-VmEngine视图模型引擎.md     ← 渲染核心</span></span>
<span class="line"><span>├── 07-元素生命周期与渲染.md        ← 元素渲染</span></span>
<span class="line"><span>├── 08-事件系统与碰撞检测.md        ← 交互系统</span></span>
<span class="line"><span>├── 09-插件系统架构.md              ← 扩展机制</span></span>
<span class="line"><span>├── 10-性能优化策略.md              ← 性能调优</span></span>
<span class="line"><span>├── 11-PixiJS与WebGL基础.md        ← 附录-渲染引擎</span></span>
<span class="line"><span>└── 12-常见问题与最佳实践.md        ← 附录-FAQ</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><hr><h2 id="📖-第一部分-基础概念篇" tabindex="-1">📖 第一部分：基础概念篇 <a class="header-anchor" href="#📖-第一部分-基础概念篇" aria-label="Permalink to &quot;📖 第一部分：基础概念篇&quot;">​</a></h2><h3 id="第1章-基础概念与技术选型" tabindex="-1">第1章：基础概念与技术选型 <a class="header-anchor" href="#第1章-基础概念与技术选型" aria-label="Permalink to &quot;第1章：基础概念与技术选型&quot;">​</a></h3><p><strong>核心问题</strong>：为什么需要无限画布？与传统 DOM 渲染有什么区别？</p><p><strong>内容要点</strong>：</p><ul><li>1.1 什么是无限画布 <ul><li>定义与特征</li><li>应用场景（Figma、Miro、Canva、稿定设计）</li><li>与传统 DOM 方案的对比</li></ul></li><li>1.2 技术选型分析 <ul><li>Canvas 2D vs WebGL vs SVG</li><li>为什么选择 PixiJS（Piso）</li><li>渲染性能对比数据</li></ul></li><li>1.3 整体架构概览 <ul><li>五层架构设计</li><li>核心模块关系图</li><li>数据流与渲染流</li></ul></li></ul><p><strong>学习目标</strong>：理解无限画布的本质和技术选型背景</p><hr><h3 id="第2章-坐标系统与矩阵变换" tabindex="-1">第2章：坐标系统与矩阵变换 <a class="header-anchor" href="#第2章-坐标系统与矩阵变换" aria-label="Permalink to &quot;第2章：坐标系统与矩阵变换&quot;">​</a></h3><p><strong>核心问题</strong>：如何在无限画布中精确定位和变换元素？</p><p><strong>内容要点</strong>：</p><ul><li>2.1 坐标系统基础 <ul><li>世界坐标系（World Coordinates）</li><li>屏幕坐标系（Screen Coordinates）</li><li>局部坐标系（Local Coordinates）</li><li>三者之间的关系</li></ul></li><li>2.2 矩阵变换原理 <ul><li>2D 仿射变换矩阵</li><li>平移（Translation）</li><li>缩放（Scale）</li><li>旋转（Rotation）</li><li>复合变换</li></ul></li><li>2.3 坐标转换实现 <ul><li><code>getLocalPoint</code> - 屏幕坐标转世界坐标</li><li><code>getGlobalPoint</code> - 世界坐标转屏幕坐标</li><li><code>decomposeTransform</code> - 矩阵分解</li></ul></li><li>2.4 包围盒计算 <ul><li>AABB（轴对齐包围盒）</li><li>OBB（有向包围盒）</li><li>包围盒应用场景</li></ul></li></ul><p><strong>学习目标</strong>：掌握坐标系统和矩阵变换的数学原理</p><hr><h2 id="📖-第二部分-核心渲染引擎篇" tabindex="-1">📖 第二部分：核心渲染引擎篇 <a class="header-anchor" href="#📖-第二部分-核心渲染引擎篇" aria-label="Permalink to &quot;📖 第二部分：核心渲染引擎篇&quot;">​</a></h2><h3 id="第3章-surface-画布表面层" tabindex="-1">第3章：Surface 画布表面层 <a class="header-anchor" href="#第3章-surface-画布表面层" aria-label="Permalink to &quot;第3章：Surface 画布表面层&quot;">​</a></h3><p><strong>核心问题</strong>：画布的顶层管理者是如何工作的？</p><p><strong>内容要点</strong>：</p><ul><li>3.1 Surface 架构设计 <ul><li>Surface 抽象基类</li><li>核心组件组合</li></ul></li><li>3.2 三种画布模式 <ul><li><code>BoardSurface</code> - 无限画布模式</li><li><code>PosterSurface</code> - 海报模式</li><li><code>FlowSurface</code> - 长图模式</li></ul></li><li>3.3 渲染循环机制 <ul><li>Ticker 渲染帧管理</li><li>渲染更新策略</li><li>性能监控</li></ul></li><li>3.4 分辨率与 DPI <ul><li>高清屏适配</li><li>动态分辨率切换</li></ul></li></ul><p><strong>学习目标</strong>：理解 Surface 层的设计模式和职责划分</p><hr><h3 id="第4章-viewport-视口管理" tabindex="-1">第4章：Viewport 视口管理 <a class="header-anchor" href="#第4章-viewport-视口管理" aria-label="Permalink to &quot;第4章：Viewport 视口管理&quot;">​</a></h3><p><strong>核心问题</strong>：如何实现无限大的画布只显示用户可见的部分？</p><p><strong>内容要点</strong>：</p><ul><li>4.1 视口核心概念 <ul><li>视口状态：position、zoom</li><li>视口边界与限制</li><li>视口 padding</li></ul></li><li>4.2 缩放系统 <ul><li>缩放算法实现</li><li>以鼠标位置为中心缩放</li><li>缩放限制（minZoom、maxZoom）</li></ul></li><li>4.3 平移系统 <ul><li>平移边界计算</li><li>惯性滚动</li><li>边缘吸附</li></ul></li><li>4.4 视口命令 <ul><li><code>zoomTo</code> / <code>zoomToFit</code></li><li><code>zoomToElement</code> / <code>zoomToBounds</code></li><li><code>scrollToElement</code> / <code>scrollToBounds</code></li></ul></li><li>4.5 视口动画 <ul><li>贝塞尔曲线缓动</li><li>动画帧管理</li></ul></li><li>4.6 视口持久化 <ul><li>LRU 缓存策略</li><li>状态恢复</li></ul></li></ul><p><strong>学习目标</strong>：掌握视口管理的核心算法和实现细节</p><hr><h3 id="第5章-vmengine-视图模型引擎" tabindex="-1">第5章：VmEngine 视图模型引擎 <a class="header-anchor" href="#第5章-vmengine-视图模型引擎" aria-label="Permalink to &quot;第5章：VmEngine 视图模型引擎&quot;">​</a></h3><p><strong>核心问题</strong>：数据模型如何转换为可渲染的视图对象？</p><p><strong>内容要点</strong>：</p><ul><li>5.1 引擎架构设计 <ul><li>数据模型 → 视图模型映射</li><li>对象池管理</li><li>Pointer 引用机制</li></ul></li><li>5.2 元素类型系统 <ul><li>30+ 种元素类型映射</li><li>元素继承体系</li><li>元素创建工厂</li></ul></li><li>5.3 视图模型管理 <ul><li><code>buildVm</code> - 构建视图模型</li><li><code>createVm</code> - 创建视图模型</li><li><code>cloneVm</code> - 克隆视图模型</li><li><code>removeVm</code> - 移除视图模型</li></ul></li><li>5.4 增量更新机制 <ul><li>Action 类型定义</li><li>Processor 处理器模式</li><li>批量更新优化</li></ul></li></ul><p><strong>学习目标</strong>：理解数据驱动渲染的核心机制</p><hr><h3 id="第6章-元素生命周期与渲染" tabindex="-1">第6章：元素生命周期与渲染 <a class="header-anchor" href="#第6章-元素生命周期与渲染" aria-label="Permalink to &quot;第6章：元素生命周期与渲染&quot;">​</a></h3><p><strong>核心问题</strong>：一个元素从创建到销毁经历了哪些阶段？</p><p><strong>内容要点</strong>：</p><ul><li>6.1 BaseElementVm 基类设计 <ul><li>类继承体系</li><li>核心属性和方法</li><li>图层结构</li></ul></li><li>6.2 数据模型生命周期 <ul><li><code>modelCreated</code> - 模型创建</li><li><code>modelUpdated</code> - 模型更新</li><li><code>modelRemoved</code> - 模型移除</li></ul></li><li>6.3 视图模型生命周期 <ul><li><code>shouldUpdate</code> - 是否需要更新</li><li><code>beforeUpdate</code> - 更新前钩子</li><li><code>render</code> - 渲染方法</li><li><code>afterUpdate</code> - 更新后钩子</li></ul></li><li>6.4 具体元素实现 <ul><li>ImageVm - 图片元素</li><li>TextVm - 文本元素</li><li>ShapeVm - 形状元素</li><li>GroupVm - 组元素</li></ul></li><li>6.5 特殊元素解析 <ul><li>LayoutVm - 画板元素</li><li>ConnectorVm - 连接线</li><li>MagnifierVm - 放大镜</li></ul></li></ul><p><strong>学习目标</strong>：掌握元素渲染的完整流程</p><hr><h2 id="📖-第三部分-事件与交互篇" tabindex="-1">📖 第三部分：事件与交互篇 <a class="header-anchor" href="#📖-第三部分-事件与交互篇" aria-label="Permalink to &quot;📖 第三部分：事件与交互篇&quot;">​</a></h2><h3 id="第7章-事件系统与碰撞检测" tabindex="-1">第7章：事件系统与碰撞检测 <a class="header-anchor" href="#第7章-事件系统与碰撞检测" aria-label="Permalink to &quot;第7章：事件系统与碰撞检测&quot;">​</a></h3><p><strong>核心问题</strong>：如何精确判断用户点击了哪个元素？</p><p><strong>内容要点</strong>：</p><ul><li>7.1 EventBoundary 事件边界 <ul><li>事件边界设计</li><li>遍历策略</li></ul></li><li>7.2 碰撞检测算法 <ul><li>点击检测 <code>hitTest</code></li><li>区域检测 <code>intersect</code></li><li>包围盒检测</li><li>有向包围盒检测</li></ul></li><li>7.3 SAT 分离轴算法 <ul><li>算法原理</li><li>实现细节</li><li>性能优化</li></ul></li><li>7.4 遮罩层处理 <ul><li>遮罩检测</li><li>透明区域穿透</li></ul></li><li>7.5 Bypass 策略 <ul><li>Skip - 跳过元素</li><li>Pass - 穿透元素</li><li>Hits - 直接命中</li><li>None - 正常检测</li></ul></li></ul><p><strong>学习目标</strong>：掌握事件系统和碰撞检测的实现原理</p><hr><h3 id="第8章-手势与交互处理" tabindex="-1">第8章：手势与交互处理 <a class="header-anchor" href="#第8章-手势与交互处理" aria-label="Permalink to &quot;第8章：手势与交互处理&quot;">​</a></h3><p><strong>核心问题</strong>：如何优雅地处理用户的各种交互操作？</p><p><strong>内容要点</strong>：</p><ul><li>8.1 鼠标事件处理 <ul><li>滚轮缩放</li><li>滚轮平移</li><li>右键菜单</li></ul></li><li>8.2 触摸事件处理 <ul><li>双指缩放</li><li>单指平移</li><li>惯性滚动</li></ul></li><li>8.3 键盘快捷键 <ul><li>快捷键系统</li><li>组合键处理</li></ul></li><li>8.4 性能优化 <ul><li>节流与防抖</li><li>Mipmap 策略切换</li></ul></li></ul><p><strong>学习目标</strong>：理解交互处理的最佳实践</p><hr><h2 id="📖-第四部分-插件系统篇" tabindex="-1">📖 第四部分：插件系统篇 <a class="header-anchor" href="#📖-第四部分-插件系统篇" aria-label="Permalink to &quot;📖 第四部分：插件系统篇&quot;">​</a></h2><h3 id="第9章-插件系统架构" tabindex="-1">第9章：插件系统架构 <a class="header-anchor" href="#第9章-插件系统架构" aria-label="Permalink to &quot;第9章：插件系统架构&quot;">​</a></h3><p><strong>核心问题</strong>：如何设计一个可扩展的插件系统？</p><p><strong>内容要点</strong>：</p><ul><li>9.1 PluginSystem 设计 <ul><li>插件注册机制</li><li>插件生命周期</li></ul></li><li>9.2 渲染插件分类 <ul><li>视口类插件（viewport、scrollbar、ruler）</li><li>交互类插件（hand、hover、guide）</li><li>渲染类插件（outline、highlight、mosaic）</li><li>功能类插件（magic-brush、connector）</li></ul></li><li>9.3 核心插件解析 <ul><li><code>viewport-plugin</code> - 视口控制</li><li><code>guide-plugin</code> - 对齐参考线</li><li><code>ruler-plugin</code> - 标尺</li><li><code>transform-plugin</code> - 元素变换</li></ul></li><li>9.4 自定义插件开发 <ul><li>插件接口定义</li><li>开发规范</li><li>示例代码</li></ul></li></ul><p><strong>学习目标</strong>：掌握插件系统的设计模式和扩展方法</p><hr><h2 id="📖-第五部分-性能优化篇" tabindex="-1">📖 第五部分：性能优化篇 <a class="header-anchor" href="#📖-第五部分-性能优化篇" aria-label="Permalink to &quot;📖 第五部分：性能优化篇&quot;">​</a></h2><h3 id="第10章-性能优化策略" tabindex="-1">第10章：性能优化策略 <a class="header-anchor" href="#第10章-性能优化策略" aria-label="Permalink to &quot;第10章：性能优化策略&quot;">​</a></h3><p><strong>核心问题</strong>：如何让画布在万级元素时仍然流畅？</p><p><strong>内容要点</strong>：</p><ul><li>10.1 虚拟化渲染 <ul><li>视口剔除（Viewport Culling）</li><li>按需创建/销毁</li><li>空间索引</li></ul></li><li>10.2 纹理管理 <ul><li>纹理复用</li><li>纹理池</li><li>懒加载策略</li></ul></li><li>10.3 渲染优化 <ul><li>脏矩形检测</li><li>批处理渲染</li><li>LOD 分级渲染</li></ul></li><li>10.4 内存优化 <ul><li>对象池复用</li><li>资源回收</li><li>内存监控</li></ul></li><li>10.5 性能监控 <ul><li>FPS 监控</li><li>渲染时间统计</li><li>性能分析工具</li></ul></li></ul><p><strong>学习目标</strong>：掌握无限画布的性能优化技巧</p><hr><h2 id="📖-附录" tabindex="-1">📖 附录 <a class="header-anchor" href="#📖-附录" aria-label="Permalink to &quot;📖 附录&quot;">​</a></h2><h3 id="第11章-pixijs-与-webgl-基础" tabindex="-1">第11章：PixiJS 与 WebGL 基础 <a class="header-anchor" href="#第11章-pixijs-与-webgl-基础" aria-label="Permalink to &quot;第11章：PixiJS 与 WebGL 基础&quot;">​</a></h3><ul><li>11.1 WebGL 渲染原理</li><li>11.2 PixiJS 核心概念 <ul><li>Container、Sprite、Graphics</li><li>Texture 与 BaseTexture</li><li>Transform 与 Matrix</li></ul></li><li>11.3 Piso（PixiJS 定制版）</li></ul><hr><h3 id="第12章-常见问题与最佳实践" tabindex="-1">第12章：常见问题与最佳实践 <a class="header-anchor" href="#第12章-常见问题与最佳实践" aria-label="Permalink to &quot;第12章：常见问题与最佳实践&quot;">​</a></h3><ul><li>12.1 常见问题 FAQ</li><li>12.2 开发最佳实践</li><li>12.3 调试技巧</li><li>12.4 性能测试方法</li></ul><hr><h2 id="📊-学习路线图" tabindex="-1">📊 学习路线图 <a class="header-anchor" href="#📊-学习路线图" aria-label="Permalink to &quot;📊 学习路线图&quot;">​</a></h2><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>入门阶段（建议 2-3 天）</span></span>
<span class="line"><span>├── 第1章：基础概念与技术选型</span></span>
<span class="line"><span>├── 第2章：坐标系统与矩阵变换</span></span>
<span class="line"><span>└── 第11章：PixiJS 与 WebGL 基础（可选）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>进阶阶段（建议 3-5 天）</span></span>
<span class="line"><span>├── 第3章：Surface 画布表面层</span></span>
<span class="line"><span>├── 第4章：Viewport 视口管理</span></span>
<span class="line"><span>├── 第5章：VmEngine 视图模型引擎</span></span>
<span class="line"><span>└── 第6章：元素生命周期与渲染</span></span>
<span class="line"><span></span></span>
<span class="line"><span>高级阶段（建议 3-5 天）</span></span>
<span class="line"><span>├── 第7章：事件系统与碰撞检测</span></span>
<span class="line"><span>├── 第8章：手势与交互处理</span></span>
<span class="line"><span>├── 第9章：插件系统架构</span></span>
<span class="line"><span>└── 第10章：性能优化策略</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><hr><h2 id="🎯-预期收获" tabindex="-1">🎯 预期收获 <a class="header-anchor" href="#🎯-预期收获" aria-label="Permalink to &quot;🎯 预期收获&quot;">​</a></h2><p>完成本系列学习后，你将能够：</p><ol><li><strong>理解原理</strong>：深入理解无限画布的设计理念和实现原理</li><li><strong>阅读代码</strong>：能够独立阅读和理解编辑器渲染引擎代码</li><li><strong>排查问题</strong>：具备定位和解决渲染相关问题的能力</li><li><strong>性能优化</strong>：掌握画布性能优化的核心策略</li><li><strong>二次开发</strong>：能够基于现有架构进行功能扩展和定制</li></ol><hr><h2 id="📝-文档约定" tabindex="-1">📝 文档约定 <a class="header-anchor" href="#📝-文档约定" aria-label="Permalink to &quot;📝 文档约定&quot;">​</a></h2><ul><li><strong>代码块</strong>：所有代码示例均来自实际项目，路径会在代码块上方标注</li><li><strong>关键概念</strong>：首次出现的关键术语会用 <strong>粗体</strong> 标注</li><li><strong>注意事项</strong>：重要提示会用 <code>&gt; ⚠️</code> 标注</li><li><strong>扩展阅读</strong>：推荐的延伸阅读会在章节末尾列出</li></ul><hr><blockquote><p>📅 文档更新时间：2026-01-27</p><p>👤 维护者：前端团队</p></blockquote>`,89)]))}const b=i(e,[["render",r]]);export{h as __pageData,b as default};
