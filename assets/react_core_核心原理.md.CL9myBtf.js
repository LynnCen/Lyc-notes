import{_ as r,a,b as t,c as i,d as o,e as l}from"./chunks/6.DljeWJxU.js";import{_ as c,c as n,o as p,a8 as s}from"./chunks/framework.B1-gFi6y.js";const g=JSON.parse('{"title":"核心原理","description":"","frontmatter":{},"headers":[],"relativePath":"react/core/核心原理.md","filePath":"react/core/核心原理.md","lastUpdated":1716793116000}'),d={name:"react/core/核心原理.md"};function h(b,e,m,u,_,f){return p(),n("div",null,e[0]||(e[0]=[s('<h1 id="核心原理" tabindex="-1">核心原理 <a class="header-anchor" href="#核心原理" aria-label="Permalink to &quot;核心原理&quot;">​</a></h1><h2 id="异步可中断更新" tabindex="-1">异步可中断更新 <a class="header-anchor" href="#异步可中断更新" aria-label="Permalink to &quot;异步可中断更新&quot;">​</a></h2><h3 id="同步更新和异步更新的区别" tabindex="-1">同步更新和异步更新的区别 <a class="header-anchor" href="#同步更新和异步更新的区别" aria-label="Permalink to &quot;同步更新和异步更新的区别&quot;">​</a></h3><p>如下图</p><p>输入框内输入的文字较多时，同步模式下就会出现明显的卡顿 <img src="'+r+'" alt="alt text"></p><h3 id="对比同步与异步工作模式" tabindex="-1">对比同步与异步工作模式 <a class="header-anchor" href="#对比同步与异步工作模式" aria-label="Permalink to &quot;对比同步与异步工作模式&quot;">​</a></h3><p><strong>同步工作模式</strong></p><p>在该模式下，一旦开启，则不可中断，后续的浏览器事件(IO)都会被阻塞，需要等待整个 render 结束后才会处理</p><p><strong>异步可中断模式</strong></p><p>一个 fiber 就是一个最小的工作单元</p><p>render 阶段，为了避免出现浏览器事件(IO)长期得不到相应而出现的饥饿现象，故把整个 render 做时间切片 time-slicing，在每个时间片的末尾根据优先级查询当前是否有 IO 操作需要响应，如果有则转去处理 IO，当前 render 可暂停、继续、丢弃等，然后进行增量渲染。（关于饥饿现象、时间切片和可中断性可参考 OS）</p><p>Commit 阶段始终是同步的，目的就是为了将变化的部分一次性更新到 DOM 上</p><p><img src="'+a+'" alt="alt text"></p><h3 id="fiber-数据结构" tabindex="-1">Fiber 数据结构 <a class="header-anchor" href="#fiber-数据结构" aria-label="Permalink to &quot;Fiber 数据结构&quot;">​</a></h3><p><img src="'+t+'" alt="alt text"></p><h3 id="fiber-树" tabindex="-1">Fiber 树 <a class="header-anchor" href="#fiber-树" aria-label="Permalink to &quot;Fiber 树&quot;">​</a></h3><p>type 表示组件的类型 tag 表示组件的类型</p><p>节点间的连接关系 child（孩子）、sibling（兄弟）、return（父亲）</p><p>并不是一个标准的树状结构，而是一个链表的结构，用一个链表来表示一棵树，他的好处就是能够做到单向遍历，每一步都可以做到暂停和恢复。</p><p>遍历顺序是深度优先（DFS）：先遍历所有的 child 节点、没有 child 节点就会去找兄弟节点 sibling、然后再是 child 节点，没有 child 节点就去找兄弟节点，没有兄弟节点就回去找 return（表示上一级的节点，并不是 parent）</p><p>从遍历顺序上看，Fiber 树实际上是用链表来表示的树</p><p><img src="'+i+'" alt="alt text"></p><p>根据遍历顺序，以下的打印顺序是什么</p><p><img src="'+o+'" alt="alt text"></p><h3 id="fiber-双缓冲" tabindex="-1">Fiber 双缓冲 <a class="header-anchor" href="#fiber-双缓冲" aria-label="Permalink to &quot;Fiber 双缓冲&quot;">​</a></h3><p>初始 render 阶段，fiber 的 alternate 会绘制成完整的一个 Fiber 树，在 commit 阶段，Fiber 会把 current 节点指向 alternate 节点，做一次性的替换。</p><p>React 默认会创建 rootFiberNode，下面挂在 rootFiber，初次时，rootFiber 下面的 current 是空的（current 任何时候都是指向浏览器实际渲染的内容）。render 阶段，会在 alternate 节点开始计算生成完整的一个 Fiber 树，在 React 内部叫做 workInProgress 树，到了 commit 阶段，表示 workInProgress 树已经计算完成，它会把 alternate 节点浅 copy 到 rootFiber 的 current 节点，由于是浅 copy，整个速度是非常快的。</p><h3 id="scheduler" tabindex="-1">Scheduler <a class="header-anchor" href="#scheduler" aria-label="Permalink to &quot;Scheduler&quot;">​</a></h3><p>React 调度包含两层工作循环 workloop：Scheduler 层和 Fiber(Reconciler) 层</p><p>workloop 为了避免对浏览器造成一个阻塞，使用 Scheduler shouldYeld 方法用来判断当前事件执行的时间是否超过阀值，默认阀值为 5 毫秒 ，如果一个计算任务的计算时长超过这个阀值，react 就是出让浏览器的执行权，让更高优先级的任务插入，保证页面的流畅性。</p><h3 id="reconciler" tabindex="-1">Reconciler <a class="header-anchor" href="#reconciler" aria-label="Permalink to &quot;Reconciler&quot;">​</a></h3><h3 id="整体流程" tabindex="-1">整体流程 <a class="header-anchor" href="#整体流程" aria-label="Permalink to &quot;整体流程&quot;">​</a></h3><p><img src="'+l+'" alt="alt text"></p>',33)]))}const k=c(d,[["render",h]]);export{g as __pageData,k as default};
