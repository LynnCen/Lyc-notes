import{_ as a,c as e,o as i,a7 as n}from"./chunks/framework.BQb8NfN9.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"work/gd/monorepo/RFC: 大型 Monorepo 中基于 Changesets 的混合制品交付策略改进.md","filePath":"work/gd/monorepo/RFC: 大型 Monorepo 中基于 Changesets 的混合制品交付策略改进.md","lastUpdated":1770085732000}'),t={name:"work/gd/monorepo/RFC: 大型 Monorepo 中基于 Changesets 的混合制品交付策略改进.md"};function p(l,s,o,r,h,d){return i(),e("div",null,s[0]||(s[0]=[n(`<p><strong>状态</strong>: In Review</p><h2 id="摘要" tabindex="-1">摘要 <a class="header-anchor" href="#摘要" aria-label="Permalink to &quot;摘要&quot;">​</a></h2><p>在大型 Monorepo 中，Changesets 官方推荐的 <code>privatePackages</code> 方案会导致严重的工程效率问题：大量级联版本更新让代码评审变得困难，频繁的 <code>package.json</code> 变更导致构建缓存失效、CI/CD 性能下降。本文档提出了一种混合版本管理策略，在保留 Changesets 版本管理能力（Git Tag、CHANGELOG）的前提下，通过优化依赖关系和版本更新机制，显著减少不必要的版本变更，提升代码评审效率和 CI/CD 性能。</p><h2 id="术语说明" tabindex="-1">术语说明 <a class="header-anchor" href="#术语说明" aria-label="Permalink to &quot;术语说明&quot;">​</a></h2><p>本文档使用以下术语：</p><ul><li><p><strong>应用包</strong>：非 NPM 包（例如应用程序），这些包不发布到 NPM 仓库，通过 Docker 镜像部署，需要 Changesets 管理版本以生成 Git Tag 触发部署。本文多处使用 <code>@app/*</code> 作为其命名约定。</p></li><li><p><strong>private 包</strong>：在 <code>package.json</code> 中设置了 <code>&quot;private&quot;: true</code> 的包，这是 NPM 包规范定义的字段，它表示包不发布到 NPM 仓库。</p></li></ul><h2 id="动机" tabindex="-1">动机 <a class="header-anchor" href="#动机" aria-label="Permalink to &quot;动机&quot;">​</a></h2><p>Changesets 是目前广泛使用的 Monorepo 版本管理工具。根据其官方文档推荐的方案（<a href="https://github.com/changesets/changesets/blob/main/docs/managing-applications-or-non-npm-packages.md" target="_blank" rel="noreferrer">Managing applications or non-npm packages</a>），建议将应用包配置为 <code>privatePackages</code> 来进行版本控制。具体做法是将应用包在 <code>package.json</code> 中设置为 <code>&quot;private&quot;: true</code>，并在 Changesets 配置中启用 <code>privatePackages</code> 的版本控制。</p><h3 id="痛点-工具哲学与应用特征的冲突" tabindex="-1">痛点：工具哲学与应用特征的冲突 <a class="header-anchor" href="#痛点-工具哲学与应用特征的冲突" aria-label="Permalink to &quot;痛点：工具哲学与应用特征的冲突&quot;">​</a></h3><p>然而，在大型 Monorepo 实践中，这种方法带来了严重问题。这源于<strong>工具的设计哲学（库导向）与应用（Application）的发布特征存在错位</strong>。</p><p>Changesets 根植于 NPM 生态，是为库（Library）设计的。在库的依赖树中，版本传播是必须的（级联更新）。如果 <code>Lib A -&gt; Lib B</code>，当 <code>Lib B</code> 升级时，<code>Lib A</code> 必须发版，以确保消费者获得正确的依赖组合。其核心逻辑是：依赖变更即产物变更，因此需要版本变更。</p><p>相反，应用是依赖树的叶子节点（Leaf Node），其发布行为与库有显著不同。应用通常是&quot;部署（Deploy）&quot;而非&quot;发布（Publish）&quot;，关注的是构建产物（如 Docker 镜像）。</p><ol><li><strong>代码评审困难</strong>：大量的 private 包版本号变更（&quot;Cascading Version Bumps&quot;）让 PR 包含数百行无关修改。在 GitLab 等平台上，这会触发大量不必要的 Code Owner 审核机制，导致一个简单的 PR 需要涉及无关的团队成员进行评审，不仅拖慢了流程，也让真正有意义的变更日志淹没在版本号更新中，失去了评审的焦点。</li><li><strong>CI/CD 效率低下</strong>：频繁的 <code>package.json</code> 变动导致构建系统的缓存失效，每次版本更新都会触发全量构建，大幅降低流水线效率。</li></ol><h3 id="为什么不能直接放弃-changesets" tabindex="-1">为什么不能直接放弃 Changesets <a class="header-anchor" href="#为什么不能直接放弃-changesets" aria-label="Permalink to &quot;为什么不能直接放弃 Changesets&quot;">​</a></h3><p>既然存在冲突，为什么不直接使用 Nx / Turborepo 等智能构建工具来管理版本呢？这些工具通过计算哈希（Hash）完美解决了构建缓存问题。</p><p>但在生产环境交付中，<strong>交付产物（Artifact）的版本控制工作流</strong> 与 <strong>构建触发（Build Trigger）</strong> 是两个维度的需求：</p><ol><li><strong>交付产物的版本控制</strong>：Changesets 提供了一套完整的“变更集 -&gt; 版本号 -&gt; Git Tag -&gt; CHANGELOG”工作流。这关注的是<strong>软件生命周期管理</strong>，确保每次交付都有明确的语义化版本（如 <code>v1.2.0</code>）和可追溯的变更记录。这是运营、QA 和用户所需要的。</li><li><strong>基于变更的构建触发</strong>：Nx / Turborepo 关注的是<strong>构建效率</strong>。它们知道“因为文件 A 变了，所以需要重新构建应用 B”。但它们通常不负责定义“应用 B 这次构建出来的版本号应该是多少”，也不负责生成面向用户的 CHANGELOG。</li></ol><p>因此，我们需要一种方案，既能保留 Changesets 带来的<strong>产物版本控制能力</strong>（Git Tag / Changelog），又能消除其在构建效率方面的副作用。</p><h3 id="社区解决方案现状" tabindex="-1">社区解决方案现状 <a class="header-anchor" href="#社区解决方案现状" aria-label="Permalink to &quot;社区解决方案现状&quot;">​</a></h3><p>针对此问题，社区已经有深入的探讨，例如 <a href="https://github.com/changesets/changesets/issues/849" target="_blank" rel="noreferrer">RFC: Packages extensibility #849</a>。社区希望将 Changesets 升级为一个通用的软件交付工具，不仅支持 NPM 包，还支持 Docker、Go、Rust 等多种类型的产物，并通过插件机制（ChangesetPackage）来扩展版本管理能力。</p><p>然而，这一愿景虽然美好，但目前仍处于提案阶段，短期内无法落地。因此，社区主要有两类解决方案：</p><ol><li><strong>智能构建工具流派（Nx / Turborepo / Rush）</strong>：如果不修改版本号，Nx 等工具可以计算出受影响的应用并重构建。</li><li><strong>补丁/插件流派</strong>：通过编写脚本或配置机器人来忽略内部依赖的自动更新，属于&quot;偏方&quot;。</li></ol><p>本 RFC 方案与社区的长远愿景（支持非 NPM 包管理）是一致的，但作为一种<strong>务实的中间方案（Pragmatic Solution）</strong>，它不需要等待官方的重构，仅利用现有特性即可立即解决核心痛点。</p><h2 id="提议" tabindex="-1">提议 <a class="header-anchor" href="#提议" aria-label="Permalink to &quot;提议&quot;">​</a></h2><p>本方案的核心思路是：Changesets 定位为 <strong>最终交付产物</strong> 的版本管理工具，不再参与 private 包的版本管理。</p><ol><li><p><strong>关闭 private 包的版本管理</strong>：在 Changesets 配置中禁用 <code>privatePackages</code> 的版本控制和 Git Tag 生成。由于 private 包数量通常远多于公开发布的包，禁用其版本管理可以大幅减少版本号变更噪音。</p></li><li><p><strong>阻断级联版本更新</strong>：将应用包对 private 包的依赖放在 <code>devDependencies</code> 中，利用 Changesets 不会因 <code>devDependencies</code> 变化而自动更新版本号的特性，阻断 private 包变更向应用包的级联传播。</p></li><li><p><strong>将应用包视作头等公民</strong>：应用包设置为 <code>&quot;private&quot;: false</code> 以参与版本管理，但通过发布流程的过滤机制确保不会被发布到 NPM 仓库，仅利用 Git Tag 触发 Docker 镜像部署。</p></li></ol><p>通过这种方式，应用包的版本仅在自身代码变更或直接依赖的公共库变更时更新，大幅减少了因 private 包变更导致的版本噪音，同时保留了完整的版本管理能力。</p><h2 id="详细设计" tabindex="-1">详细设计 <a class="header-anchor" href="#详细设计" aria-label="Permalink to &quot;详细设计&quot;">​</a></h2><h3 id="应用包配置" tabindex="-1">应用包配置 <a class="header-anchor" href="#应用包配置" aria-label="Permalink to &quot;应用包配置&quot;">​</a></h3><p>在所有应用包的 <code>package.json</code> 中，确保 <code>&quot;private&quot;: false</code> 或省略该字段，使 Changesets 正常管理它们的版本。为防止意外发布（如本地误操作或 CI 配置错误），在每个应用包的 <code>package.json</code> 中添加 <code>prepublishOnly</code> 生命周期脚本，在 <code>pnpm publish</code> 执行前强制失败并输出错误信息。示例配置如下：</p><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;@app/my-app&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;version&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.0.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;scripts&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;prepublishOnly&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;echo &#39;ERROR: This is an application package and cannot be published to NPM. Do not set </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">private</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">: true as Changesets needs to manage its version for Git Tag generation.&#39; &amp;&amp; exit 1&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;private&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这个钩子会在发布命令执行前运行，如果被触发会立即失败并输出错误信息，确保应用包不会被意外发布到 NPM 仓库。</p><h3 id="依赖管理策略" tabindex="-1">依赖管理策略 <a class="header-anchor" href="#依赖管理策略" aria-label="Permalink to &quot;依赖管理策略&quot;">​</a></h3><p>依赖 private 包的策略需要根据包的发布性质区分处理，避免不必要地放大影响面。</p><h4 id="需要发布到-npm-的公开包" tabindex="-1">需要发布到 NPM 的公开包 <a class="header-anchor" href="#需要发布到-npm-的公开包" aria-label="Permalink to &quot;需要发布到 NPM 的公开包&quot;">​</a></h4><p>如果公开包依赖了 private 包，<strong>必须</strong>使用 <code>devDependencies</code> 而不是 <code>dependencies</code> 引用，否则执行 <code>npm publish</code> 时会失败（private 包无法从公共 NPM 仓库获取）。这些包需要通过打包工具将 <code>devDependencies</code> 中的依赖打包进最终产物。</p><h4 id="应用包" tabindex="-1">应用包 <a class="header-anchor" href="#应用包" aria-label="Permalink to &quot;应用包&quot;">​</a></h4><p>应用包不发布到 NPM，但需要创建 Git Tag 来触发部署。如果应用包依赖了 private 包，<strong>必须</strong>使用 <code>devDependencies</code> 而不是 <code>dependencies</code> 引用，原因包括：</p><ol><li><p><strong>Changesets 限制</strong>：如果应用包在 <code>dependencies</code> 中依赖了被跳过的 private 包（<code>privatePackages.version: false</code>），Changesets 会报错：<code>The package &quot;@app/xxx&quot; depends on the skipped package &quot;@repo/xxx&quot;, but &quot;@app/xxx&quot; is not being skipped</code>。这是 Changesets 的设计限制，不允许非跳过的包依赖跳过的包。</p></li><li><p>减少版本噪音：Changesets 不会因为 <code>devDependencies</code> 的变化而自动更新包的版本号（详见&quot;版本更新策略&quot;章节），从而减少不必要的版本变更。</p></li><li><p>减少镜像体积：将依赖打包进最终产物可以减少 Docker 镜像的体积，因为这可以避免大型 Monorepo 中复杂的本地包依赖被打包到镜像中。</p></li></ol><p>应用包的构建工具（如 webpack、rollup、esbuild 等）<strong>必须</strong>配置为将 <code>devDependencies</code> 中的依赖打包进最终产物，确保运行时能够正常工作。</p><p>示例配置如下：</p><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;@app/my-app&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;version&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.0.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;private&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;dependencies&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;public-lib&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^1.0.0&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;devDependencies&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;@repo/logger&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;workspace:*&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;@repo/ui&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;workspace:*&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="private-包之间的依赖" tabindex="-1">private 包之间的依赖 <a class="header-anchor" href="#private-包之间的依赖" aria-label="Permalink to &quot;private 包之间的依赖&quot;">​</a></h4><p>private 包之间的依赖可以继续使用 <code>dependencies</code> 引用，原因包括：</p><ol><li><p>不会发布失败：private 包不会发布到 NPM，不存在 <code>npm publish</code> 失败的问题。</p></li><li><p>减少影响面：如果要求所有 private 包之间的依赖都放在 <code>devDependencies</code> 中，需要所有 private 包都支持打包，这会大幅增加影响面和实施成本。</p></li><li><p>保持灵活性：private 包可能不需要打包（如配置类包、工具类包），使用 <code>dependencies</code> 可以保持依赖关系的清晰和灵活性。</p></li></ol><p><strong>总结：只有需要发布到 NPM 的公开包和需要减少版本噪音的应用包才需要将 private 依赖放在 <code>devDependencies</code> 中</strong>。private 包之间的依赖可以继续使用 <code>dependencies</code>，避免不必要地放大影响面。</p><h3 id="changesets-配置" tabindex="-1">Changesets 配置 <a class="header-anchor" href="#changesets-配置" aria-label="Permalink to &quot;Changesets 配置&quot;">​</a></h3><p>在 <code>.changeset/config.json</code> 中关闭 <code>privatePackages</code> 的自动版本控制和 Git Tag 生成功能。配置示例如下：</p><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;updateInternalDependencies&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;patch&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;privatePackages&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;version&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;tag&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;ignore&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>配置说明：</p><ul><li><p><code>privatePackages.version: false</code>：禁用 private 包的版本号自动更新。在大型 Monorepo 中，private 包的数量通常远多于公开发布的包，如果启用版本控制会导致大量的版本号变更噪音，严重影响代码评审效率和 CI 性能。</p></li><li><p><code>privatePackages.tag: false</code>：禁用 private 包的 Git Tag 生成。由于版本号不会更新，创建 Tag 也没有实际意义。</p></li><li><p><code>ignore: []</code>：不忽略应用包，让它们参与版本管理。</p></li></ul><p><strong>注意</strong>：应用包是 <code>&quot;private&quot;: false</code>，因此 <code>privatePackages</code> 配置<strong>不会影响它们</strong>。它们会正常更新版本并在 <code>changeset publish</code> 阶段创建 Git Tag。</p><h3 id="发布流程修改" tabindex="-1">发布流程修改 <a class="header-anchor" href="#发布流程修改" aria-label="Permalink to &quot;发布流程修改&quot;">​</a></h3><p>修改根目录 <code>package.json</code> 中的 <code>changeset:publish</code> 脚本，利用 pnpm 的过滤能力排除应用包。脚本配置如下：</p><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;scripts&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;changeset:publish&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;pnpm publish -r --filter=!@app/* &amp;&amp; changeset tag&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>重要</strong>：由于使用 <code>pnpm publish -r</code> 代替 <code>changeset publish</code> 发布包，Changesets 不会自动创建 Git Tag。因此需要在发布命令后添加 <code>changeset tag</code> 来为所有已发布版本创建 Git Tag（包括应用包的 Git Tag，例如 <code>@app/my-app@1.0.1</code>）。</p><p>项目通过 <code>changesets-gitlab</code> 配置发布流程，使用环境变量 <code>INPUT_PUBLISH</code> 指向 <code>changeset:publish</code> 脚本。CI/CD 配置示例如下：</p><div class="language-yaml vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">pnpm install</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">pnpm run build</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">pnpm exec changesets-gitlab</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">variables</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  INPUT_VERSION</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">pnpm run changeset:version</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  INPUT_PUBLISH</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">pnpm run changeset:publish</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>工作流程中，<code>changesets version</code>（通过 <code>INPUT_VERSION</code> 执行）正常运行，更新所有包（包括应用包）的 <code>package.json</code> 版本号，生成 CHANGELOG。<code>changesets-gitlab</code> 自动将版本更新和 CHANGELOG 提交到仓库。执行 <code>changeset:publish</code>（通过 <code>INPUT_PUBLISH</code> 执行）时，该命令会：</p><ol><li>执行 <code>pnpm publish -r --filter=!@app/*</code> 发布 NPM 库到 NPM 仓库（排除应用包）</li><li>执行 <code>changeset tag</code> 为所有已发布版本创建 Git Tag（包括应用包的 Git Tag，例如 <code>@app/my-app@1.0.1</code>）</li></ol><h3 id="版本更新策略" tabindex="-1">版本更新策略 <a class="header-anchor" href="#版本更新策略" aria-label="Permalink to &quot;版本更新策略&quot;">​</a></h3><p>Changesets 默认行为是只有当存在对应的 <code>.changeset/*.md</code> 文件时，才会更新包的版本。使用 <code>devDependencies</code> + 打包策略后，Changesets 不会因为 private 包（devDependencies）的变化而自动更新依赖方的版本号。</p><h4 id="版本更新机制" tabindex="-1">版本更新机制 <a class="header-anchor" href="#版本更新机制" aria-label="Permalink to &quot;版本更新机制&quot;">​</a></h4><p>示例场景：假设 <code>@app/a@1.0.0</code> 通过 <code>devDependencies</code> 依赖了 <code>@repo/lib</code>（使用 <code>workspace:*</code> 协议）。如果 <code>@repo/lib</code> 发生了代码变更，<code>@app/a</code> 的版本号不会自动更新，仍然保持 <code>1.0.0</code>。如果 <code>@app/a</code> 需要部署新版本（例如需要包含 <code>@repo/lib</code> 的变更），必须手动为 <code>@app/a</code> 创建 Changeset 才能触发版本更新。</p><h4 id="版本更新触发条件" tabindex="-1">版本更新触发条件 <a class="header-anchor" href="#版本更新触发条件" aria-label="Permalink to &quot;版本更新触发条件&quot;">​</a></h4><ol><li>应用自身代码变更：必须创建 Changeset，触发版本更新和 Git Tag 生成</li><li>公开库（dependencies）变更：Changesets 会自动更新版本（根据 <code>updateInternalDependencies</code> 配置）</li><li>private 包（devDependencies）变更：<strong>不会自动更新版本</strong>，需要手动创建 Changeset 才能触发版本更新</li></ol><h3 id="部署流程集成" tabindex="-1">部署流程集成 <a class="header-anchor" href="#部署流程集成" aria-label="Permalink to &quot;部署流程集成&quot;">​</a></h3><p>现有的 Docker 镜像部署流程可以继续使用 Changesets 生成的 Git Tag 来触发，无需修改。应用包的 Git Tag（格式为 <code>@app/.*@.*</code>）可以正常触发部署流程。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>本方案并非完美的“银弹”，而是一种针对大型 Monorepo 现状的<strong>妥协方案</strong>。我们主要与官方推荐方案进行对比：</p><p><strong>官方方案 (private: true)</strong> 优先保证<strong>语义化版本的严格正确性</strong>。它认为依赖变了，应用本身也就变了，因此版本号必须增加。这在理论上是完美的，几乎不会出错。</p><p><strong>本 RFC 方案</strong> 则优先保证<strong>工程效率</strong>。通过隔离 <code>devDependencies</code>，我们阻断了变更的级联传播。这是一种<strong>工程化规避（Workaround）</strong>，其代价是牺牲了部分语义严谨性，并引入了以下<strong>风险与副作用</strong>：</p><ol><li><p><strong>破坏了 &quot;private&quot; 的语义</strong>：应用包在 <code>package.json</code> 中设置为 <code>&quot;private&quot;: false</code>，但实际上并不发布到 NPM，这破坏了 <code>private</code> 字段的语义。</p></li><li><p><strong>版本更新需要手动触发（最大风险）</strong>：依赖的 private 包发生变更后，依赖方（应用包或需要发布到 NPM 的公开包）不再自动更新版本号。开发者需要手动判断是否需要更新版本，并创建 Changeset 才能触发版本更新（详见&quot;版本更新策略&quot;章节）。如果开发者忘记创建 Changeset，可能导致代码已变更但版本号未更新（最终也不会被发布或部署）。</p></li></ol><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://github.com/changesets/changesets/blob/main/docs/managing-applications-or-non-npm-packages.md" target="_blank" rel="noreferrer">Changesets 官方文档：Managing applications or non-npm packages</a></li><li><a href="https://github.com/changesets/changesets/blob/main/docs/config-file-options.md" target="_blank" rel="noreferrer">Changesets 配置文档</a></li><li><a href="https://github.com/changesets/changesets/issues/849" target="_blank" rel="noreferrer">RFC: Packages extensibility #849 (Community Discussion)</a></li><li><a href="https://pnpm.io/filtering" target="_blank" rel="noreferrer">pnpm 过滤选项文档</a></li></ul>`,75)]))}const g=a(t,[["render",p]]);export{k as __pageData,g as default};
