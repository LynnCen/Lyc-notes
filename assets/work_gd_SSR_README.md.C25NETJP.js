import{_ as a,c as n,o as e,a7 as l}from"./chunks/framework.BQb8NfN9.js";const b=JSON.parse('{"title":"SSR (Server-Side Rendering) 技术文档集","description":"","frontmatter":{},"headers":[],"relativePath":"work/gd/SSR/README.md","filePath":"work/gd/SSR/README.md","lastUpdated":1770085732000}'),i={name:"work/gd/SSR/README.md"};function p(r,s,t,o,d,c){return e(),n("div",null,s[0]||(s[0]=[l(`<h1 id="ssr-server-side-rendering-技术文档集" tabindex="-1">SSR (Server-Side Rendering) 技术文档集 <a class="header-anchor" href="#ssr-server-side-rendering-技术文档集" aria-label="Permalink to &quot;SSR (Server-Side Rendering) 技术文档集&quot;">​</a></h1><blockquote><p><strong>文档集概述</strong><br> 本目录包含了服务端渲染（SSR）技术的完整文档体系，从基础概念到核心机制，从鉴权方案到 AB 实验优化，涵盖了 SSR 架构的各个方面。</p></blockquote><hr><h2 id="📚-文档导航" tabindex="-1">📚 文档导航 <a class="header-anchor" href="#📚-文档导航" aria-label="Permalink to &quot;📚 文档导航&quot;">​</a></h2><h3 id="🎯-第一层级-基础入门" tabindex="-1">🎯 第一层级：基础入门 <a class="header-anchor" href="#🎯-第一层级-基础入门" aria-label="Permalink to &quot;🎯 第一层级：基础入门&quot;">​</a></h3><p>从零开始了解 SSR，掌握前后端同构的核心概念。</p><table tabindex="0"><thead><tr><th>文档</th><th>核心内容</th><th>适合人群</th></tr></thead><tbody><tr><td><strong><a href="./01-基础入门-前后端同构快速入门">01-基础入门-前后端同构快速入门</a></strong></td><td>SSR 常见问题、生命周期缓存、辅助方法</td><td>🎯 SSR 初学者</td></tr><tr><td><strong><a href="./02-基础入门-SSR接入文档">02-基础入门-SSR接入文档</a></strong></td><td>实际接入流程、配置指南</td><td>🎯 实践接入</td></tr></tbody></table><h3 id="🔧-第二层级-核心机制" tabindex="-1">🔧 第二层级：核心机制 <a class="header-anchor" href="#🔧-第二层级-核心机制" aria-label="Permalink to &quot;🔧 第二层级：核心机制&quot;">​</a></h3><p>深入理解 SSR 的数据请求与水合机制，这是 SSR 的核心。</p><table tabindex="0"><thead><tr><th>文档</th><th>核心内容</th><th>适合人群</th></tr></thead><tbody><tr><td><strong><a href="./03-核心机制-SSR场景下接口数据请求及水合机制">03-核心机制-SSR场景下接口数据请求及水合机制</a></strong></td><td>数据请求、水合原理、状态同步</td><td>🔧 深入理解 SSR</td></tr><tr><td><strong><a href="./04-核心机制-RFC-SSR场景下接口数据请求及水合机制更新">04-核心机制-RFC-SSR场景下接口数据请求及水合机制更新</a></strong></td><td>机制升级、性能优化</td><td>🔧 架构优化</td></tr></tbody></table><h3 id="🔐-第三层级-鉴权与-token-管理" tabindex="-1">🔐 第三层级：鉴权与 Token 管理 <a class="header-anchor" href="#🔐-第三层级-鉴权与-token-管理" aria-label="Permalink to &quot;🔐 第三层级：鉴权与 Token 管理&quot;">​</a></h3><p>SSR 场景下的身份认证与授权机制，确保安全性与用户体验。</p><table tabindex="0"><thead><tr><th>文档</th><th>核心内容</th><th>适合人群</th></tr></thead><tbody><tr><td><strong><a href="./05-鉴权-RFC16-SSR鉴权流程标准化提议">05-鉴权-RFC16-SSR鉴权流程标准化提议</a></strong></td><td>鉴权流程、水合问题、缓存污染</td><td>🔐 鉴权架构</td></tr><tr><td><strong><a href="./06-鉴权-SSR中使用OAuth和JWT的最佳实践">06-鉴权-SSR中使用OAuth和JWT的最佳实践</a></strong></td><td>OAuth 2.0、JWT、安全最佳实践</td><td>🔐 安全实践</td></tr><tr><td><strong><a href="./07-鉴权-服务端刷新tokens并发问题与解决方案">07-鉴权-服务端刷新tokens并发问题与解决方案</a></strong></td><td>Token 并发刷新、分布式锁、请求去重</td><td>🔐 并发控制</td></tr><tr><td><strong><a href="./08-鉴权-Token应当由服务端还是客户端刷新">08-鉴权-Token应当由服务端还是客户端刷新</a></strong></td><td>Token 刷新策略、技术决策</td><td>🔐 架构决策</td></tr></tbody></table><h3 id="🧪-第四层级-ab-实验系列" tabindex="-1">🧪 第四层级：AB 实验系列 <a class="header-anchor" href="#🧪-第四层级-ab-实验系列" aria-label="Permalink to &quot;🧪 第四层级：AB 实验系列&quot;">​</a></h3><p>SSR 场景下的 AB 实验基础设施，从缓存策略到跨平台支持。</p><table tabindex="0"><thead><tr><th>文档</th><th>核心内容</th><th>适合人群</th></tr></thead><tbody><tr><td><strong><a href="./09-AB实验-RFC12.1-SSR场景下的AB实验与缓存策略改进">09-AB实验-RFC12.1-SSR场景下的AB实验与缓存策略改进</a></strong></td><td>AB 实验基础、缓存策略、Cache Key</td><td>🧪 AB 基础</td></tr><tr><td><strong><a href="./10-AB实验-RFC12.2-SSR场景下的AB实验数据获取优化">10-AB实验-RFC12.2-SSR场景下的AB实验数据获取优化</a></strong></td><td>数据获取优化、性能提升</td><td>🧪 性能优化</td></tr><tr><td><strong><a href="./11-AB实验-RFC12.3-提高AB缓存命中率">11-AB实验-RFC12.3-提高AB缓存命中率</a></strong></td><td>缓存命中率优化、缓存策略</td><td>🧪 缓存优化</td></tr><tr><td><strong><a href="./12-AB实验-RFC12.4-AB支持花瓣服务端">12-AB实验-RFC12.4-AB支持花瓣服务端</a></strong></td><td>跨平台支持、花瓣适配</td><td>🧪 跨平台</td></tr></tbody></table><hr><h2 id="🗺️-学习路径" tabindex="-1">🗺️ 学习路径 <a class="header-anchor" href="#🗺️-学习路径" aria-label="Permalink to &quot;🗺️ 学习路径&quot;">​</a></h2><h3 id="路径-1-新手入门-推荐" tabindex="-1">路径 1：新手入门（推荐） <a class="header-anchor" href="#路径-1-新手入门-推荐" aria-label="Permalink to &quot;路径 1：新手入门（推荐）&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1. 前后端同构快速入门</span></span>
<span class="line"><span>   ↓ 了解 SSR 基础概念</span></span>
<span class="line"><span>2. SSR 接入文档</span></span>
<span class="line"><span>   ↓ 掌握实践接入流程</span></span>
<span class="line"><span>3. SSR 场景下接口数据请求及水合机制</span></span>
<span class="line"><span>   ↓ 理解核心原理</span></span>
<span class="line"><span>4. 根据需求选择专题深入</span></span>
<span class="line"><span>   ├─ 鉴权场景 → 鉴权系列文档</span></span>
<span class="line"><span>   └─ AB 实验 → AB 实验系列文档</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="路径-2-架构设计" tabindex="-1">路径 2：架构设计 <a class="header-anchor" href="#路径-2-架构设计" aria-label="Permalink to &quot;路径 2：架构设计&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1. 核心机制文档（数据请求与水合）</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>2. 鉴权系列文档（完整的鉴权方案）</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>3. AB 实验系列文档（实验基础设施）</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>4. 综合应用到实际项目</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="路径-3-问题导向" tabindex="-1">路径 3：问题导向 <a class="header-anchor" href="#路径-3-问题导向" aria-label="Permalink to &quot;路径 3：问题导向&quot;">​</a></h3><p>根据遇到的具体问题，直接查阅相关文档：</p><table tabindex="0"><thead><tr><th>问题类型</th><th>推荐文档</th></tr></thead><tbody><tr><td><strong>水合失败</strong></td><td>核心机制系列、前后端同构快速入门</td></tr><tr><td><strong>鉴权问题</strong></td><td>鉴权系列（RFC 16、OAuth/JWT）</td></tr><tr><td><strong>Token 刷新</strong></td><td>Token 并发问题、Token 刷新策略</td></tr><tr><td><strong>AB 实验不生效</strong></td><td>RFC 12.1、RFC 12.2</td></tr><tr><td><strong>缓存命中率低</strong></td><td>RFC 12.3</td></tr><tr><td><strong>跨平台 AB</strong></td><td>RFC 12.4</td></tr></tbody></table><hr><h2 id="🔑-核心概念" tabindex="-1">🔑 核心概念 <a class="header-anchor" href="#🔑-核心概念" aria-label="Permalink to &quot;🔑 核心概念&quot;">​</a></h2><h3 id="ssr-server-side-rendering" tabindex="-1">SSR (Server-Side Rendering) <a class="header-anchor" href="#ssr-server-side-rendering" aria-label="Permalink to &quot;SSR (Server-Side Rendering)&quot;">​</a></h3><p><strong>定义</strong>：在服务器端执行前端框架代码，生成完整的 HTML 页面返回给浏览器。</p><p><strong>核心优势</strong>：</p><ul><li>✅ <strong>SEO 友好</strong>：搜索引擎可以直接抓取完整内容</li><li>✅ <strong>首屏快速</strong>：用户更快看到内容（TTFB、FCP、LCP 优化）</li><li>✅ <strong>用户体验</strong>：减少白屏时间，提升感知性能</li></ul><p><strong>核心挑战</strong>：</p><ul><li>⚠️ <strong>水合问题</strong>：服务端与客户端状态不一致</li><li>⚠️ <strong>环境差异</strong>：服务端没有 <code>window</code>、<code>document</code> 等浏览器 API</li><li>⚠️ <strong>请求污染</strong>：多用户请求共享服务端代码</li><li>⚠️ <strong>缓存复杂</strong>：需要考虑个性化内容与缓存的平衡</li></ul><h3 id="水合-hydration" tabindex="-1">水合 (Hydration) <a class="header-anchor" href="#水合-hydration" aria-label="Permalink to &quot;水合 (Hydration)&quot;">​</a></h3><p><strong>定义</strong>：客户端 JavaScript 接管服务端渲染的 HTML，使其变为可交互的动态页面。</p><p><strong>工作流程</strong>：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>服务端渲染 HTML</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>浏览器接收并显示静态 HTML（用户已可见）</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>加载客户端 JavaScript</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>水合：将事件监听器绑定到 DOM</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>页面变为可交互</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>关键要求</strong>：</p><ul><li>🔴 <strong>状态一致</strong>：服务端和客户端的初始渲染结果必须完全一致</li><li>🔴 <strong>数据同步</strong>：服务端获取的数据需要传递给客户端</li><li>🔴 <strong>生命周期</strong>：理解 SSR 和 CSR 的生命周期差异</li></ul><h3 id="前后端同构-isomorphic-universal" tabindex="-1">前后端同构 (Isomorphic / Universal) <a class="header-anchor" href="#前后端同构-isomorphic-universal" aria-label="Permalink to &quot;前后端同构 (Isomorphic / Universal)&quot;">​</a></h3><p><strong>定义</strong>：同一套代码既可以在服务端运行，也可以在客户端运行。</p><p><strong>核心价值</strong>：</p><ul><li>✅ 代码复用，减少维护成本</li><li>✅ 统一的开发体验</li><li>✅ 更容易实现 SSR</li></ul><p><strong>实现要点</strong>：</p><ul><li>📦 使用条件导出适配不同环境</li><li>📦 避免单例模式，防止请求污染</li><li>📦 使用辅助方法屏蔽环境差异</li><li>📦 区分 SSR 和 CSR 生命周期</li></ul><h3 id="生命周期缓存-lifecycle-cache" tabindex="-1">生命周期缓存 (Lifecycle Cache) <a class="header-anchor" href="#生命周期缓存-lifecycle-cache" aria-label="Permalink to &quot;生命周期缓存 (Lifecycle Cache)&quot;">​</a></h3><p><strong>定义</strong>：将服务端数据请求的结果随 HTML 传递给客户端，避免重复请求。</p><p><strong>工作原理</strong>：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>服务端：</span></span>
<span class="line"><span>  ├─ 执行数据请求</span></span>
<span class="line"><span>  ├─ 缓存请求结果</span></span>
<span class="line"><span>  ├─ 渲染 HTML</span></span>
<span class="line"><span>  └─ 将缓存数据序列化后嵌入 HTML</span></span>
<span class="line"><span></span></span>
<span class="line"><span>客户端：</span></span>
<span class="line"><span>  ├─ 解析 HTML 中的缓存数据</span></span>
<span class="line"><span>  ├─ 水合时使用缓存数据（不重新请求）</span></span>
<span class="line"><span>  └─ 用户交互后才发起新请求</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>关键价值</strong>：</p><ul><li>✅ 避免数据请求重复</li><li>✅ 确保水合时状态一致</li><li>✅ 提升性能</li></ul><h3 id="cache-key" tabindex="-1">Cache Key <a class="header-anchor" href="#cache-key" aria-label="Permalink to &quot;Cache Key&quot;">​</a></h3><p><strong>定义</strong>：缓存系统用于标识缓存内容的唯一键。</p><p><strong>SSR 场景的 Cache Key 组成</strong>：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Cache Key = hash(</span></span>
<span class="line"><span>  URL +</span></span>
<span class="line"><span>  登录状态 +</span></span>
<span class="line"><span>  用户ID（登录后）+</span></span>
<span class="line"><span>  AB 实验组 +</span></span>
<span class="line"><span>  其他个性化因素</span></span>
<span class="line"><span>)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>AB 实验的 Cache Key 策略</strong>：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>未优化：</span></span>
<span class="line"><span>  每个用户一个缓存 → 缓存爆炸</span></span>
<span class="line"><span></span></span>
<span class="line"><span>优化后：</span></span>
<span class="line"><span>  按 AB 实验组分组 → 有限的缓存版本</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>示例：</span></span>
<span class="line"><span>  2 个实验 → 2^2 = 4 个缓存版本</span></span>
<span class="line"><span>  3 个实验 → 2^3 = 8 个缓存版本</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><hr><h2 id="📊-技术架构图" tabindex="-1">📊 技术架构图 <a class="header-anchor" href="#📊-技术架构图" aria-label="Permalink to &quot;📊 技术架构图&quot;">​</a></h2><h3 id="ssr-整体架构" tabindex="-1">SSR 整体架构 <a class="header-anchor" href="#ssr-整体架构" aria-label="Permalink to &quot;SSR 整体架构&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>用户请求</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>CDN / 边缘节点</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>BFF 层（King BFF）</span></span>
<span class="line"><span>   ├─ 鉴权</span></span>
<span class="line"><span>   ├─ AB 实验数据获取</span></span>
<span class="line"><span>   ├─ 缓存检查</span></span>
<span class="line"><span>   └─ ↓</span></span>
<span class="line"><span>Meta SSR 服务</span></span>
<span class="line"><span>   ├─ 执行 Vue/React SSR</span></span>
<span class="line"><span>   ├─ 数据请求（携带 AB Tag）</span></span>
<span class="line"><span>   ├─ 渲染 HTML</span></span>
<span class="line"><span>   ├─ 生成缓存数据</span></span>
<span class="line"><span>   └─ ↓</span></span>
<span class="line"><span>返回 HTML + 内嵌数据</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>浏览器</span></span>
<span class="line"><span>   ├─ 显示 HTML</span></span>
<span class="line"><span>   ├─ 加载 JavaScript</span></span>
<span class="line"><span>   ├─ 水合（使用内嵌数据）</span></span>
<span class="line"><span>   └─ 变为可交互</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h3 id="ssr-鉴权流程" tabindex="-1">SSR 鉴权流程 <a class="header-anchor" href="#ssr-鉴权流程" aria-label="Permalink to &quot;SSR 鉴权流程&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1. 用户请求带 Cookie（Access Token + Refresh Token）</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>2. BFF 验证 Access Token</span></span>
<span class="line"><span>   ├─ 有效 → 继续</span></span>
<span class="line"><span>   └─ 无效 → 尝试刷新</span></span>
<span class="line"><span>       ├─ Refresh Token 有效 → 刷新 Access Token</span></span>
<span class="line"><span>       └─ Refresh Token 无效 → 重定向登录</span></span>
<span class="line"><span>          ↓</span></span>
<span class="line"><span>3. SSR 渲染（携带用户信息）</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>4. 返回 HTML（不包含 Token）</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>5. 客户端水合（从 Cookie 读取 Token）</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="ab-实验在-ssr-中的流程" tabindex="-1">AB 实验在 SSR 中的流程 <a class="header-anchor" href="#ab-实验在-ssr-中的流程" aria-label="Permalink to &quot;AB 实验在 SSR 中的流程&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1. 用户请求</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>2. 检查 Cookie 中的 x-ab-test-id</span></span>
<span class="line"><span>   ├─ 存在 → 使用缓存的 AB 组</span></span>
<span class="line"><span>   └─ 不存在 → 请求 AB 服务</span></span>
<span class="line"><span>       ├─ 计算 AB 组</span></span>
<span class="line"><span>       ├─ 生成 x-ab-test-id</span></span>
<span class="line"><span>       └─ 种入 Cookie</span></span>
<span class="line"><span>          ↓</span></span>
<span class="line"><span>3. 组装 Cache Key（包含 AB 组）</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>4. 检查缓存</span></span>
<span class="line"><span>   ├─ 命中 → 返回缓存</span></span>
<span class="line"><span>   └─ 未命中 → SSR 渲染</span></span>
<span class="line"><span>       ├─ 请求接口（携带 AB Tag）</span></span>
<span class="line"><span>       ├─ 渲染对应的 AB 实验内容</span></span>
<span class="line"><span>       └─ 写入缓存</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><hr><h2 id="🛠️-快速开始" tabindex="-1">🛠️ 快速开始 <a class="header-anchor" href="#🛠️-快速开始" aria-label="Permalink to &quot;🛠️ 快速开始&quot;">​</a></h2><h3 id="场景-1-第一次接入-ssr" tabindex="-1">场景 1：第一次接入 SSR <a class="header-anchor" href="#场景-1-第一次接入-ssr" aria-label="Permalink to &quot;场景 1：第一次接入 SSR&quot;">​</a></h3><p><strong>步骤</strong>：</p><ol><li>阅读 <a href="./01-基础入门-前后端同构快速入门">前后端同构快速入门</a></li><li>了解常见陷阱： <ul><li>❌ 使用浏览器 API（<code>window</code>、<code>document</code>）</li><li>❌ 单例模式导致请求污染</li><li>❌ 服务端客户端状态不一致</li></ul></li><li>使用生命周期缓存：</li></ol><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Vue 3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { cacheProvider } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@web-widget/helpers/cache&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> cacheProvider</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;cache_key&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Vue 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { syncCacheProvider } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@web-widget/helpers/cache&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> syncCacheProvider</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;cache_key&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><ol start="4"><li>阅读 <a href="./02-基础入门-SSR接入文档">SSR 接入文档</a> 完成实际接入</li></ol><h3 id="场景-2-实现-ssr-鉴权" tabindex="-1">场景 2：实现 SSR 鉴权 <a class="header-anchor" href="#场景-2-实现-ssr-鉴权" aria-label="Permalink to &quot;场景 2：实现 SSR 鉴权&quot;">​</a></h3><p><strong>步骤</strong>：</p><ol><li>阅读 <a href="./05-鉴权-RFC16-SSR鉴权流程标准化提议">RFC 16: SSR 鉴权流程标准化提议</a></li><li>了解核心原则： <ul><li>✅ Token 存储在 HttpOnly Cookie</li><li>✅ SSR 从 BFF 获取鉴权状态</li><li>✅ 避免 Token 包含在 HTML 中</li></ul></li><li>实现 Token 刷新： <ul><li>阅读 <a href="./07-鉴权-服务端刷新tokens并发问题与解决方案">服务端刷新 tokens 并发问题与解决方案</a></li><li>使用分布式锁或请求去重</li></ul></li><li>参考 <a href="./06-鉴权-SSR中使用OAuth和JWT的最佳实践">OAuth 和 JWT 最佳实践</a></li></ol><h3 id="场景-3-支持-ab-实验" tabindex="-1">场景 3：支持 AB 实验 <a class="header-anchor" href="#场景-3-支持-ab-实验" aria-label="Permalink to &quot;场景 3：支持 AB 实验&quot;">​</a></h3><p><strong>步骤</strong>：</p><ol><li>阅读 <a href="./09-AB实验-RFC12.1-SSR场景下的AB实验与缓存策略改进">RFC 12.1: SSR 场景下的 AB 实验与缓存策略改进</a></li><li>理解核心机制： <ul><li>AB SDK 适配 SSR</li><li>AB 组纳入 Cache Key</li><li>使用 Cookie 缓存 AB 组</li></ul></li><li>优化性能： <ul><li>阅读 <a href="./10-AB实验-RFC12.2-SSR场景下的AB实验数据获取优化">RFC 12.2: 数据获取优化</a></li><li>阅读 <a href="./11-AB实验-RFC12.3-提高AB缓存命中率">RFC 12.3: 提高缓存命中率</a></li></ul></li><li>跨平台支持： <ul><li>阅读 <a href="./12-AB实验-RFC12.4-AB支持花瓣服务端">RFC 12.4: AB 支持花瓣服务端</a></li></ul></li></ol><hr><h2 id="⚠️-常见问题与陷阱" tabindex="-1">⚠️ 常见问题与陷阱 <a class="header-anchor" href="#⚠️-常见问题与陷阱" aria-label="Permalink to &quot;⚠️ 常见问题与陷阱&quot;">​</a></h2><h3 id="问题-1-水合失败" tabindex="-1">问题 1：水合失败 <a class="header-anchor" href="#问题-1-水合失败" aria-label="Permalink to &quot;问题 1：水合失败&quot;">​</a></h3><p><strong>现象</strong>：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Warning: Text content did not match. </span></span>
<span class="line"><span>Server: &quot;Loading...&quot; Client: &quot;Hello World&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>原因</strong>：</p><ul><li>服务端和客户端渲染结果不一致</li><li>数据请求在客户端重新执行，结果不同</li><li>使用了浏览器特定 API</li></ul><p><strong>解决方案</strong>：</p><ul><li>✅ 使用生命周期缓存同步数据</li><li>✅ 检查服务端是否有浏览器 API 调用</li><li>✅ 确保初始状态完全一致</li></ul><h3 id="问题-2-请求污染" tabindex="-1">问题 2：请求污染 <a class="header-anchor" href="#问题-2-请求污染" aria-label="Permalink to &quot;问题 2：请求污染&quot;">​</a></h3><p><strong>现象</strong>：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>用户 A 访问 → 看到用户 B 的数据</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><strong>原因</strong>：</p><ul><li>使用单例模式缓存用户数据</li><li>全局变量在多个请求间共享</li></ul><p><strong>解决方案</strong>：</p><ul><li>✅ 避免单例模式</li><li>✅ 基于请求上下文创建实例</li><li>✅ 使用元框架提供的 <code>context()</code> 方法</li></ul><h3 id="问题-3-ab-实验不生效" tabindex="-1">问题 3：AB 实验不生效 <a class="header-anchor" href="#问题-3-ab-实验不生效" aria-label="Permalink to &quot;问题 3：AB 实验不生效&quot;">​</a></h3><p><strong>现象</strong>：</p><ul><li>首次访问没有 AB 实验内容</li><li>刷新后又看到 AB 实验内容</li></ul><p><strong>原因</strong>：</p><ul><li>缓存页面没有 AB 实验</li><li>AB SDK 没有适配 SSR</li></ul><p><strong>解决方案</strong>：</p><ul><li>✅ 参考 RFC 12.1 改造 AB SDK</li><li>✅ 将 AB 组纳入 Cache Key</li><li>✅ 使用 Cookie 缓存 AB 组</li></ul><h3 id="问题-4-token-刷新并发问题" tabindex="-1">问题 4：Token 刷新并发问题 <a class="header-anchor" href="#问题-4-token-刷新并发问题" aria-label="Permalink to &quot;问题 4：Token 刷新并发问题&quot;">​</a></h3><p><strong>现象</strong>：</p><ul><li>多个并发请求同时刷新 Token</li><li>Token 被覆盖或失效</li></ul><p><strong>原因</strong>：</p><ul><li>没有并发控制机制</li></ul><p><strong>解决方案</strong>：</p><ul><li>✅ 使用分布式锁（Redis SETNX）</li><li>✅ 实现请求去重</li><li>✅ 参考 RFC 中的 6 种解决方案</li></ul><hr><h2 id="📈-性能优化" tabindex="-1">📈 性能优化 <a class="header-anchor" href="#📈-性能优化" aria-label="Permalink to &quot;📈 性能优化&quot;">​</a></h2><h3 id="关键性能指标" tabindex="-1">关键性能指标 <a class="header-anchor" href="#关键性能指标" aria-label="Permalink to &quot;关键性能指标&quot;">​</a></h3><table tabindex="0"><thead><tr><th>指标</th><th>说明</th><th>目标</th><th>SSR 优势</th></tr></thead><tbody><tr><td><strong>TTFB</strong></td><td>Time to First Byte</td><td>&lt; 200ms</td><td>✅ 缓存优化</td></tr><tr><td><strong>FCP</strong></td><td>First Contentful Paint</td><td>&lt; 1.8s</td><td>✅ SSR 直接输出内容</td></tr><tr><td><strong>LCP</strong></td><td>Largest Contentful Paint</td><td>&lt; 2.5s</td><td>✅ 关键内容服务端渲染</td></tr><tr><td><strong>TTI</strong></td><td>Time to Interactive</td><td>&lt; 3.8s</td><td>⚠️ 需要等待 JS 加载</td></tr><tr><td><strong>Hydration Time</strong></td><td>水合时间</td><td>&lt; 500ms</td><td>⚠️ 需要优化</td></tr></tbody></table><h3 id="优化策略" tabindex="-1">优化策略 <a class="header-anchor" href="#优化策略" aria-label="Permalink to &quot;优化策略&quot;">​</a></h3><p><strong>1. 缓存策略</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>登录前页面：</span></span>
<span class="line"><span>  - maxAge: 10 分钟</span></span>
<span class="line"><span>  - staleWhileRevalidate: 1 周</span></span>
<span class="line"><span>  - staleIfError: 1 周</span></span>
<span class="line"><span></span></span>
<span class="line"><span>登录后页面：</span></span>
<span class="line"><span>  - maxAge: 1 分钟</span></span>
<span class="line"><span>  - 按用户 ID 分组缓存</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>2. AB 实验缓存优化</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>问题：AB 实验导致缓存碎片化</span></span>
<span class="line"><span>   2 个实验 → 4 个缓存版本</span></span>
<span class="line"><span>   3 个实验 → 8 个缓存版本</span></span>
<span class="line"><span>   </span></span>
<span class="line"><span>优化：</span></span>
<span class="line"><span>   - 合理控制实验数量</span></span>
<span class="line"><span>   - 及时下线过期实验</span></span>
<span class="line"><span>   - 使用 Cookie 缓存 AB 组</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>3. 数据请求优化</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>- 使用生命周期缓存避免重复请求</span></span>
<span class="line"><span>- 并行请求而非串行</span></span>
<span class="line"><span>- 服务端请求直连内网，更快</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><hr><h2 id="🔗-相关资源" tabindex="-1">🔗 相关资源 <a class="header-anchor" href="#🔗-相关资源" aria-label="Permalink to &quot;🔗 相关资源&quot;">​</a></h2><h3 id="官方文档" tabindex="-1">官方文档 <a class="header-anchor" href="#官方文档" aria-label="Permalink to &quot;官方文档&quot;">​</a></h3><ul><li><a href="https://vuejs.org/guide/scaling-up/ssr.html" target="_blank" rel="noreferrer">Vue SSR Guide</a></li><li><a href="https://react.dev/reference/react/use-server" target="_blank" rel="noreferrer">React Server Components</a></li><li><a href="https://vitejs.dev/guide/ssr.html" target="_blank" rel="noreferrer">Vite SSR</a></li></ul><h3 id="内部资源" tabindex="-1">内部资源 <a class="header-anchor" href="#内部资源" aria-label="Permalink to &quot;内部资源&quot;">​</a></h3><ul><li>Meta SSR 框架文档</li><li>@web-widget/helpers API 文档</li><li>King BFF 接入文档</li></ul><h3 id="相关-rfc" tabindex="-1">相关 RFC <a class="header-anchor" href="#相关-rfc" aria-label="Permalink to &quot;相关 RFC&quot;">​</a></h3><ul><li>RFC 10: 实施 HTTP 缓存策略加速站点速度</li><li>RFC 13: 实施 CDN 加速网站访问</li><li>RFC 15/20: Importmap 生成工具 WPM2/WPM3</li></ul><hr><h2 id="💡-贡献指南" tabindex="-1">💡 贡献指南 <a class="header-anchor" href="#💡-贡献指南" aria-label="Permalink to &quot;💡 贡献指南&quot;">​</a></h2><p>如果你发现文档有误或需要补充：</p><ol><li>在 Confluence 原文档提出修改建议</li><li>联系前端基建团队更新</li><li>定期同步最新版本到本地</li></ol><hr><h2 id="❓-faq" tabindex="-1">❓ FAQ <a class="header-anchor" href="#❓-faq" aria-label="Permalink to &quot;❓ FAQ&quot;">​</a></h2><h3 id="q1-什么时候应该使用-ssr" tabindex="-1">Q1：什么时候应该使用 SSR？ <a class="header-anchor" href="#q1-什么时候应该使用-ssr" aria-label="Permalink to &quot;Q1：什么时候应该使用 SSR？&quot;">​</a></h3><p><strong>适合 SSR</strong>：</p><ul><li>✅ 需要 SEO（首页、详情页、落地页）</li><li>✅ 首屏性能要求高</li><li>✅ 用户体验优先</li></ul><p><strong>不适合 SSR</strong>：</p><ul><li>❌ 纯后台管理系统</li><li>❌ 高度交互的应用（如编辑器）</li><li>❌ 实时性要求极高的应用</li></ul><h3 id="q2-ssr-和-csr-可以混合使用吗" tabindex="-1">Q2：SSR 和 CSR 可以混合使用吗？ <a class="header-anchor" href="#q2-ssr-和-csr-可以混合使用吗" aria-label="Permalink to &quot;Q2：SSR 和 CSR 可以混合使用吗？&quot;">​</a></h3><p><strong>可以！</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>整体页面：SSR（首屏快、SEO 友好）</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>部分组件：CSR（复杂交互、实时数据）</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>使用 <code>&lt;ClientOnly&gt;</code> 组件包裹纯客户端组件。</p><h3 id="q3-如何调试-ssr-问题" tabindex="-1">Q3：如何调试 SSR 问题？ <a class="header-anchor" href="#q3-如何调试-ssr-问题" aria-label="Permalink to &quot;Q3：如何调试 SSR 问题？&quot;">​</a></h3><p><strong>工具</strong>：</p><ul><li>服务端：Node.js Debugger</li><li>客户端：Chrome DevTools</li><li>网络：Charles / Fiddler</li><li>性能：Lighthouse</li></ul><p><strong>技巧</strong>：</p><ul><li>对比服务端和客户端的渲染结果</li><li>检查生命周期缓存是否正确传递</li><li>使用 <code>console.log</code> 区分运行环境</li></ul><h3 id="q4-ssr-的性能瓶颈在哪里" tabindex="-1">Q4：SSR 的性能瓶颈在哪里？ <a class="header-anchor" href="#q4-ssr-的性能瓶颈在哪里" aria-label="Permalink to &quot;Q4：SSR 的性能瓶颈在哪里？&quot;">​</a></h3><p><strong>主要瓶颈</strong>：</p><ol><li><p><strong>服务端渲染耗时</strong></p><ul><li>解决：缓存、代码分割、按需渲染</li></ul></li><li><p><strong>数据请求耗时</strong></p><ul><li>解决：并行请求、Redis 缓存、内网直连</li></ul></li><li><p><strong>水合耗时</strong></p><ul><li>解决：减少 JS 体积、延迟非关键脚本</li></ul></li><li><p><strong>缓存命中率低</strong></p><ul><li>解决：优化 Cache Key 策略、控制实验数量</li></ul></li></ol><hr><h2 id="📝-文档维护" tabindex="-1">📝 文档维护 <a class="header-anchor" href="#📝-文档维护" aria-label="Permalink to &quot;📝 文档维护&quot;">​</a></h2><p><strong>维护团队</strong>：前端基建团队<br><strong>整理日期</strong>：2025-01-25<br><strong>文档版本</strong>：v1.0</p><p><strong>更新记录</strong>：</p><ul><li>2025-01-25：初始版本，整合 13 篇 SSR 相关文档</li></ul><hr><p><strong>Happy Coding with SSR! 🚀</strong></p>`,157)]))}const u=a(i,[["render",p]]);export{b as __pageData,u as default};
