import{_ as i,c as a,o as e,a8 as t}from"./chunks/framework.B1-gFi6y.js";const _=JSON.parse('{"title":"面向对象","description":"","frontmatter":{},"headers":[],"relativePath":"softExame/面向对象.md","filePath":"softExame/面向对象.md","lastUpdated":1746693701000}'),o={name:"softExame/面向对象.md"};function r(s,l,n,h,d,c){return e(),a("div",null,l[0]||(l[0]=[t('<h1 id="面向对象" tabindex="-1">面向对象 <a class="header-anchor" href="#面向对象" aria-label="Permalink to &quot;面向对象&quot;">​</a></h1><h2 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h2><ol><li>对象</li><li>类</li><li>继承</li><li>多态</li><li>封装</li><li>抽象</li><li>接口</li></ol><h2 id="设计原则" tabindex="-1">设计原则 <a class="header-anchor" href="#设计原则" aria-label="Permalink to &quot;设计原则&quot;">​</a></h2><ol><li>单一职责原则：一个类只负责一个职责</li><li>开闭原则：对扩展开放，对修改关闭</li><li>里氏替换原则：子类可以替换父类</li><li>依赖倒置原则：高层模块不应该依赖低层模块，二者都应该依赖其抽象。要依赖抽象，不要依赖具体类，针对接口编程，不要针对实现编程</li><li>接口隔离原则：客户端不应该依赖它不需要的接口，使用多个专门的接口比使用单一的总接口要好</li><li>迪米特法则：一个类应该对其他类有最少的了解</li><li>组合重用原则：尽量使用组合而不是继承来实现复用，组合优于继承</li></ol><h2 id="uml" tabindex="-1">UML <a class="header-anchor" href="#uml" aria-label="Permalink to &quot;UML&quot;">​</a></h2><ol><li>类图</li><li>对象图</li><li>用例图</li><li>时序图</li><li>协作图</li><li>状态图</li><li>活动图</li></ol><h2 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h2><ol><li>创建型模式</li></ol><p>创建对象的方式</p><ul><li>单例模式：一个类只有一个实例，并提供一个访问它的全局访问点</li><li>工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到子类</li><li>抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</li><li>建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</li><li>原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</li></ul><ol start="2"><li>结构型模式</li></ol><p>定义：</p><ul><li>适配器模式：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</li><li>桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立地变化</li><li>装饰模式：动态地给一个对象添加一些额外的职责</li><li>组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性</li><li>外观模式：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</li><li>享元模式：运用共享技术有效地支持大量细粒度的对象</li><li>代理模式：为其他对象提供一种代理以控制对这个对象的访问</li></ul><ol start="3"><li>行为型模式</li></ol><p>定义：</p><ul><li>观察者模式：定义对象间的一对多依赖关系，当一个对象改变状态时，所有依赖它的对象都会收到通知并自动更新</li><li>中介者模式：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</li><li>策略模式：定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换</li><li>模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</li><li>命令模式：将请求封装成对象，从而使您可以用不同的请求、队列或日志来参数化其他对象。命令模式也支持可撤销的操作</li><li>责任链模式：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止</li><li>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类</li><li>迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示</li><li>访问者模式：表示一个作用于某对象结构中的各元素的操作。它使您可以在不改变各元素的类的前提下定义作用于这些元素的新操作</li></ul><h2 id="设计模式分类" tabindex="-1">设计模式分类 <a class="header-anchor" href="#设计模式分类" aria-label="Permalink to &quot;设计模式分类&quot;">​</a></h2>',18)]))}const m=i(o,[["render",r]]);export{_ as __pageData,m as default};
