import{_ as s,c as i,o as a,aa as n}from"./chunks/framework.CAVwB9kQ.js";const t="/Lyc-notes/assets/%E6%9C%89%E5%90%91%E5%9B%BE_%E6%97%A0%E5%90%91%E5%9B%BE.BkOXb7UF.png",l="/Lyc-notes/assets/%E6%97%A0%E5%90%91%E5%9B%BE%E5%8F%8A%E5%85%B6%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.BH37dORa.png",p="/Lyc-notes/assets/%E7%94%9F%E6%88%90%E6%A0%91.DuaAX9AF.png",e="/Lyc-notes/assets/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.D6HWnqP9.png",h="/Lyc-notes/assets/%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.3sVNj9Im.png",r="/Lyc-notes/assets/%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AE%9E%E4%BE%8B.B3Uf922i.png",k="/Lyc-notes/assets/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.N1PJtg5i.png",E="/Lyc-notes/assets/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8.7j6kjCky.png",g="/Lyc-notes/assets/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.Bm9ZuMDM.png",o="/Lyc-notes/assets/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8.lEik6BzA.png",d="/Lyc-notes/assets/%E5%9B%BE%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.lzpMi3kT.png",c="/Lyc-notes/assets/BFS%E5%AE%9E%E4%BE%8B.GNxSSfnC.png",y="/Lyc-notes/assets/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%94%9F%E6%88%90%E6%A0%91.DReZc7IQ.png",A="/Lyc-notes/assets/DFS%E7%94%9F%E6%88%90%E6%A3%AE%E6%9E%97.3HAPKMSn.png",b="/Lyc-notes/assets/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.B4Kg69QC.png",F="/Lyc-notes/assets/prim%E7%AE%97%E6%B3%95%E6%9E%84%E9%80%A0.DKEs-PnM.png",u="/Lyc-notes/assets/Kruskal%E6%9E%84%E9%80%A0%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.VWOjzGSL.png",D="/Lyc-notes/assets/Dijkstra.D5f2pqNw.png",m="/Lyc-notes/assets/floyd.B-pSWrdo.png",B="/Lyc-notes/assets/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%80%BB%E7%BB%93.C58VYBJf.png",T=JSON.parse('{"title":"第 6 章 图","description":"","frontmatter":{},"headers":[],"relativePath":"dataStructure/chapter6.md","filePath":"dataStructure/chapter6.md","lastUpdated":1718793804000}'),v={name:"dataStructure/chapter6.md"},_=n('<h1 id="第-6-章-图" tabindex="-1">第 6 章 图 <a class="header-anchor" href="#第-6-章-图" aria-label="Permalink to &quot;第 6 章 图&quot;">​</a></h1><h2 id="图的基本概念" tabindex="-1">图的基本概念 <a class="header-anchor" href="#图的基本概念" aria-label="Permalink to &quot;图的基本概念&quot;">​</a></h2><h4 id="图的定义" tabindex="-1">图的定义 <a class="header-anchor" href="#图的定义" aria-label="Permalink to &quot;图的定义&quot;">​</a></h4><p>图 G 由项点集和边集 E 组成，记为 G=(V,E)</p><p>线性表可以是空表，树可以是空树，但图不可以是空图。也就是说，图中不能一个顶点 也没有，图的顶点集 V 一定非空，但边集 E 可以为空，此时图中只有顶点而没有边。</p><ol><li><p><strong>有向图</strong></p></li><li><p><strong>无向图</strong></p></li></ol><p><img src="'+t+'" alt="alt text"></p><ol start="3"><li><strong>简单图、多重图</strong></li></ol><p>一个图 G 若满足: 1️⃣ 不存在重复边; 2️⃣ 不存在顶点到自身的边，则称图 G 为简单图。图 6. 1 中 G1 和 G2 均内简单图</p><ol start="4"><li><strong>完全图（简单完全图）</strong></li></ol><p>对于无向图，|E|的取值范围为 0 到 n(n-1)/2，<strong>有 n(n-1)/2 条边的无向图称完全图</strong>，<strong>在完全图中任意两个项点之间都存在边</strong>。对于有向图，|E|的取值范围为 0 到 n(n-1)，<strong>有 n(n-1)条弧的有向图称为有向完全图</strong>，在有向完全图中任意两个顶点之间都存在方向相反的两条弧。图 6.1 中 G2 为无向完全图，而 G3 为有向完全图。</p><ol start="5"><li><p><strong>子图</strong></p><p>G3 为 G1 的子图</p></li><li><p><strong>连通、连通图和连通分量</strong></p></li></ol><p>在<strong>无向图</strong>中，若从顶点 v 到顶点 w 有路径存在，则称 v 和 w 是连通的。若图 G 中任意两个顶点都是连通的 ， 则称图 G 连通图，否则称非连通图。无向图中的极大连通子图称连通分量，在图 6.2(a)中，图 G4 有 3 个连通分量如图 6.2(b)所示。假设一个图有 n 个顶点，若边数小于 n-1，则此图必是非连通图;思考，若图是非连通图，则最多可以有多少条边?</p><p><img src="'+l+'" alt="alt text"></p><ol start="7"><li><strong>强连通图、强连通分量</strong></li></ol><p>在<strong>有向图</strong>中，若有一对顶点 w 和 w，从 v 到 w 和从 w 到 v 之间都有路径，则称这两个顶点是<strong>强连通</strong>的。<strong>若图中任意一对项点都是强连通的，则称此图为强连通图</strong>。<strong>有向图中的极大强连通子图称为有向图的强连通分量</strong>，图 G，的强连通分量如图 6.3 所示。思考，假设一个有向图有 n 个项点，若是强连通图，则最少需要有多少条边</p><ol start="8"><li><strong>生成树、生成森林</strong></li></ol><p>连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为 n，则它的生成树含有 n-1 条边。包含图中全部顶点的极小连通子图，只有生成树满足这个极小条件，对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。在非连通图中，连通分量的生成树构成了非连通图的生成森林。图 G 的一个生成树如图 6.4 所示。</p><p><img src="'+p+'" alt="alt text"></p><blockquote><p>区分极大连通子图和极小连通子图。极大连通子图要求子图必须连通，而且包含尽可能 多的顶点和边;极小连通子图是既要保持子图连通又要使得边数最少的子图</p></blockquote><ol start="9"><li><strong>顶点的度、入度和出度</strong></li></ol><p>在<strong>无向图</strong>中，顶点 v 的度是<strong>指依附于项点的边的条数</strong>，记为 TD(v)。在图 6.1(b)中，每个项点的度均为 3。<strong>无向图的全部顶点的度之和等于边数的 2 倍</strong>，因为每条边和两个项点相关联。 在<strong>有向图</strong>中，顶点 v 的度分为入度和出度，<strong>入度是以顶点终点的有向边的数目</strong>，记为 ID(1):而<strong>出度是以顶点，为起点的有向边的数目</strong>，记为 OD(v)。在图 6.1(a)中，顶点 2 的出度为 2、入度为 1。顶点 v 的度等于其<strong>入度与出度之和</strong>，即 TD(v)=ID(v)+OD(v)。<strong>有向图的全部顶点的入度之和与出度之和相等，并且等于边数，这是因为每条有向边都有一个起点和终点</strong>。</p><ol start="10"><li><strong>边的权和网</strong></li></ol><p>在一个图中，每条边都可以标上具有某种含义的数值，<strong>该数值称为该边的权值</strong>。这种边上 带有权值的图称为<strong>带权图，也称网</strong>。</p><ol start="11"><li><strong>稠密图、稀疏图</strong></li></ol><p>边数很少的图称为稀疏图，反之称为稠密图。稀疏和稠密本身是模糊的概念，稀疏图和稠 密图常常是相对而言的。一般当图 G 满足 E&lt;|7log|V 时，可以将 G 视为稀疏图。</p><ol start="12"><li><strong>路径、路径长度和回路</strong></li></ol><p>顶点 v，到顶点 1，之间的一条路径是指顶点序列 1pVV。，当然关联的边也可理解为路径的构成要素。路径上的边的数目称内<strong>路径长度</strong>。<strong>第一个顶点和最后一个项点相同的路径称为回路或环</strong>。若一个图有 n 个项点，且有大于 n-1 条边，则此图一定有环。</p><ol start="13"><li><strong>简单路径、简单回路</strong></li></ol><p>在路径序列中，顶点不重复出现的路径称为简单路径。除第一个顶点和最后一个顶点外， 其余顶点不重复出现的回路称为简单回路。</p><ol start="14"><li><strong>距离</strong></li></ol><p>从顶点 w 出发到顶点 v 的最短路径若存在，则此路径的长度称为从 u 到 v 的距离。若从 w 到 v 根本不存在路径，则记该距离为无穷(∞)</p><ol start="16"><li><strong>有向树</strong></li></ol><p>一个项点的入度为 0、其余顶点的入度均为 1 的有向图，称为有向树。</p><h2 id="图的存储及基本操作" tabindex="-1">图的存储及基本操作 <a class="header-anchor" href="#图的存储及基本操作" aria-label="Permalink to &quot;图的存储及基本操作&quot;">​</a></h2><h4 id="邻接矩阵法" tabindex="-1">邻接矩阵法 <a class="header-anchor" href="#邻接矩阵法" aria-label="Permalink to &quot;邻接矩阵法&quot;">​</a></h4><p>所谓邻接矩阵存储，是指用<strong>一个一维数组存储图中顶点的信息</strong>，<strong>用一个二维数组存储图中边的信息(即各顶点之间的邻接关系)</strong>，存储顶点之间邻接关系的二维数组称为邻接矩阵。</p><p>对带权图而言，若顶点 Vi 和 Vj 之间有边相连，则邻接矩阵中对应项存放着该边对应的权值，若顶点 Vi 和 Vj 不相连，则通常用 0 或 ∞ 来代表这两个项点之间不存在边。</p><p><img src="'+e+`" alt="alt text"></p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#deinfen MaxVertexNum </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //  顶点数目的最大值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> VertexType;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 顶点对应的数据类型</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EdgeType;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 边对应的数据类型</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   VertexType </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[MaxVertexNum];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 顶点表</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   EdgeType </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[MaxVertexNum][MaxVertexNum];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 邻接矩阵、边表</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vexnum,arcnum;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 图的当前顶点数和边数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}MGraph;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>1️⃣ 在简单应用中，可直接用二维数组作为图的邻接矩阵(顶点信息等均可省略)。 2️⃣ 当邻接矩阵的元素仅表示相应边是否存在时，EdgeType 可用值为 0 和 1 的枚举类型。 3️⃣ 无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。 4️⃣ 邻接矩阵表示法的空间复杂度为 O(n-)，其中 n 为图的顶点数|M。</p></blockquote><blockquote><p>邻接矩阵的遍历的时间复杂度</p></blockquote><p>图的邻接矩阵存储表示法具有以下特点:</p><p>1️⃣ <strong>无向图的邻接矩阵一定是一个对称矩阵(并且唯一)</strong>。因此，在实际存储邻接矩阵时只需存储上(或下)三角矩阵的元素。 2️⃣ 对于无向图，邻接矩阵的第 i 行(或第 i 列)非零元素(或非 ∞ 元素)的个数正好是顶点 i 的度 TD(v)。 3️⃣ 对于有向图，邻接矩阵的第 i 行非零元素(或非 ∞ 元素)的个数正好是顶点 i 的出度 OD(v)；第 i 列非零元素(或非 ∞ 元素)的个数正好是顶点 i 的入度 ID(Vi)； 4️⃣ 用邻接矩阵存储图，很容易确定图中任意两个项点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。 5️⃣ 稠密图(即边数较多的图)适合采用邻接矩阵的存储表示。 6️⃣ 设图 G 的邻接矩阵为 A，**A^n 的元素 A^n[j][j] 等于由顶点 i 到顶点 j 的长度为 n 的路径的数目 **</p><h4 id="邻接表法" tabindex="-1">邻接表法 <a class="header-anchor" href="#邻接表法" aria-label="Permalink to &quot;邻接表法&quot;">​</a></h4><p>所谓邻接表，是指对图 G 中的每个顶点 Vi 建立一个单链表，第 i 个单链表中的结点表示依附于顶点 Vi 的边(对于有向图则是以顶点 Vi 为尾的弧)，这个单链表就称为顶点 Vi 的边表(对于有向图则称出边表)。边表的头指针和顶点的数据信息采用顺序存储，称为顶点表，所以在邻接表中存在两种结点:顶点表结点和边表结点，如图 6.6 所示。</p><p><img src="`+h+'" alt="alt text"><img src="'+r+`" alt="alt text"></p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MaxVertexNum</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //图中顶点数目的最大值</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ArcNode {.</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 边表结点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> adjvex;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">             // 该弧指向的顶点的位置</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ArcNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nextarc</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 指向下一条的指针</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // InfoType info;       // 网的边权值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}ArcNode</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> VNode{</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 顶点表结点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   VertexType data;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 顶点信息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   ArcNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">firstarc;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 指向第一条依附该顶点的弧的指针</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}VNode, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">AdjList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[MaxVertexNum]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   AdjList vertices;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 邻接表</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vexnum , arcnum;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 图的顶点数和弧数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} ALGraph</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">              //ALGr aph 是以邻接表存储的图类型</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><strong>特点：</strong></p><ul><li>若 G 为无向图，则所需的存储空间为 <strong>O(|V|+2|E|)</strong>；若 G 为有向图，则所需的存储空间为 <strong>O(|V|+|E|)</strong>。前者的倍数 2 是因为在无向图中，每条边在邻接表中出现了两次。</li><li>对于<strong>稀疏图(即边数较少的图)</strong>，采用邻接表表示将极大地节省存储空间。</li><li>在邻接表中，给定一个顶点，<strong>能很容易地找出它的所有邻边</strong>，因为只需要读取它的邻接表。在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为 O(n)。但是，若要确定给定的两个顶点间是否存在边，则在邻接矩阵中可以立刻查到，而在邻接表中则需要在 相应结点对应的边表中查找另一结点，效率较低。</li><li>在无向图的邻接表中，求某个项点的度只需计算其邻接表中的边表结点个数。在有向图的邻接表中，求某个顶点的出度只需计算其邻接表中的边表结点个数;但求某个顶点 x 的入度则需遍历全部的邻接表，统计邻接(adjvex )域为 × 的边表结点个数。</li><li>图的邻接表表示并不唯一，因为在每个顶点对应的边表中，各边结点的链接次序可以是任意的，它取决于建立邻接表的算法及边的输入次序。</li></ul><h4 id="十字链表" tabindex="-1">十字链表 <a class="header-anchor" href="#十字链表" aria-label="Permalink to &quot;十字链表&quot;">​</a></h4><p>为了解决有向图求入度需要遍历整个邻接表问题，引出了十字链表。十字链表是有向图的一种链式存储结构。在十字链表中，有向图的每条弧用一个结点(弧结点)来表示，每个顶点也用一个结点 (顶点结点)来表示。两种结点的结构如下所示。</p><p><img src="`+k+'" alt="alt text"> 弧结点中有 5 个域: <code>tailvex</code>和<code>headvex</code>两个域分别指示<strong>弧尾</strong>和<strong>弧头</strong>这两个顶点的编号; 头链域 <code>hlink</code>指向<strong>弧头相同</strong>的下一个弧结点; 尾链域<code>tlink</code>指向<strong>弧尾相同</strong>的下一个弧结点; <code>info</code> 域存放该弧的相关信息。 这样，<strong>弧头相同的弧在同一个链表上</strong>，<strong>弧尾相同的弧也在同 一个链表上</strong>。</p><p>顶点结点中有 3 个域： <code>data </code>域存放该顶点的数据信息，如顶点名称; <code>firstin</code>域指向以该顶点为弧头的第一个弧结点; <code>firstout</code>域指向以该顶点为弧尾的第一个弧结点。</p><p><img src="'+E+'" alt="alt text"></p><p>在十字链表中，既容易找到 Vi 为尾的弧，也容易找到 Vi 为头的弧，因而容易求得顶点的出度和入度。<strong>图的十字链表表示是不唯一的，但一个十字链表表示唯一确定一个图</strong>。</p><h4 id="邻接多重表" tabindex="-1">邻接多重表 <a class="header-anchor" href="#邻接多重表" aria-label="Permalink to &quot;邻接多重表&quot;">​</a></h4><p>邻接多重表是<strong>无向图</strong>的一种链式存储结构。在邻接表中，容易求得顶点和边的各种信息， <strong>但在邻接表中求两个项点之间是否存在边而对边执行删除等操作时</strong>，需要分别在<strong>两个顶点的边表中遍历</strong>，效率较低。与十字链表类似，在邻接多重表中，每条边用一个结点表示，</p><p><img src="'+g+'" alt="alt text"></p><p>在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，因为每条边依附于两个顶点，所以每个边结点同时链接在两个链表中。对无向图而言，其邻接多重表和邻接表的差别仅在于，同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。</p><p><img src="'+o+'" alt="alt text"></p><p>图的四种存储方式总结 <img src="'+d+`" alt="alt text"></p><h2 id="图的遍历" tabindex="-1">图的遍历 <a class="header-anchor" href="#图的遍历" aria-label="Permalink to &quot;图的遍历&quot;">​</a></h2><p>图的遍历是指从图中的某一项点出发，按照某种搜索方法沿着图中的边对图中的所有项点访问一次，且仅访问一次。 注意到树是一种特殊的图，所以树的遍历实际上也可视为一种特殊的图的遍历。图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。 图的遍历比树的遍历要复杂得多，因图的任意一个顶点都可能和其余的顶点相邻接，所以在访间某个顶点后，可能沿着某条路径搜索又回到该顶点。为避免同一顶点被访问多次，在遍历图的过程中，必须记下每个已访问过的项点，为此可以设一个辅助数组 visited[]来标记顶点是否被访问过。图的遍历算法主要有两种:<strong>广度优先搜索和深度优先搜索</strong>。</p><h4 id="广度优先搜索-bfs" tabindex="-1">广度优先搜索（BFS） <a class="header-anchor" href="#广度优先搜索-bfs" aria-label="Permalink to &quot;广度优先搜索（BFS）&quot;">​</a></h4><p>广度优先搜索(Breadth-First-Search, BFS)类似于二叉树的层序遍历算法。 基本思想： 1️⃣ 首先访问起始顶点 v，接着由 v 出发，依次访问 v 的各个未访问过的邻接顶点 W1，W2，...，Wi， 2️⃣ 然后依次访问 W1，W2，...，Wi 的所有未被访问过的邻接顶点 3️⃣ 再从这些访问过的项点出发，访问它们所有未被访问过的邻接顶点，直至图中所有项点都被访问过为止。 4️⃣ 若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的项点作为始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>广度优先搜索是一种分层的查找过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有往回退的情况，因此它不是一个递归的算法。为了实现逐层的访问，算法必须借助一个辅助队列，以记忆正在访问的顶点的下一层顶点。</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> visited</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[MAX_VERTEX_NUM];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 访问标记数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BFSTraverse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Graph </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">G</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 对图G进行广度优先遍历</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">G.vernum;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">      visited</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> FALSE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 访问标记数组初始话</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   InitQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Q);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                   // 初始话辅助队列Q</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">G.vexnum ; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 从0号顶点开始遍历</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">visited</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i]){</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">             // 对每一个连通分量调用一下BFS</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">         BFS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(G,i)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//用邻接表实现广度优先搜索的算法如下:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BFS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ALGraph </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">G</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   visit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                       // 访问顶点i</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">   visited</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TRUE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">              // 对i做已访问标记</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   EnQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Q,i);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                   // 顶点i入队</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IsEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Q)){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      DeQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Q,v);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                 // 队首顶点v出队</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">G.vertices[v].firstarc;p;p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p-&gt;nextarc){</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 检测v的所有邻接点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         w </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p-&gt;adjvex;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">visited</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[w] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> FALSE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            visit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(w);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">               // w为v的尚未访问的邻接点，访问w</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">            visited</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[w] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TRUE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 对w做已访问标记</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            EnQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Q,w)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 顶点w入队</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>用<strong>邻接矩阵</strong>实现广度优先搜索的算法如下:</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BFS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MGraph </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">G</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    visit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i) ;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//访问初始顶点i</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    visited</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TRUE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // //对i做已访问标记</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    EnQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Q, i) :</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //顶点主入队</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IsEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Q)) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       DeQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Q, v) ;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 队首顶点 出队</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (w</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;w</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">G.vexnum; w</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//检测 的所有邻接点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">           if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">visited</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[w]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">FAISE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">G.edge[v][w]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">               visit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(w);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // w为v的尚未访问的邻接点，访问w</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">               visited</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[w]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TRUE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">对w做已访问标记</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">               EnQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Q,w);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 顶点w入队</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>辅助数组 visited[]标志顶点是否被访问过，其初始状态为 FALSE。在图的遍历过程中，一旦某个顶点 v;被访问，就立即置 visited[i]TRUE，防止它被多次访问。</p><p><img src="`+c+'" alt="alt text"></p><p>图的广度优先搜索的过程与二叉树的层序遍历是完全一致的，图的广度优先搜索遍历算法是二叉树的层次遍历算法的扩展</p><ol><li><p><strong>BFS 性能分析</strong> 无论是邻接表还是邻接矩阵的存储方式，BFS 算法都需要借助一个辅助队列 Q，n 个顶点均需入队一次，在最坏的情况下，空间复杂度为 O(V)。 采用<strong>邻接表</strong>存储时，每个顶点均需搜索(或入队)一次，时间复杂度为 O(V)，在搜索每个顶点的邻接点时，每条边至少访问一次，时间复杂度为 O(E)，总的时间复杂度为 O(V+E)。采用<strong>邻接矩阵</strong>存储时，查找每个项点的邻接点所需的时间为 O(V)，总时间复杂度为 O(V^2)。</p></li><li><p><strong>BFS 求解单源最短路径问题</strong></p></li></ol><p>使用 BFS，我们可以求解一个满足上述定义的韭带权图的单源最短路径问题，这是由广度优先搜索总是按照距离由近到远来遍历图中每个项点的性质决定的。</p><ol start="3"><li><strong>广度优先生成树</strong></li></ol><p>在广度遍历的过程中，我们可以得到一棵遍历树，称为广度优先生成树。 需要注意的是，<strong>同一个图的邻接矩阵存储表示是唯一的，所以其广度优先生成树也是唯一的， 但因为邻接表存储表示不唯一，所以其广度优先生成树也是不唯一的</strong>。</p><p><img src="'+y+'" alt="alt text"></p><h4 id="深度优先搜索" tabindex="-1">深度优先搜索 <a class="header-anchor" href="#深度优先搜索" aria-label="Permalink to &quot;深度优先搜索&quot;">​</a></h4><p>与广度优先搜索不同，<strong>深度优先搜索 (Depth-First-Search, DFS)类似于树的先序遍历</strong>。</p><p>基本思想： 首先访问图中某一起始顶点 v，然后由 v 出发，访问与 v 邻接且未被访 问的任意一个顶点 w1，再访问与 w，邻接且未被访问的任意一个顶点 w2••• 重复上述过程。当不能再继续向下访问时，依次退回到最近被访间的顶点，若它还有邻接顶点未被访间过，则从该点开始继续上述搜索过程，直至图中所有顶点均被访问过为止。</p><p>深度优先搜索的过程:首先访问 a，并置 a 访问标记;然后访问与 a 邻接且未被访问的顶点 b，置 b 访问标记;然后访问与 b 邻接且未被访问的顶点 d，置 d 访问标记。此时 d 已没有未被访问过的邻接点，所以返回上一个访问的项点 b，访问与其邻接且未被访问的项点 e，置 e 访问标记，以此类推，直至图中所有项点都被访问一次。遍历结果为 abdehcg。</p><blockquote><p>图的邻接矩阵表示是唯 一的，但对邻接表来说，若边的输入次序不同，则生成的邻接表 也不同。因此，对同样一个图，基于邻接矩阵的遍历得到的 DFS 序列和 BFS 序列是唯一的， 基于邻接表的遍历得到的 DFS 序列和 BFS 序列是不唯一的。</p></blockquote><ol><li><strong>DFS 的性能分析</strong> DFS 算法是一个递归算法，需要借助一个递归工作栈，所以其空间复杂度为 O(IM)。 采用邻接矩阵存储时，总时间复杂度为 <code>O(V^2)</code>。 采用邻接表存储时，总的时间复杂度为 <code>O(V+E)</code>。</li><li><strong>深度优先的生成树和生成森林</strong><img src="'+A+'" alt="alt text"></li></ol><h2 id="图-的遍历与图的连通性" tabindex="-1">图 的遍历与图的连通性 <a class="header-anchor" href="#图-的遍历与图的连通性" aria-label="Permalink to &quot;图 的遍历与图的连通性&quot;">​</a></h2><p>图的遍历算法可以用来判断图的连通性。对于无向图来说，若无向图是连通的，则从任意一个结点出发，仅需一次遍历就能够访问图中的所有项点;若无向图是非连通的，则从某一个项点出发，一次遍历只能访问到该项点所在连通分量的所有顶点，而对于图中其他连通分量的顶点，则无法通过这次遍历访问。对于有向图来说，若从初始顶点到图中的每个顶点都有路径，则能够访问到图中的所有顶点，否则不能访问到所有顶点。 因此，在<code>BFSTraverse()</code>或<code>DFSTraverse()</code>中添加了第二个 for 循环，再选取初始点，继续进行遍历，以防止一次无法遍历图的所有项点。对于无向图，上述两个函数调用 BFS(G,i)或 DFS(G,i)的次数等于该图的连通分量数;而对于有向图则不是这样，因为一个连通的有向图分为强连通的和非强连通的，它的连通子图也分为强连通分量和非强连通分量，非强连通分量一次调用 BFS(G,1)或 DES(G，i)无法访问到该连通分量的所有顶点。</p><h2 id="图的应用" tabindex="-1">图的应用 <a class="header-anchor" href="#图的应用" aria-label="Permalink to &quot;图的应用&quot;">​</a></h2><p>图的应用主要包括:最小生成 (代价)树、最短路径、拓扑排序 和关键路径。</p><h4 id="最小生成树" tabindex="-1">最小生成树 <a class="header-anchor" href="#最小生成树" aria-label="Permalink to &quot;最小生成树&quot;">​</a></h4><p>一个连通图的生成树包含图的所有项点，并且只含尽可能少的边。对于生成树来说，若砍去它的一条边，则会使生成树变成非连通图;若给它增加一条边，则会形成图中的一条回路。</p><p>对于一个带权连通无向图 G，生成树不同，每棵树的权(即树中所有边上的权值之和)也可能不同。权值之和最小的那棵生成树称为 G 的最小生成树(Minimum-Spanning-Tree,MST)。</p><p>性质： 1️⃣ 若图 G 中存在权值相同的边，则 G 的最小生成树可能不唯一，即最小生成树的树形不唯一。当图 G 中的各边权值互不相等时，G 的最小生成树是唯一的;若无向连通图 G 的边数比顶点数少 1，即 G 本身是一棵树时，则 G 的最小生成树就是它本身。 2️⃣ 虽然最小生成树不唯一，但其对应的边的权值之和总是唯 一的，而且是最小的。 3️⃣ 最小生成树的边数为顶点数減 1。</p><blockquote><p>最小生成树中某顶点到其他顶点是否具有最短路径的分析 <img src="'+b+'" alt="alt text"></p></blockquote><p>基于该性质的最小生成树算法主要有<code>Prim</code> 算法和<code>Kruskal</code>算法，它们都基于贪心算法的策略</p><ol><li><strong>Prim 算法</strong></li></ol><p><img src="'+F+'" alt="alt text"> 时间复杂度为 O(V^2),不依赖于 E，因此它适用于求解边稠密的图的最小生成树。</p><ol start="2"><li><strong>Kruskal 算法</strong> 与 Prim 算法从顶点开始扩展最小生成树不同，Kruskal 算法是一种<strong>按权值的递增次序选择合适的边来构造最小生成树的方法</strong>。</li></ol><p><img src="'+u+'" alt="alt text"></p><p>在<code>Kruskal</code>算法中，最坏情况需要对|E|条边各扫描一次。通常采用堆(见第 7 章)来存放边的集合，每次选择最小权值的边需要 O(log2E)的时间;每次使用并查集来快速判断两个顶点是 否属于一个集合所需的时间为 O(aV)，a(V)的增长极其缓慢，可视为常数。算法的总时间复 杂度为 O(Vlog2E)，不依赖于|V|，因此 Kruskal 算法适合于<strong>边稀疏而顶点较多的图</strong>。</p><h4 id="最短路径" tabindex="-1">最短路径 <a class="header-anchor" href="#最短路径" aria-label="Permalink to &quot;最短路径&quot;">​</a></h4><p>6.3 节所述的广度优先搜索查找最短路径只是对无权图而言的。当图是带权图时，把从一个顶点 vo 到图中其余任意一个顶点，的一条路径所经过边上的权值之和，定义为该路径的<strong>带权路径长度</strong>，<strong>把带权路径长度最短的那条路径(可能不止一条)称为最短路径</strong>。 求解最短路径的算法通常都依赖于一种性质，即两点之间的最短路径也包含了路径上其他项点间的最短路径。带权有向图 G 的最短路径问题一般可分两类:一是<strong>单源最短路径</strong>，即求图中某一顶点到其他各顶点的最短路径，可通过经典的<code> Dijkstra(迪杰斯特拉)</code>算法求解;二是求<strong>每对顶点间的最短路径</strong>，可通过 <code>Floyd(弗洛伊德)</code>算法来求解。</p><ol><li><strong>Dijkstra 算法求单源最短路径问题</strong><code>Dijkstra</code> 算法设置一个集合 S 记录已求得的最短路径的顶点，初始时把源点 Vo 放入 S，集合 S 每并入一个新顶点 Vi，都要修改源点 Vo 到集合 V—S 中顶点当前的最短路径长度值 在构造的过程中还设置了三个辅助数组:</li></ol><ul><li><code>final[]</code>:标记各顶点是否已找到最短路径，即是否归入集合 S。</li><li><code>dist[]</code>:记录从源点 Vo 到其他各顶点当前的最短路径长度，它的初始值为:若从 Vo 到 Vi 有弧，则 <code>dist[i]</code>弧上的权值;否则置 <code>dist[i ]为∞</code>。</li><li><code>path[]</code>:<code>path[i]</code>表示从源点到顶点 Vi 之间的最短路径的前驱结点。在算法结束时，可根据其值追溯得到源点 Vo 到顶点 Vi 的最短路径。</li></ul><blockquote><p>Dijkstra 算法求解最短路径的实例 (2012、2014、2016、2021) <img src="'+D+'" alt="alt text"></p></blockquote><p>显然，<code>Dijkstra</code> 算法也是基于贪心策略的。 使用<strong>邻接矩阵</strong>表示时，时间复杂度为 O(V^2)。 使用带权的<strong>邻接表</strong>表示时，虽然修改 dist[]的时间可以减少，但由于在 dist[]中选择最小分量的时间不变，所以时间复杂度仍为 O(V^2);</p><p><strong>边上带有负权值时，Dijkstra 算法并不适用。</strong></p><ol start="2"><li><strong>Floyd 算法求各顶点之间最短路径问题</strong></li></ol><p>求所有顶点之间的最短路径问题描述如下:已知 一个各边权值均大于 0 的带权有向图，对任意两个顶点 Vi!=Vj，要求求出 Vi 与 Vj 之间的最短路径和最短路径长度。 <img src="'+m+'" alt="alt text"></p><p><strong>求最短路径的总结</strong><img src="'+B+'" alt="alt text"></p>',109),x=[_];function V(C,f,G,S,q,w){return a(),i("div",null,x)}const O=s(v,[["render",V]]);export{T as __pageData,O as default};
