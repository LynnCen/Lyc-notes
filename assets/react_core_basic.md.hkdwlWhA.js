import{_ as e}from"./chunks/core-packages.c2850581.FW-IKf5s.js";import{_ as r,a as o,b as t,c as a,d as c,e as i}from"./chunks/6.DljeWJxU.js";import{_ as l,c as n,o as d,aa as s}from"./chunks/framework.CAVwB9kQ.js";const R=JSON.parse('{"title":"核心概念","description":"","frontmatter":{},"headers":[],"relativePath":"react/core/basic.md","filePath":"react/core/basic.md","lastUpdated":1717939136000}'),p={name:"react/core/basic.md"},h=s('<h1 id="核心概念" tabindex="-1">核心概念 <a class="header-anchor" href="#核心概念" aria-label="Permalink to &quot;核心概念&quot;">​</a></h1><h2 id="核心包结构" tabindex="-1">核心包结构 <a class="header-anchor" href="#核心包结构" aria-label="Permalink to &quot;核心包结构&quot;">​</a></h2><ol><li><p><strong>react</strong></p><blockquote><p>react 基础包，提供创建 react 组件（<code>React.createElement</code>）、状态管理（<code>useState</code>）、生命周期（<code>useEffect</code>）等必要函数，开发过程中的使用的 api 主要都来自这个包。</p></blockquote></li><li><p><strong>react-dom</strong></p><blockquote><p>web 应用的<strong>渲染器</strong>，是 react 与 web 平台连接的桥梁(可以在浏览器和 nodejs 环境中使用)，将<code>react-reconciler</code>中的运行结果输出到 web 界面上，主要作用是将 React 组件转换为 DOM 节点，并渲染在浏览器上。在 React 18 中，更推荐使用的渲染 api 是 <code>createRoot.render</code>，在 concurrent 模式（并发模式）下性能更好。</p></blockquote></li><li><p><strong>react-reconciler</strong></p><blockquote><p>react 的核心包（<strong>调度构造器</strong>），通过实现协调算法（<code>diff 算法</code>）管理 react 应用状态的输入和结果的输出，构造 fiber 树， 将输入信号最终转换成输出信号传递给<strong>渲染器</strong>（<code>react-dom</code>）。主要功能作用：</p><ul><li>接受状态输入(<code>scheduleUpdateOnFiber</code>)，将 fiber 树生成逻辑封装到一个回调函数中(涉及 fiber 树形结构, fiber.updateQueue 队列, 调和算法等)</li><li>把此回调函数(<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>)送入<code>scheduler</code>进行调度</li><li>回调函数执行完成后获取到更新结果，交给<strong>渲染器</strong>（<code>react-dom</code>）渲染到页面上</li></ul></blockquote></li><li><p><strong>scheduler</strong></p><blockquote><p>调度机制的核心实现(<strong>调度器</strong>)，接收<strong>react-reconciler</strong>传入的回调函数任务，并管理这些任务的优先级和执行顺序。</p><ul><li>核心任务就是执行回调(回调函数由<code>react-reconciler</code>提供)</li><li>控制由<code>react-reconciler</code>送入的回调函数的执行时机, 在 concurrent 模式下可以实现任务分片, 实现可中断渲染(concurrent 模式下才有此特性)</li></ul></blockquote></li></ol><h2 id="架构分层" tabindex="-1">架构分层 <a class="header-anchor" href="#架构分层" aria-label="Permalink to &quot;架构分层&quot;">​</a></h2><p>可将 react 应用整体结构分为接口层（<code>api</code>）和内核层（<code>core</code>）</p><ol><li><p><strong>接口层（api）</strong> react 包对外暴露 api</p></li><li><p><strong>内核层</strong> 由三部分组成，调度器（<code>scheduler</code>），调度构造器（<code>react-reconciler</code>），渲染器（<code>react-dom</code>）</p></li></ol><p><strong>内核关系</strong><img src="'+e+'" alt="alt text"></p><h2 id="异步可中断更新" tabindex="-1">异步可中断更新 <a class="header-anchor" href="#异步可中断更新" aria-label="Permalink to &quot;异步可中断更新&quot;">​</a></h2><h3 id="同步更新和异步更新的区别" tabindex="-1">同步更新和异步更新的区别 <a class="header-anchor" href="#同步更新和异步更新的区别" aria-label="Permalink to &quot;同步更新和异步更新的区别&quot;">​</a></h3><p>如下图</p><p>输入框内输入的文字较多时，同步模式下就会出现明显的卡顿 <img src="'+r+'" alt="alt text"></p><h3 id="对比同步与异步工作模式" tabindex="-1">对比同步与异步工作模式 <a class="header-anchor" href="#对比同步与异步工作模式" aria-label="Permalink to &quot;对比同步与异步工作模式&quot;">​</a></h3><p><strong>同步工作模式</strong></p><p>在该模式下，一旦开启，则不可中断，后续的浏览器事件(IO)都会被阻塞，需要等待整个 render 结束后才会处理</p><p><strong>异步可中断模式</strong></p><p>一个 fiber 就是一个最小的工作单元</p><p>render 阶段，为了避免出现浏览器事件(IO)长期得不到相应而出现的饥饿现象，故把整个 render 做时间切片 time-slicing，在每个时间片的末尾根据优先级查询当前是否有 IO 操作需要响应，如果有则转去处理 IO，当前 render 可暂停、继续、丢弃等，然后进行增量渲染。（关于饥饿现象、时间切片和可中断性可参考 OS）</p><p>Commit 阶段始终是同步的，目的就是为了将变化的部分一次性更新到 DOM 上</p><p><img src="'+o+'" alt="alt text"></p><h3 id="fiber-数据结构" tabindex="-1">Fiber 数据结构 <a class="header-anchor" href="#fiber-数据结构" aria-label="Permalink to &quot;Fiber 数据结构&quot;">​</a></h3><p><img src="'+t+'" alt="alt text"></p><h3 id="fiber-树" tabindex="-1">Fiber 树 <a class="header-anchor" href="#fiber-树" aria-label="Permalink to &quot;Fiber 树&quot;">​</a></h3><p>type 表示组件的类型 tag 表示组件的类型</p><p>节点间的连接关系 child（孩子）、sibling（兄弟）、return（父亲）</p><p>并不是一个标准的树状结构，而是一个链表的结构，用一个链表来表示一棵树，他的好处就是能够做到单向遍历，每一步都可以做到暂停和恢复。</p><p>遍历顺序是深度优先（DFS）：先遍历所有的 child 节点、没有 child 节点就会去找兄弟节点 sibling、然后再是 child 节点，没有 child 节点就去找兄弟节点，没有兄弟节点就回去找 return（表示上一级的节点，并不是 parent）</p><p>从遍历顺序上看，Fiber 树实际上是用链表来表示的树</p><p><img src="'+a+'" alt="alt text"></p><p>根据遍历顺序，以下的打印顺序是什么</p><p><img src="'+c+'" alt="alt text"></p><h3 id="fiber-双缓冲" tabindex="-1">Fiber 双缓冲 <a class="header-anchor" href="#fiber-双缓冲" aria-label="Permalink to &quot;Fiber 双缓冲&quot;">​</a></h3><p>初始 render 阶段，fiber 的 alternate 会绘制成完整的一个 Fiber 树，在 commit 阶段，Fiber 会把 current 节点指向 alternate 节点，做一次性的替换。</p><p>React 默认会创建 rootFiberNode，下面挂在 rootFiber，初次时，rootFiber 下面的 current 是空的（current 任何时候都是指向浏览器实际渲染的内容）。render 阶段，会在 alternate 节点开始计算生成完整的一个 Fiber 树，在 React 内部叫做 workInProgress 树，到了 commit 阶段，表示 workInProgress 树已经计算完成，它会把 alternate 节点浅 copy 到 rootFiber 的 current 节点，由于是浅 copy，整个速度是非常快的。</p><h3 id="scheduler" tabindex="-1">Scheduler <a class="header-anchor" href="#scheduler" aria-label="Permalink to &quot;Scheduler&quot;">​</a></h3><p>React 调度包含两层工作循环 workloop：Scheduler 层和 Fiber(Reconciler) 层</p><p>workloop 为了避免对浏览器造成一个阻塞，使用 Scheduler shouldYeld 方法用来判断当前事件执行的时间是否超过阀值，默认阀值为 5 毫秒 ，如果一个计算任务的计算时长超过这个阀值，react 就是出让浏览器的执行权，让更高优先级的任务插入，保证页面的流畅性。</p><h3 id="reconciler" tabindex="-1">Reconciler <a class="header-anchor" href="#reconciler" aria-label="Permalink to &quot;Reconciler&quot;">​</a></h3><h3 id="整体流程" tabindex="-1">整体流程 <a class="header-anchor" href="#整体流程" aria-label="Permalink to &quot;整体流程&quot;">​</a></h3><p><img src="'+i+'" alt="alt text"></p>',39),b=[h];function u(m,g,_,f,q,k){return d(),n("div",null,b)}const S=l(p,[["render",u]]);export{R as __pageData,S as default};
