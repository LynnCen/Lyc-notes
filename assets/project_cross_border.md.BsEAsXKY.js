import{_ as e,c as l,o as r,a8 as t}from"./chunks/framework.DfyYcdQv.js";const p=JSON.parse('{"title":"跨境退","description":"","frontmatter":{},"headers":[],"relativePath":"project/cross_border.md","filePath":"project/cross_border.md","lastUpdated":1741274414000}'),i={name:"project/cross_border.md"};function o(h,a,n,s,d,c){return r(),l("div",null,a[0]||(a[0]=[t('<h1 id="跨境退" tabindex="-1">跨境退 <a class="header-anchor" href="#跨境退" aria-label="Permalink to &quot;跨境退&quot;">​</a></h1><h2 id="需求背景" tabindex="-1">需求背景 <a class="header-anchor" href="#需求背景" aria-label="Permalink to &quot;需求背景&quot;">​</a></h2><p>大部分国家和地区用户均有强退货需求并向消费者表达了7天无理由退货服务，但跨境退无法退货是很多用户不愿意购买某些品类的重要原因，且海外收货地址下的退货退款成功率不足50%（远低于非海外地址的76%和手淘整体的94%）。</p><p>目前针对海外订单逆向退货方式主要是本地退（订单渗透率23%+）本地退依赖商家签约；期望补充提供跨境退服务，满足卖家和消费者逆向退货需求；同时结合运费险，优化用户跨境退货运费贵，退货成本高的问题。向消费者传递&quot;放心购，无忧退&quot;的服务心智，提升正向成交转化率和逆向退货退款成功率。</p><p>为满足海外用户的强退货需求，提升跨境退的退款成功率（目标&gt;80%），项目旨在建设通用的跨境逆向履约能力，优化跨境退流程，降低用户退货成本，传递&quot;放心购，无忧退&quot;的服务心智。通过补充跨境退服务，提升正向成交转化率和逆向退货退款成功率。</p><h2 id="目标" tabindex="-1">目标 <a class="header-anchor" href="#目标" aria-label="Permalink to &quot;目标&quot;">​</a></h2><ul><li>建设更为通用的跨境逆向履约能力，保障跨境退退款成功率&gt;80%</li><li>HK跨境退订单/GMV渗透率（跨境退成交/HK总成交）达xx%</li><li>跨境退打标商品D-O转化率提升xx%</li></ul><h2 id="适配器" tabindex="-1">适配器 <a class="header-anchor" href="#适配器" aria-label="Permalink to &quot;适配器&quot;">​</a></h2><h3 id="适配器是什么" tabindex="-1">适配器是什么？ <a class="header-anchor" href="#适配器是什么" aria-label="Permalink to &quot;适配器是什么？&quot;">​</a></h3><p>适配器模式是一种结构型设计模式，它允许将不兼容的接口转换为可兼容的接口，从而使原本由于接口不兼容而不能一起工作的类可以一起工作。适配器模式通过创建一个适配器类来连接两个不兼容的接口，使得原本不兼容的类可以协同工作。</p><p>前端开发中，适配器模式通常用于将不同框架或库的接口进行适配，以便在项目中统一使用：</p><ul><li>统一不同数据源的接口</li><li>兼容不同版本的API</li><li>适配不同的UI组件库</li></ul><h3 id="适配器模式的主要角色" tabindex="-1">适配器模式的主要角色 <a class="header-anchor" href="#适配器模式的主要角色" aria-label="Permalink to &quot;适配器模式的主要角色&quot;">​</a></h3><ul><li><strong>目标接口（Target）</strong>：定义客户端使用的特定接口</li><li><strong>适配器类（Adapter）</strong>：实现目标接口，并包含一个对适配者类的引用</li><li><strong>适配者类（Adaptee）</strong>：定义一个已经存在的接口，这个接口需要被适配</li></ul><h3 id="适配器模式的工作原理" tabindex="-1">适配器模式的工作原理 <a class="header-anchor" href="#适配器模式的工作原理" aria-label="Permalink to &quot;适配器模式的工作原理&quot;">​</a></h3><ol><li>创建目标接口（Target）：定义客户端使用的特定接口</li><li>创建适配者类（Adaptee）：定义一个已经存在的接口，这个接口需要被适配</li><li>创建适配器类（Adapter）：实现目标接口，并包含一个对适配者类的引用</li><li>客户端使用适配器类：客户端通过适配器类来使用适配者类，而不需要直接使用适配者类</li></ol><h3 id="适配器在react中的应用" tabindex="-1">适配器在React中的应用 <a class="header-anchor" href="#适配器在react中的应用" aria-label="Permalink to &quot;适配器在React中的应用&quot;">​</a></h3><ul><li>统一不同数据源的接口</li><li>兼容不同版本的API</li><li>适配不同的UI组件库</li></ul><h3 id="业务实践" tabindex="-1">业务实践 <a class="header-anchor" href="#业务实践" aria-label="Permalink to &quot;业务实践&quot;">​</a></h3><p>应用适配器思想，分析和拆分设计图，将不同页面中相同组件进行抽象和复用，分析其中的差异点，结合服务端接口返回字段差异，定义好组件的ts类型，尽可能抽象为单一可复用的最小单元，在每个页面的上层做一个适配器层，处理好接口数据，将组件的props进行适配，从而达到组件的复用。</p><h2 id="低代码拓展" tabindex="-1">低代码拓展 <a class="header-anchor" href="#低代码拓展" aria-label="Permalink to &quot;低代码拓展&quot;">​</a></h2><h3 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to &quot;背景&quot;">​</a></h3><ol><li>前后端人员数差异较大，前端2人后端8人，为了应对快速迭代模式，将部分页面通过低代码的方式实现，减少前后端人员差异，提升迭代效率</li><li>页面中存在大量重复组件，且组件的差异性不大，可通过配置话字段解决</li></ol><h3 id="低代码的实现" tabindex="-1">低代码的实现 <a class="header-anchor" href="#低代码的实现" aria-label="Permalink to &quot;低代码的实现&quot;">​</a></h3><p>分三步：制定协议，定义映射，生成组件</p><ol><li>制定组件协议，约定组件的输入输出，以及组件的样式和行为</li><li>在适配器层根据后端字段枚举出所有组件的映射关系,定义为一个map，key为后端字段，value为组件的配置</li></ol>',26)]))}const b=e(i,[["render",o]]);export{p as __pageData,b as default};
