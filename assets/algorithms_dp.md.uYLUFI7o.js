import{_ as h,C as t,c as p,o as i,a7 as a,b as k,w as n,a as e,G as r,a9 as d}from"./chunks/framework.BQb8NfN9.js";const m=JSON.parse('{"title":"动态规划（Dynamic Programming，DP）","description":"","frontmatter":{},"headers":[],"relativePath":"algorithms/dp.md","filePath":"algorithms/dp.md","lastUpdated":1771857214000}'),E={name:"algorithms/dp.md"};function g(o,s,F,y,c,u){const l=t("Mermaid");return i(),p("div",null,[s[1]||(s[1]=a(`<h1 id="动态规划-dynamic-programming-dp" tabindex="-1">动态规划（Dynamic Programming，DP） <a class="header-anchor" href="#动态规划-dynamic-programming-dp" aria-label="Permalink to &quot;动态规划（Dynamic Programming，DP）&quot;">​</a></h1><blockquote><p>把动态规划当成「有记忆的递归 + 系统化推表」来学，而不是一开始就死背状态转移方程。</p></blockquote><hr><h2 id="一、核心思想-两个前提-一个目标" tabindex="-1">一、核心思想：两个前提 + 一个目标 <a class="header-anchor" href="#一、核心思想-两个前提-一个目标" aria-label="Permalink to &quot;一、核心思想：两个前提 + 一个目标&quot;">​</a></h2><p><strong>动态规划</strong>是一种在有「重叠子问题」和「最优子结构」的场景下，通过<strong>保存子问题结果</strong>来避免重复计算、提升效率的算法思路。</p><ul><li><strong>最优子结构</strong>：大问题的最优解，可以由若干子问题的最优解组合而成<br> 例：<code>F(n) = F(n-1) + F(n-2)</code>，只要 <code>F(n-1)</code> 和 <code>F(n-2)</code> 正确，<code>F(n)</code> 就能算出来。</li><li><strong>重叠子问题</strong>：递归/搜索过程中，同一个子问题会被重复计算多次<br> 例：求 <code>F(5)</code> 时，<code>F(2)</code>、<code>F(3)</code> 会在递归树里出现很多次。</li></ul><p>动态规划的<strong>目标</strong>：在保证正确性的前提下，把这些「重复子问题」的结果记下来/推出来，从而把指数级的复杂度降到多项式，常见为 O(n)、O(n²)。</p><hr><h2 id="二、解题五步法-通用套路" tabindex="-1">二、解题五步法（通用套路） <a class="header-anchor" href="#二、解题五步法-通用套路" aria-label="Permalink to &quot;二、解题五步法（通用套路）&quot;">​</a></h2><p>做 DP 题时，可以按下面 5 步走：</p><ol><li><strong>定义状态</strong>：用一个或多个变量表示「子问题」，例如： <ul><li>一维：<code>dp[i]</code> 表示「前 i 个中的最优值」或「以 i 结尾的最优值」</li><li>二维：<code>dp[i][j]</code> 表示「前 i 个、容量 j 时的最优值」等</li></ul></li><li><strong>写状态转移方程</strong>：找到「由小到大」的递推关系，例如： <ul><li><code>dp[i] = dp[i-1] + dp[i-2]</code></li></ul></li><li><strong>确定初始值 / 边界条件</strong>：最小规模子问题的答案，例如： <ul><li><code>dp[0]</code>、<code>dp[1]</code> 是多少</li></ul></li><li><strong>确定计算顺序</strong>： <ul><li>若使用<strong>自底向上</strong>：一般从小到大循环 i</li><li>若使用<strong>记忆化搜索</strong>：由大到小递归，但会自动先算小规模子问题</li></ul></li><li><strong>实现代码</strong>： <ul><li><strong>自顶向下</strong>：递归 + 记忆化（缓存函数结果）</li><li><strong>自底向上</strong>：迭代表格填表</li></ul></li></ol><blockquote><p>牢记：<strong>先想「子问题定义」和「如何从小推大」</strong>，再去写代码。</p></blockquote><hr><h2 id="三、教学例子-斐波那契数列-从暴力到-dp" tabindex="-1">三、教学例子：斐波那契数列，从暴力到 DP <a class="header-anchor" href="#三、教学例子-斐波那契数列-从暴力到-dp" aria-label="Permalink to &quot;三、教学例子：斐波那契数列，从暴力到 DP&quot;">​</a></h2><h3 id="_3-1-问题定义" tabindex="-1">3.1 问题定义 <a class="header-anchor" href="#_3-1-问题定义" aria-label="Permalink to &quot;3.1 问题定义&quot;">​</a></h3><p>斐波那契数列：</p><ul><li>F(0) = 0</li><li>F(1) = 1</li><li>F(n) = F(n-1) + F(n-2) （n ≥ 2）</li></ul><p>问题：给定 n，求 F(n)。</p><hr><h3 id="_3-2-暴力递归-指数级复杂度" tabindex="-1">3.2 暴力递归：指数级复杂度 <a class="header-anchor" href="#_3-2-暴力递归-指数级复杂度" aria-label="Permalink to &quot;3.2 暴力递归：指数级复杂度&quot;">​</a></h3><p>最直接的写法就是照着数学公式递归：</p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>以 <code>F(5)</code> 为例，递归树大致如下，可以看到 <code>F(2)</code>、<code>F(3)</code> 被多次重复计算：</p>`,23)),(i(),k(d,null,{default:n(()=>[r(l,{id:"mermaid-160",class:"mermaid",graph:"graph%20TD%0A%20%20%20%20F5%5BF(5)%5D%20%20%0A%20%20%20%20F4_1%5BF(4)%5D%0A%20%20%20%20F3_1%5BF(3)%5D%0A%20%20%20%20F2_1%5BF(2)%5D%0A%20%20%20%20F1_1%5BF(1)%5D%0A%20%20%20%20F0_1%5BF(0)%5D%0A%20%20%20%20F2_2%5BF(2)%5D%0A%20%20%20%20F1_2%5BF(1)%5D%0A%20%20%20%20F0_2%5BF(0)%5D%0A%20%20%20%20F3_2%5BF(3)%5D%0A%20%20%20%20F2_3%5BF(2)%5D%0A%20%20%20%20F1_3%5BF(1)%5D%0A%20%20%20%20F0_3%5BF(0)%5D%0A%20%20%20%20F1_4%5BF(1)%5D%0A%0A%20%20%20%20F5%20--%3E%20F4_1%0A%20%20%20%20F5%20--%3E%20F3_2%0A%0A%20%20%20%20F4_1%20--%3E%20F3_1%0A%20%20%20%20F4_1%20--%3E%20F2_2%0A%0A%20%20%20%20F3_1%20--%3E%20F2_1%0A%20%20%20%20F3_1%20--%3E%20F1_2%0A%0A%20%20%20%20F2_1%20--%3E%20F1_1%0A%20%20%20%20F2_1%20--%3E%20F0_1%0A%0A%20%20%20%20F2_2%20--%3E%20F1_3%0A%20%20%20%20F2_2%20--%3E%20F0_2%0A%0A%20%20%20%20F3_2%20--%3E%20F2_3%0A%20%20%20%20F3_2%20--%3E%20F1_4%0A%0A%20%20%20%20F2_3%20--%3E%20F1_4%0A%20%20%20%20F2_3%20--%3E%20F0_3%0A"})]),fallback:n(()=>s[0]||(s[0]=[e(" Loading... ")])),_:1})),s[2]||(s[2]=a(`<p><strong>时间复杂度</strong>：约为 O(2ⁿ)，非常慢，只适合作为「递归树 + 重叠子问题」的示范。</p><hr><h3 id="_3-3-解法一-记忆化递归-自顶向下" tabindex="-1">3.3 解法一：记忆化递归（自顶向下） <a class="header-anchor" href="#_3-3-解法一-记忆化递归-自顶向下" aria-label="Permalink to &quot;3.3 解法一：记忆化递归（自顶向下）&quot;">​</a></h3><p><strong>想法</strong>：既然重复算了很多次，就把算过的结果记下来，下一次直接用。</p><h4 id="状态设计" tabindex="-1">状态设计 <a class="header-anchor" href="#状态设计" aria-label="Permalink to &quot;状态设计&quot;">​</a></h4><ul><li><code>memo[n]</code> 表示 <code>F(n)</code> 的值</li></ul><h4 id="状态转移" tabindex="-1">状态转移 <a class="header-anchor" href="#状态转移" aria-label="Permalink to &quot;状态转移&quot;">​</a></h4><ul><li>若 <code>memo[n]</code> 已经算过：直接返回</li><li>否则：<code>memo[n] = fib(n-1) + fib(n-2)</code></li></ul><h4 id="代码实现" tabindex="-1">代码实现 <a class="header-anchor" href="#代码实现" aria-label="Permalink to &quot;代码实现&quot;">​</a></h4><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fibMemo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">memo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [])</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (memo[n] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> undefined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> memo[n];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  memo[n] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fibMemo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, memo) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fibMemo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, memo);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> memo[n];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>复杂度</strong>：</p><ul><li>时间：O(n)，每个 n 只算一次</li><li>空间：O(n)（递归栈 + 记忆数组）</li></ul><hr><h3 id="_3-4-解法二-自底向上表格法-迭代-dp" tabindex="-1">3.4 解法二：自底向上表格法（迭代 DP） <a class="header-anchor" href="#_3-4-解法二-自底向上表格法-迭代-dp" aria-label="Permalink to &quot;3.4 解法二：自底向上表格法（迭代 DP）&quot;">​</a></h3><p>把刚才的「记忆」变成显式的数组，从小到大推：</p><h4 id="状态定义" tabindex="-1">状态定义 <a class="header-anchor" href="#状态定义" aria-label="Permalink to &quot;状态定义&quot;">​</a></h4><ul><li><code>dp[i]</code> 表示 F(i)</li></ul><h4 id="状态转移-1" tabindex="-1">状态转移 <a class="header-anchor" href="#状态转移-1" aria-label="Permalink to &quot;状态转移&quot;">​</a></h4><ul><li><code>dp[i] = dp[i-1] + dp[i-2]</code></li></ul><h4 id="初始值" tabindex="-1">初始值 <a class="header-anchor" href="#初始值" aria-label="Permalink to &quot;初始值&quot;">​</a></h4><ul><li><code>dp[0] = 0</code></li><li><code>dp[1] = 1</code></li></ul><h4 id="代码实现-1" tabindex="-1">代码实现 <a class="header-anchor" href="#代码实现-1" aria-label="Permalink to &quot;代码实现&quot;">​</a></h4><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fibDP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  dp[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  dp[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dp[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[n];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>复杂度</strong>：</p><ul><li>时间：O(n)</li><li>空间：O(n)</li></ul><hr><h3 id="_3-5-解法三-空间优化-滚动数组" tabindex="-1">3.5 解法三：空间优化（滚动数组） <a class="header-anchor" href="#_3-5-解法三-空间优化-滚动数组" aria-label="Permalink to &quot;3.5 解法三：空间优化（滚动数组）&quot;">​</a></h3><p>观察状态转移：<code>dp[i]</code> 只依赖 <code>dp[i-1]</code> 和 <code>dp[i-2]</code>，因此其实只要两个变量：</p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fibOptimized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// F(0)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// F(1)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cur</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev2;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    prev2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev1;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    prev1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev1;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>复杂度</strong>：</p><ul><li>时间：O(n)</li><li>空间：O(1)</li></ul><hr><h3 id="_3-6-三种写法对比" tabindex="-1">3.6 三种写法对比 <a class="header-anchor" href="#_3-6-三种写法对比" aria-label="Permalink to &quot;3.6 三种写法对比&quot;">​</a></h3><table tabindex="0"><thead><tr><th>解法</th><th>思路</th><th>时间复杂度</th><th>空间复杂度</th><th>特点</th></tr></thead><tbody><tr><td>暴力递归</td><td>按数学公式直接递归</td><td>O(2ⁿ)</td><td>O(n)</td><td>易懂但极慢，只适合作演示</td></tr><tr><td>记忆化递归</td><td>递归 + 缓存结果</td><td>O(n)</td><td>O(n)</td><td>思路接近暴力，改动小</td></tr><tr><td>自底向上 + 空间优化</td><td>循环推表 + 滚动数组</td><td>O(n)</td><td>O(1)</td><td>代码高效、面试常用写法</td></tr></tbody></table><hr><h2 id="四、做-dp-题时可以怎么想" tabindex="-1">四、做 DP 题时可以怎么想？ <a class="header-anchor" href="#四、做-dp-题时可以怎么想" aria-label="Permalink to &quot;四、做 DP 题时可以怎么想？&quot;">​</a></h2><ol><li><strong>先确认是不是 DP 题</strong><ul><li>是否存在「最优子结构」？</li><li>是否存在「重叠子问题」？</li></ul></li><li><strong>先用递归把问题“说清楚”</strong><ul><li>写出「当前状态」与「更小状态」的关系（哪怕先不考虑效率）</li></ul></li><li><strong>把递归改成记忆化</strong><ul><li>加一个缓存数组/哈希表，避免重复计算</li></ul></li><li><strong>再改成自底向上</strong><ul><li>用数组/表从小到大推，理清计算顺序</li></ul></li><li><strong>最后再看是否能优化空间</strong><ul><li>只依赖前几个状态时，可以滚动数组降到 O(1)</li></ul></li></ol><blockquote><p>建议练习顺序：先多做一维 DP（如爬楼梯、打家劫舍），再上二维 DP（网格路径、编辑距离），最后再看背包、区间 DP 等进阶类型。</p></blockquote>`,38))])}const A=h(E,[["render",g]]);export{m as __pageData,A as default};
