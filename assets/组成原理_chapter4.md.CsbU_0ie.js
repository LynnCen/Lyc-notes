import{_ as t,c as a,o,aa as s}from"./chunks/framework.CAVwB9kQ.js";const l="/Lyc-notes/assets/1694262218528.1WniC0lo.png",r="/Lyc-notes/assets/1694262189366.rSJsmh6H.png",e="/Lyc-notes/assets/%E9%9A%90%E5%90%AB%E5%AF%BB%E5%9D%80.BGaYBcox.png",i="/Lyc-notes/assets/%E7%AB%8B%E5%8D%B3_%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.B0Ilih1l.png",p="/Lyc-notes/assets/%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.DDWdSZe8.png",n="/Lyc-notes/assets/%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80.eb-pQN_Z.png",h="/Lyc-notes/assets/%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80.D86y2IhO.png",c="/Lyc-notes/assets/%E5%9F%BA%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.SjjdFXiu.png",d="/Lyc-notes/assets/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.Bn4ykbfn.png",g="/Lyc-notes/assets/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4.DlwzvWV-.png",m="/Lyc-notes/assets/1694518290426.BnbhMpSI.png",A="/Lyc-notes/assets/1694518300515.BQvi7WnT.png",u="/Lyc-notes/assets/1694518313870.DHMFYwiL.png",_="/Lyc-notes/assets/1694518331921.BDIdxgBX.png",E="/Lyc-notes/assets/1694518364500.TaUh7ihq.png",B="/Lyc-notes/assets/1694518374706.DbnSwzxi.png",b="/Lyc-notes/assets/1694601803725.Bgd5IhnA.png",F=JSON.parse('{"title":"第 4 章 指令系统","description":"","frontmatter":{},"headers":[],"relativePath":"组成原理/chapter4.md","filePath":"组成原理/chapter4.md","lastUpdated":1721127618000}'),P={name:"组成原理/chapter4.md"},C=s('<h1 id="第-4-章-指令系统" tabindex="-1">第 4 章 指令系统 <a class="header-anchor" href="#第-4-章-指令系统" aria-label="Permalink to &quot;第 4 章 指令系统&quot;">​</a></h1><h2 id="指令系统" tabindex="-1">指令系统 <a class="header-anchor" href="#指令系统" aria-label="Permalink to &quot;指令系统&quot;">​</a></h2><h3 id="指令集体系结构" tabindex="-1">指令集体系结构 <a class="header-anchor" href="#指令集体系结构" aria-label="Permalink to &quot;指令集体系结构&quot;">​</a></h3><p>机器指令(简称指令)是指示计算机执行某种操作的命令。一台计算机的所有指令的集合构成该机的指令系统，也称指令集。</p><p>ISA 规定的内容 主要包括:</p><ol><li><p>指令格式，指令寻址方式，操作类型，以及每种操作对应的操作数的相应规定。</p></li><li><p>操作数的类型，操作数寻址方式，以及是按大端方式还是按小端方式存放。</p></li><li><p>程序可访问的寄存器编号、个数和位数，存储空间的大小和编址方式。</p></li><li><p>指令执行过程的控制方式等，包括程序计数器、条件码定义等。</p></li></ol><h3 id="指令的基本格式" tabindex="-1">指令的基本格式 <a class="header-anchor" href="#指令的基本格式" aria-label="Permalink to &quot;指令的基本格式&quot;">​</a></h3><p>| 操作码 | 地址码字段 |</p><ul><li>操作码：指出该指令应执行什么操作以及具有何种功能。</li><li>地址码：给出被操作的信息(指令或数据)的地址，包括参加运算的一个或多个操作数的地址、运算结果的保存地址、程序的转移地址、被调用子程序的入口地址等</li><li>指令字长：是指一条指令所包含的二进制代码的位数，其取决于操作码的长度、地址码的长度 和地址码的个数。把指令长度等于机器字长的指令称为单字长指令，指令长度等于半个机器 字长的指令称为半字长指令，指令长度等于两个机器字长的指令称 双字长指令。</li></ul><p>在一个指令系统中，若所有指令的长度都是相等的，则称为定长指令字结构。定字长指令的执行速度快，控制简单。若各种指令的长度随指令功能而异，则称为变长指令字结构。然而，因为主在一般是按字节编址的，所以指令字长通常为字节的整数背。</p><p>常见指令格式：</p><ol><li>零地址指令</li><li>一地址指令</li><li>二地址指令</li><li>三地址指令</li><li>四地址指令</li></ol><h3 id="定长操作码指令格式" tabindex="-1">定长操作码指令格式 <a class="header-anchor" href="#定长操作码指令格式" aria-label="Permalink to &quot;定长操作码指令格式&quot;">​</a></h3><p>定长操作码指令在指令字的最高位部分分配固定的若干位(定长)表示操作码。一般 n 位操作码字段的指令系统量大能够表示 2^n 条指令。</p><h3 id="扩展操作码指令格式" tabindex="-1">扩展操作码指令格式 <a class="header-anchor" href="#扩展操作码指令格式" aria-label="Permalink to &quot;扩展操作码指令格式&quot;">​</a></h3><p>变长操作码 方法是扩展操作码，它使操作码 的长度随地址码的减少而增加，不同地址数的指令可具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长</p><p><img src="'+l+'" alt="1694262218528"></p><h3 id="指令的操作类型" tabindex="-1">指令的操作类型 <a class="header-anchor" href="#指令的操作类型" aria-label="Permalink to &quot;指令的操作类型&quot;">​</a></h3><ol><li>数据传送</li><li>算术和逻辑运算</li><li>移位操作</li><li>转移操作</li><li>输入输出操作</li></ol><h3 id="指令地址码的个数" tabindex="-1">指令地址码的个数 <a class="header-anchor" href="#指令地址码的个数" aria-label="Permalink to &quot;指令地址码的个数&quot;">​</a></h3><p>一条指令中必须明确地(显示)或隐含地包含以下信息。</p><p>(1)操作码。指定操作类型，如移位、加、减、乘、除、传送等</p><p>(2)源操作数或其地址。指出一个或多个源操作数或其所在地址，可能是主(虚)存地址，寄存器编号或 I/O 端口，也可以在指令中直接给出一个立即数。</p><p>(3)结果的地址。结果所存放的地址，可以是主存地址、寄存器编号或 I/O 端口。</p><p>(4)下一条指令地址。一般隐含在 PC 中，指令按顺序执行时，只要自动将 PC 的值加上指令的长度，就可以得出下一条指令的地址，如果遇到转移指令，则需要由指令给出转移到的目标地址。</p><h3 id="指令格式设计原则" tabindex="-1">指令格式设计原则 <a class="header-anchor" href="#指令格式设计原则" aria-label="Permalink to &quot;指令格式设计原则&quot;">​</a></h3><p>(1)指令应尽量短。降低开销</p><p>(2)要有足够的操作码位数。向后兼容</p><p>(3)操作码的编码必须有唯一的解释。</p><p>(4)指令长度应是字节的整数倍。指令存放在内存中，而内存往往按字节编址，指令的长度为字节的整数倍，便于指令的读取和指令地址的计算。</p><p>(5)合理选择地址字段的个数。</p><p>(6)指令应尽量规整。</p><p><img src="'+r+'" alt="1694262189366"></p><h2 id="指令的寻址方式" tabindex="-1">指令的寻址方式 <a class="header-anchor" href="#指令的寻址方式" aria-label="Permalink to &quot;指令的寻址方式&quot;">​</a></h2><p><strong>寻址方式是指寻找指令或操作数有效地址的方式，即确定本条指令的数据地址及下一条待执行指令的地址的方法</strong>。寻址方式分为<strong>指令寻址</strong>和<strong>数据寻址</strong>两大类。</p><h3 id="指令寻址和数据寻址" tabindex="-1">指令寻址和数据寻址 <a class="header-anchor" href="#指令寻址和数据寻址" aria-label="Permalink to &quot;指令寻址和数据寻址&quot;">​</a></h3><p><strong>寻找下一条将要执行的指令地址称为指令寻址；寻找本条指令的数据地址称为数据寻址。</strong></p><ol><li><strong>指令寻址</strong></li></ol><p>指令寻址方式有两种：一种是顺序寻址，一种是跳跃寻址方式。</p><p>顺序寻址：通过程序计数器 PC 加 1（1 一条指令的长度），自动形成下一条指令的地址。</p><p>跳跃寻址：由本条指令给出下一条指令地址的计算方式。由于可能受到状态寄存器的控制，跳跃的方式分为绝对转移（地址码直接给出转移目标地址）和相对转移（地址码指出转移目标地址相对于当前 PC 的偏移量），由于 CPU 总是根据 PC 的内容去贮存取指令，因此转移指令执行结果就是修改 PC 值，下一条指令仍然通过 PC 给出。</p><p>通常把指令中给出的操作数所在的存储单元的地址称为有效地址，存储单元地址可能是主存物理地址，也可能是虚拟地址。</p><ol start="2"><li><strong>数据寻址</strong></li></ol><p>数据寻址是指如何在指令中表示 一个操作数的地址，或怎样计算出操作数的地址。数据寻址 的方式较多，为区别各种方式，通常在指令字中设置 一个寻址特征字段，用来指明属于哪种寻址 方式(其位数决定了寻址方式的种类)</p><table><thead><tr><th>操作码</th><th>寻址特征</th><th>形式地址</th></tr></thead></table><p>指令中的地址码字段并不代表操作数的真实地址，这种地址称为<strong>形式地址(A)</strong>。形式地址结合寻址方式，可以计算出操作数在存储器中的真实地址，这种地址称为<strong>有效地址(EA)</strong>。</p><ul><li>若为立即寻址，则形式地址的位数决定了操作数的范围。</li><li>若为直接寻址，则形式地址的位数决定 了可寻址的范围。</li><li>若为寄存器寻址，则形式地址的位数决定了通用寄存器的最大数量。</li><li>若为寄存器间接寻址，则寄存器的位数决定了可寻址的范围</li></ul><blockquote><p>(A)表示地址为 A 的数值，A 既可以是寄存器编号，又可以是内存地址。</p></blockquote><h3 id="常见的数据寻址方式" tabindex="-1">常见的数据寻址方式 <a class="header-anchor" href="#常见的数据寻址方式" aria-label="Permalink to &quot;常见的数据寻址方式&quot;">​</a></h3><ol><li><strong>隐含寻址</strong></li></ol><p>这种类型的指令不明显地给出操作数的地址，而是隐含操作数的地址。例如，单地址的指令 格式就隐含约定第 二个操作数由累加器(ACC)提供，指令中只明显指出第一个操作数的地址。因此，累加器(ACC)对单地址指令格式来说是隐含寻址 <img src="'+e+'" alt="alt text"> 优点是有利于缩短指令字长:缺点是需增加存储操作数或隐含地址的硬件。</p><ol start="2"><li><strong>立即(树数)寻址</strong></li></ol><p>指令字中的地址字段指出的不是操作数的地址，而是操作数本身，也称立即数，采用补码表 示。</p><ol start="3"><li><strong>直接寻址</strong></li></ol><p>指令中给出的地址码是操作数的有效地址，这种地址称为直接地址或绝对地址。</p><p><img src="'+i+'" alt="alt text"></p><p>优点是简单，不需要专门计算操作数的地址，指令在执行阶段仅需访存一次:缺点是 A 的位数限制了该指令操作数的寻址范围，操作数的地址不易修改。</p><ol start="4"><li><strong>间接寻址</strong></li></ol><p>指令中给出的地址码是存放操作数有效地址的主存单元地址。</p><p><img src="'+p+'" alt="alt text"></p><ol start="5"><li><p><strong>寄存器寻址</strong></p><p>指令中给出的地址码是操作数所在的寄存器编号，操作数在寄存器中。</p><p>优点：</p><p>(1)寄存器数量远小于内存单元数，故寄存器编号和存储地址短，因而寄存器寻址方式的指令较短。</p><p>(2)操作数已在 CPU 中，不用访存，因而指令执行的速度快。</p></li><li><p><strong>寄存器间接寻址</strong></p><p>指令中给出的地址码是一个寄存器编号，该寄存器中存放的是操作数的有效地址。指令长度和寄存器寻址指令差不多，但由于要访存，所以寄存器间接寻址指令的执行时间比寄存器寻址指令的执行时间更长。 <img src="'+n+'" alt="alt text"></p></li><li><p><strong>相对寻址</strong></p></li></ol><p>相对寻址是把 PC 的内容加上指令格式中的形式地址 A 而形成操作数的有效地址，即 EA=(PC)+A，其中 A 是相对于当前 PC 值的偏移量，可正可负，补码表示</p><p>优点是操作数的地址不是固定的 ，它随 PC 值的变化而变化，且与指令地址之间总是相差一 个固定的偏移量，因此便于程序浮动。相对寻址广泛应用王转移損令。</p><p><img src="'+h+'" alt="alt text"></p><p>相对寻址方式可用来实现公共子程序的浮动或实现相对转移。</p><ol start="8"><li><strong>基址寻址</strong></li></ol><p>基址寻址方式下，指令中的地址码字段 A 给出一个偏移量，基准地址可以明显或隐含地由基址寄存器 B 给出。</p><p>操作数有效地址 EA = (B)+A</p><p><img src="'+c+'" alt="15"></p><p>基址寄存器是<strong>面向操作系统</strong>的，其内容由操作系统或管理程序确定，主要用于解决程序逻辑 空间与存储器物理空间的无关性。在程序执行过程中，基址寄存器的内容不变(作 基地址)， 形式地址可变(作为偏移量)。采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作 为基址寄存器，但其内容仍由操作系统确定。</p><p>基址寻址的优点是可以扩大寻址范围(基址寄存器的位数大于形式地址 A 的位数);用户不必考虑自己的程序存于主存的具体位置，因此有利于多道程序设计，并可用于编制浮动程序，但偏移量(形式地址 A)的位数较短。</p><p>变址、基址和相对 3 中寻址方式，都是将某个寄存器的内容与一个形式地址相加来生成操作数的有效地址。统称为偏移寻址。</p><ol start="9"><li><strong>变址寻址</strong></li></ol><p>变址寻址方式主要是用于对线性表之类的<strong>数组元素</strong>进行方便的访问。</p><p>采用变址寻址方式时，指令中的地址码字段 A 给出的是一个基准地址，<strong>例如数组的起始地址，而数组元素相对于基准地址的偏移量在指令中明显或隐含地由变址寄存器 I 给出，这样变址寄存器(简称变址器)的内容实际上就相当于数组元素的下标，每个元素的有效地址为基准地址加变址寄存器的内容</strong>，即操作数的有效地址 EA = (I) + A 其中 I 表示变址寄存器 I 的内容</p><p>显然，变址寻址与基址寻址的有效地址形成过程极为相似。但从本质上讲，两者有较大区别。 <strong>基址寻址面向系统</strong>，主要用于为多道程序或数据分配存储空间，因此基址寄存器的内容通常由操作系统或管理程序确定，在程序的执行过程中其值不可变 ，而指令字中的 A 是可变的。变址寻址<strong>立足于用户</strong>，主要用于处理<strong>数组</strong>问题，在变址寻址中，变址寄存器的内容由用户设定，在程序执 行过程中其值可变，而指令字中的 A 是不可变的。</p><ol start="10"><li><strong>堆栈寻址</strong></li></ol><p>堆栈是存储器(或寄存器组)中一块特定的、按后进先出(LIFO)原则管理的存储区，该存储区中读/写单元的地址是用一个特定寄存器给出的，该寄存器称为堆栈指针(SP)。堆栈可分为硬堆栈和软堆栈两种。寄存器堆栈也称硬堆栈，硬堆栈的成本较高，不适合做大容量的堆栈。而从主存中划出一段区域来做堆栈是最合算且最常用的方法，这种堆栈称为软堆栈 如果某指令的操作数的有效地址或转移目标地址位于该指令所在位置的钱、后某个固定位置上，则该操作数或转移目标可用相对寻址方式。采用相对寻址方式时，指令中的地址码字段 A 给出一个偏移量，基准地址隐含由 PC 给出，即操作数有效地址或目标地址 EA=(PC)+A</p><p>在采用堆栈结构的计算机中，大部分指令表面上都表现为无操作数指令的形式，因为操作数地址都隐含使用了 SP。因此在读/写堆栈的前后都伴有自动完成对 SP 的加减操作</p><p><img src="'+d+'" alt="alt text"></p><h4 id="操作类型" tabindex="-1">操作类型 <a class="header-anchor" href="#操作类型" aria-label="Permalink to &quot;操作类型&quot;">​</a></h4><p>1.算术和逻辑运算指令 加(ADD)、减(SUB)、比较(CMP)、乘(MUL)、除(DIV)、与(AND)、或(OR)、取反(NOT)、取负(NEG)、异或(XOR)、加 1(INC)、减 1(DEC)等。 2.移位指令 算术移位、逻辑移位、循环移位、半字交换。 算术左移：操作数的各位依次向左移，低位补零。有些机器将最高位移入进位标志 CF 位，这样可以通过判断符号标志和进位标志是否相等就可以判断是否发生了溢出。 算术右移：各位依次向右移，高位补符号。有些机器将最低位移入进位标志位。 逻辑左移：同算术左移。 逻辑右移：各位依次向右移，高位补零。 小循环左移：最高位移入进位标志位，同时也移入最低位。 小循环右移：最低位移入进位标志位，同时也移入最高位。 大循环左移：最高位移入进位标志位，而进位标志位移入最低位。 大循环右移：最低位移入进位标志位，而进位标志位移入最高位。 3.传送指令 传送指令通常有寄存器之间的传送 MOV、从内存单元读取数据到 CPU 寄存器 LOAD、从 CPU 寄存器写数据到内存单元 STORE 等。 4.串指令 串指令是对字符串进行操作的指令。如串传送，串比较，检索和传送出转换等指令。 5.顺序控制指令 顺序控制指令用来控制程序执行的顺序。有条件转移 BRANCH、无条件转移 JMP、跳步 SKIP、调用 CALL、返回 RET 等指令。 顺序控制类指令的功能通过将转移目标地址送到 PC 中来实现。 无条件转移指令在任何情况下都执行转移操作，而条件转移指令(分支指令)仅仅在特定条件满足时才执行转移操作。 调用指令也称为转子指令，和转移指令的根本区别在于执行调用指令时必须保存下一条指令的地址（返回地址）。调用指令用于子程序调用(即过程调用或函数调用)，当子程序执行结束时，根据返回地址回到主程序继续执行；而转移指令则不返回执行，因而无法保存返回地址。 返回指令的功能是在子程序执行完毕时，将事先保存的返回地址送到 PC，这样处理器就能回到原来的主程序继续执行。 6.CPU 控制指令 停机、开中断、关中断】系统模式切换以及进入特殊处理程序等指令。大多数机器将这类指令划为“特权”指令(也称为管态指令)，只能在内核代码执行时使用。 7.输入输出指令 这类指令用户完成 CPU 与外部设备交换数据或传送控制指令及状态信息。</p><h4 id="操作码编码" tabindex="-1">操作码编码 <a class="header-anchor" href="#操作码编码" aria-label="Permalink to &quot;操作码编码&quot;">​</a></h4><p>指令的操作码字段可以是固定长度，也可以是可变长度。 1.定长操作码编码 指令的操作码部分采用固定长度编码，这种译码方式方便，指令执行速度更快，但信息冗余。 2.拓展操作码编码 拓展操作码编码方式将操作码的编码长度分成几种固定长度的格式。操作码长度不固定，是可变的。</p><h4 id="标志信息的生成和使用" tabindex="-1">标志信息的生成和使用 <a class="header-anchor" href="#标志信息的生成和使用" aria-label="Permalink to &quot;标志信息的生成和使用&quot;">​</a></h4><p>常用的条件转移指令： <img src="'+g+'" alt="16"> CF = Count 异或 Sub</p><h4 id="高级语言于机器级代码之间的对应" tabindex="-1">高级语言于机器级代码之间的对应 <a class="header-anchor" href="#高级语言于机器级代码之间的对应" aria-label="Permalink to &quot;高级语言于机器级代码之间的对应&quot;">​</a></h4><p><img src="'+m+'" alt="1694518290426"></p><h4 id="常见的-x86-汇编指令" tabindex="-1">常见的 x86 汇编指令 <a class="header-anchor" href="#常见的-x86-汇编指令" aria-label="Permalink to &quot;常见的 x86 汇编指令&quot;">​</a></h4><p><img src="'+A+'" alt="1694518300515"></p><h4 id="at-t-格式和-interl-格式" tabindex="-1">AT&amp;T 格式和 Interl 格式 <a class="header-anchor" href="#at-t-格式和-interl-格式" aria-label="Permalink to &quot;AT&amp;T 格式和 Interl 格式&quot;">​</a></h4><p><img src="'+u+'" alt="1694518313870"></p><h4 id="选择语句的机器级表示" tabindex="-1">选择语句的机器级表示 <a class="header-anchor" href="#选择语句的机器级表示" aria-label="Permalink to &quot;选择语句的机器级表示&quot;">​</a></h4><p><img src="'+_+'" alt="1694518331921"></p><p><img src="'+E+'" alt="1694518364500"><img src="'+B+'" alt="1694518374706"></p><h4 id="循环语句的机器级表示" tabindex="-1">循环语句的机器级表示 <a class="header-anchor" href="#循环语句的机器级表示" aria-label="Permalink to &quot;循环语句的机器级表示&quot;">​</a></h4><p><img src="'+b+'" alt="1694601803725"></p><h4 id="call-和-ret-指令-函数调用的机器级表示" tabindex="-1">Call 和 Ret 指令（函数调用的机器级表示） <a class="header-anchor" href="#call-和-ret-指令-函数调用的机器级表示" aria-label="Permalink to &quot;Call 和 Ret 指令（函数调用的机器级表示）&quot;">​</a></h4><h4 id="指令系统设计风格" tabindex="-1">指令系统设计风格 <a class="header-anchor" href="#指令系统设计风格" aria-label="Permalink to &quot;指令系统设计风格&quot;">​</a></h4><p>1.按操作数位置指定风格来分 1） 累加器型指令系统 总是把其中一个操作数隐含在累加器(一般用 AC 表示)中，指令执行的结果也总是送到累加器中。 2） 栈型指令系统 JAVA 虚拟机采用的是栈型指令系统。FILO。操作数总是来自栈顶。通常是零地址或异地址指令。 3）通用寄存器型指令系统 使用通用寄存器而不是累加寄存器。其指令的操作数可以是立即数，或来自通用寄存器(R)，或来自存储单元(S)。 4）load/Store 型指令系统 也是通过使用通用寄存器来来存放运算过程中的临时数据。只有取数指令和存数指令才可以访问存储器，运算类指令不能访存。</p><p>2.指令格式的复杂程度来分 1）CISC 风格指令系统(complex Instruction Set Computer ) 特点： （1）指令系统复杂。指令多，寻址方式多，指令格式多。 （2）指令周期长。绝大多数指令需要多个时钟周期才能完成。 （3）指令周期差距大。各种指令都能访问存储器，使得简单指令和复杂指令所用的时钟周期数相差很大，不利于指令流水线。 （4）采用微程序控制。 （5）难以进行编译优化。</p><p>2）RISC 风格指令系统 (Reduced Instruction Set Computer) （1）指令数目少，只包含使用频度高的简单指令。 （2）指令格式规整。寻址方式少，指令格式少，指令长度一致 （3）采用 Load/Store 型指令设计风格。 （4）采用流水线方式执行指令。 （5）采用大量通用寄存器。 （6）采用硬连线控制器。 （7）采用优化的编译系统。</p>',102),q=[C];function x(f,D,k,I,L,S){return o(),a("div",null,q)}const T=t(P,[["render",x]]);export{F as __pageData,T as default};
