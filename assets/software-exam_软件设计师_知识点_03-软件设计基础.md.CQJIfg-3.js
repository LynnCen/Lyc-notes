import{_ as a,c as n,o as s,a7 as r}from"./chunks/framework.BQb8NfN9.js";const b=JSON.parse('{"title":"软件设计基础","description":"","frontmatter":{},"headers":[],"relativePath":"software-exam/软件设计师/知识点/03-软件设计基础.md","filePath":"software-exam/软件设计师/知识点/03-软件设计基础.md","lastUpdated":1770085161000}'),e={name:"software-exam/软件设计师/知识点/03-软件设计基础.md"};function i(l,t,o,d,p,h){return s(),n("div",null,t[0]||(t[0]=[r(`<h1 id="软件设计基础" tabindex="-1">软件设计基础 <a class="header-anchor" href="#软件设计基础" aria-label="Permalink to &quot;软件设计基础&quot;">​</a></h1><blockquote><p>软件设计是将需求规格说明转化为具体的体系结构、模块划分、接口定义和数据结构描述的过程。</p></blockquote><hr><h2 id="一、软件设计概述" tabindex="-1">一、软件设计概述 <a class="header-anchor" href="#一、软件设计概述" aria-label="Permalink to &quot;一、软件设计概述&quot;">​</a></h2><h3 id="_1-1-设计阶段划分" tabindex="-1">1.1 设计阶段划分 <a class="header-anchor" href="#_1-1-设计阶段划分" aria-label="Permalink to &quot;1.1 设计阶段划分&quot;">​</a></h3><table tabindex="0"><thead><tr><th>阶段</th><th>别名</th><th>主要任务</th></tr></thead><tbody><tr><td><strong>概要设计</strong></td><td>高层设计/体系结构设计</td><td>确定总体结构、划分模块、定义接口、选择技术方案</td></tr><tr><td><strong>详细设计</strong></td><td>低层设计/模块设计</td><td>对每个模块进行功能描述、算法设计、数据结构定义</td></tr></tbody></table><h3 id="_1-2-设计过程内容" tabindex="-1">1.2 设计过程内容 <a class="header-anchor" href="#_1-2-设计过程内容" aria-label="Permalink to &quot;1.2 设计过程内容&quot;">​</a></h3><ol><li><strong>体系结构设计</strong>：确定系统整体框架</li><li><strong>数据设计</strong>：定义数据结构和数据库</li><li><strong>接口设计</strong>：定义模块间和系统外部接口</li><li><strong>过程设计</strong>：设计算法和数据结构</li></ol><hr><h2 id="二、软件设计基本原则" tabindex="-1">二、软件设计基本原则 <a class="header-anchor" href="#二、软件设计基本原则" aria-label="Permalink to &quot;二、软件设计基本原则&quot;">​</a></h2><h3 id="_2-1-模块化-modularity" tabindex="-1">2.1 模块化 (Modularity) <a class="header-anchor" href="#_2-1-模块化-modularity" aria-label="Permalink to &quot;2.1 模块化 (Modularity)&quot;">​</a></h3><p><strong>定义</strong>：将复杂系统分解为若干个功能相对独立、规模适中的模块</p><p><strong>优点</strong>：</p><ul><li>降低系统复杂度</li><li>提高可理解性</li><li>提高可维护性</li><li>便于团队协作</li></ul><h3 id="_2-2-信息隐蔽-information-hiding" tabindex="-1">2.2 信息隐蔽 (Information Hiding) <a class="header-anchor" href="#_2-2-信息隐蔽-information-hiding" aria-label="Permalink to &quot;2.2 信息隐蔽 (Information Hiding)&quot;">​</a></h3><p><strong>定义</strong>：将模块的内部实现细节对其他模块隐藏，只暴露有限的接口</p><p><strong>优点</strong>：</p><ul><li>减少模块间依赖</li><li>提高模块独立性</li><li>便于修改和维护</li></ul><h3 id="_2-3-抽象-abstraction" tabindex="-1">2.3 抽象 (Abstraction) <a class="header-anchor" href="#_2-3-抽象-abstraction" aria-label="Permalink to &quot;2.3 抽象 (Abstraction)&quot;">​</a></h3><p><strong>定义</strong>：关注事物的主要特征，忽略次要细节</p><p><strong>层次</strong>：</p><ul><li>过程抽象：关注功能，忽略实现</li><li>数据抽象：关注数据特性，忽略存储细节</li></ul><hr><h2 id="三、内聚与耦合" tabindex="-1">三、内聚与耦合 <a class="header-anchor" href="#三、内聚与耦合" aria-label="Permalink to &quot;三、内聚与耦合&quot;">​</a></h2><h3 id="_3-1-内聚性-cohesion" tabindex="-1">3.1 内聚性 (Cohesion) <a class="header-anchor" href="#_3-1-内聚性-cohesion" aria-label="Permalink to &quot;3.1 内聚性 (Cohesion)&quot;">​</a></h3><p><strong>定义</strong>：模块内部各元素之间功能相关性的紧密程度</p><p><strong>原则</strong>：追求<strong>高内聚</strong></p><h4 id="内聚类型-由低到高" tabindex="-1">内聚类型（由低到高） <a class="header-anchor" href="#内聚类型-由低到高" aria-label="Permalink to &quot;内聚类型（由低到高）&quot;">​</a></h4><table tabindex="0"><thead><tr><th>类型</th><th>说明</th><th>内聚程度</th></tr></thead><tbody><tr><td>偶然内聚</td><td>模块内元素无实质联系，只是恰好放在一起</td><td>最低</td></tr><tr><td>逻辑内聚</td><td>元素逻辑相关但功能不同（如所有输入处理放一起）</td><td>↓</td></tr><tr><td>时间内聚</td><td>元素在同一时间段执行（如初始化模块）</td><td>↓</td></tr><tr><td>过程内聚</td><td>元素按特定顺序执行</td><td>↓</td></tr><tr><td>通信内聚</td><td>元素使用相同输入数据或产生相同输出</td><td>↓</td></tr><tr><td>顺序内聚</td><td>一个元素的输出作为另一个元素的输入</td><td>↓</td></tr><tr><td>功能内聚</td><td>所有元素共同完成一个单一、明确的功能</td><td>最高</td></tr></tbody></table><h4 id="记忆口诀" tabindex="-1">记忆口诀 <a class="header-anchor" href="#记忆口诀" aria-label="Permalink to &quot;记忆口诀&quot;">​</a></h4><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>偶逻时过通顺功</span></span>
<span class="line"><span>低到高来记心中</span></span>
<span class="line"><span>功能内聚最理想</span></span>
<span class="line"><span>设计追求要牢记</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_3-2-耦合性-coupling" tabindex="-1">3.2 耦合性 (Coupling) <a class="header-anchor" href="#_3-2-耦合性-coupling" aria-label="Permalink to &quot;3.2 耦合性 (Coupling)&quot;">​</a></h3><p><strong>定义</strong>：模块与模块之间相互依赖的程度</p><p><strong>原则</strong>：追求<strong>低耦合</strong></p><h4 id="耦合类型-由高到低" tabindex="-1">耦合类型（由高到低） <a class="header-anchor" href="#耦合类型-由高到低" aria-label="Permalink to &quot;耦合类型（由高到低）&quot;">​</a></h4><table tabindex="0"><thead><tr><th>类型</th><th>说明</th><th>耦合程度</th></tr></thead><tbody><tr><td>内容耦合</td><td>一个模块直接访问或修改另一个模块的内部数据</td><td>最高（最差）</td></tr><tr><td>公共耦合</td><td>多个模块共享全局数据</td><td>↓</td></tr><tr><td>外部耦合</td><td>模块共享外部设备或文件</td><td>↓</td></tr><tr><td>控制耦合</td><td>一个模块通过传递控制信息影响另一个模块的执行</td><td>↓</td></tr><tr><td>标记耦合</td><td>模块间传递记录信息（数据结构）</td><td>↓</td></tr><tr><td>数据耦合</td><td>模块间只传递简单数据参数</td><td>最低（最好）</td></tr></tbody></table><h4 id="记忆口诀-1" tabindex="-1">记忆口诀 <a class="header-anchor" href="#记忆口诀-1" aria-label="Permalink to &quot;记忆口诀&quot;">​</a></h4><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>内公外控标数</span></span>
<span class="line"><span>高到低来排队</span></span>
<span class="line"><span>数据耦合最理想</span></span>
<span class="line"><span>内容耦合最要避</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_3-3-内聚耦合综合" tabindex="-1">3.3 内聚耦合综合 <a class="header-anchor" href="#_3-3-内聚耦合综合" aria-label="Permalink to &quot;3.3 内聚耦合综合&quot;">​</a></h3><table tabindex="0"><thead><tr><th>目标</th><th>原则</th><th>理想状态</th></tr></thead><tbody><tr><td>内聚</td><td>尽量高</td><td>功能内聚</td></tr><tr><td>耦合</td><td>尽量低</td><td>数据耦合</td></tr></tbody></table><p><strong>黄金法则</strong>：<strong>高内聚、低耦合</strong></p><hr><h2 id="四、solid设计原则" tabindex="-1">四、SOLID设计原则 <a class="header-anchor" href="#四、solid设计原则" aria-label="Permalink to &quot;四、SOLID设计原则&quot;">​</a></h2><h3 id="_4-1-单一职责原则-srp" tabindex="-1">4.1 单一职责原则 (SRP) <a class="header-anchor" href="#_4-1-单一职责原则-srp" aria-label="Permalink to &quot;4.1 单一职责原则 (SRP)&quot;">​</a></h3><p><strong>Single Responsibility Principle</strong></p><p><strong>定义</strong>：一个类应该只有一个引起它变化的原因，即只承担一项职责</p><p><strong>作用</strong>：</p><ul><li>控制类的粒度</li><li>提高类的内聚性</li><li>降低复杂性</li></ul><p><strong>示例</strong>：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>❌ 错误：User类同时处理用户数据和邮件发送</span></span>
<span class="line"><span>✅ 正确：User类只处理用户数据，EmailService类处理邮件发送</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_4-2-开闭原则-ocp" tabindex="-1">4.2 开闭原则 (OCP) <a class="header-anchor" href="#_4-2-开闭原则-ocp" aria-label="Permalink to &quot;4.2 开闭原则 (OCP)&quot;">​</a></h3><p><strong>Open/Closed Principle</strong></p><p><strong>定义</strong>：软件实体应该<strong>对扩展开放，对修改关闭</strong></p><p><strong>含义</strong>：</p><ul><li>增加新功能时，通过添加新代码实现</li><li>不修改已有的、经过测试的稳定代码</li></ul><p><strong>实现方式</strong>：</p><ul><li>使用抽象和多态</li><li>依赖抽象而非具体实现</li></ul><h3 id="_4-3-里氏替换原则-lsp" tabindex="-1">4.3 里氏替换原则 (LSP) <a class="header-anchor" href="#_4-3-里氏替换原则-lsp" aria-label="Permalink to &quot;4.3 里氏替换原则 (LSP)&quot;">​</a></h3><p><strong>Liskov Substitution Principle</strong></p><p><strong>定义</strong>：所有引用基类的地方必须能透明地使用其子类对象</p><p><strong>简单理解</strong>：子类对象应该能够替换父类对象，且程序行为不变</p><p><strong>违反示例</strong>：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>❌ 正方形继承矩形，但设置宽高时行为不一致</span></span>
<span class="line"><span>✅ 使用接口或组合代替继承</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_4-4-接口隔离原则-isp" tabindex="-1">4.4 接口隔离原则 (ISP) <a class="header-anchor" href="#_4-4-接口隔离原则-isp" aria-label="Permalink to &quot;4.4 接口隔离原则 (ISP)&quot;">​</a></h3><p><strong>Interface Segregation Principle</strong></p><p><strong>定义</strong>：客户端不应该被迫依赖于它不使用的方法</p><p><strong>原则</strong>：</p><ul><li>接口要小而专一</li><li>避免&quot;胖接口&quot;</li><li>将大接口拆分成小接口</li></ul><p><strong>示例</strong>：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>❌ 错误：IWorker接口包含work()和eat()方法，机器人也要实现eat()</span></span>
<span class="line"><span>✅ 正确：拆分为IWorkable和IFeedable两个接口</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_4-5-依赖倒置原则-dip" tabindex="-1">4.5 依赖倒置原则 (DIP) <a class="header-anchor" href="#_4-5-依赖倒置原则-dip" aria-label="Permalink to &quot;4.5 依赖倒置原则 (DIP)&quot;">​</a></h3><p><strong>Dependency Inversion Principle</strong></p><p><strong>定义</strong>：</p><ul><li>高层模块不应该依赖于低层模块，两者都应该依赖于抽象</li><li>抽象不应该依赖于细节，细节应该依赖于抽象</li></ul><p><strong>简单理解</strong>：面向接口编程，而不是面向实现编程</p><p><strong>示例</strong>：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>❌ 错误：OrderService直接依赖MySQLDatabase</span></span>
<span class="line"><span>✅ 正确：OrderService依赖IDatabase接口，MySQLDatabase实现该接口</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_4-6-solid原则总结" tabindex="-1">4.6 SOLID原则总结 <a class="header-anchor" href="#_4-6-solid原则总结" aria-label="Permalink to &quot;4.6 SOLID原则总结&quot;">​</a></h3><table tabindex="0"><thead><tr><th>原则</th><th>缩写</th><th>核心思想</th></tr></thead><tbody><tr><td>单一职责</td><td>SRP</td><td>一个类只做一件事</td></tr><tr><td>开闭原则</td><td>OCP</td><td>对扩展开放，对修改关闭</td></tr><tr><td>里氏替换</td><td>LSP</td><td>子类可以替换父类</td></tr><tr><td>接口隔离</td><td>ISP</td><td>接口要小而专一</td></tr><tr><td>依赖倒置</td><td>DIP</td><td>依赖抽象而非具体</td></tr></tbody></table><hr><h2 id="五、其他设计原则" tabindex="-1">五、其他设计原则 <a class="header-anchor" href="#五、其他设计原则" aria-label="Permalink to &quot;五、其他设计原则&quot;">​</a></h2><h3 id="_5-1-迪米特法则-lod" tabindex="-1">5.1 迪米特法则 (LoD) <a class="header-anchor" href="#_5-1-迪米特法则-lod" aria-label="Permalink to &quot;5.1 迪米特法则 (LoD)&quot;">​</a></h3><p><strong>Law of Demeter / 最少知识原则</strong></p><p><strong>定义</strong>：一个对象应该对其他对象有尽可能少的了解</p><p><strong>规则</strong>：</p><ul><li>只与直接朋友通信</li><li>不要调用&quot;朋友的朋友&quot;的方法</li></ul><p><strong>朋友包括</strong>：</p><ul><li>当前对象本身</li><li>当前对象的成员变量</li><li>方法参数</li><li>方法创建的对象</li></ul><h3 id="_5-2-组合优于继承" tabindex="-1">5.2 组合优于继承 <a class="header-anchor" href="#_5-2-组合优于继承" aria-label="Permalink to &quot;5.2 组合优于继承&quot;">​</a></h3><p><strong>定义</strong>：优先使用对象组合，而不是类继承来实现代码复用</p><p><strong>原因</strong>：</p><ul><li>继承是静态的，组合是动态的</li><li>继承破坏封装，组合保持封装</li><li>继承会导致类爆炸</li></ul><hr><h2 id="六、考试要点" tabindex="-1">六、考试要点 <a class="header-anchor" href="#六、考试要点" aria-label="Permalink to &quot;六、考试要点&quot;">​</a></h2><h3 id="选择题常见考法" tabindex="-1">选择题常见考法 <a class="header-anchor" href="#选择题常见考法" aria-label="Permalink to &quot;选择题常见考法&quot;">​</a></h3><ol><li><strong>内聚类型判断</strong>：给定场景，判断属于哪种内聚类型</li><li><strong>耦合类型判断</strong>：给定模块交互方式，判断耦合类型</li><li><strong>设计原则应用</strong>：判断代码是否违反某设计原则</li><li><strong>原则特点辨析</strong>：区分不同设计原则的含义</li></ol><h3 id="典型例题" tabindex="-1">典型例题 <a class="header-anchor" href="#典型例题" aria-label="Permalink to &quot;典型例题&quot;">​</a></h3><p><strong>题1</strong>：某模块内的各部分都是在同一时间段内执行，这种内聚属于？ <strong>答案</strong>：时间内聚</p><p><strong>题2</strong>：模块A通过参数向模块B传递一个标志，模块B根据标志决定执行流程，这种耦合属于？ <strong>答案</strong>：控制耦合</p><p><strong>题3</strong>：哪个原则要求&quot;对扩展开放，对修改关闭&quot;？ <strong>答案</strong>：开闭原则(OCP)</p><h3 id="速记表" tabindex="-1">速记表 <a class="header-anchor" href="#速记表" aria-label="Permalink to &quot;速记表&quot;">​</a></h3><table tabindex="0"><thead><tr><th>概念</th><th>理想状态</th><th>最差状态</th></tr></thead><tbody><tr><td>内聚</td><td>功能内聚</td><td>偶然内聚</td></tr><tr><td>耦合</td><td>数据耦合</td><td>内容耦合</td></tr></tbody></table>`,102)]))}const u=a(e,[["render",i]]);export{b as __pageData,u as default};
