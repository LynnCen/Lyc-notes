import{_ as o,c as d,o as c,a8 as a}from"./chunks/framework.DfyYcdQv.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/browser.md","filePath":"interview/browser.md","lastUpdated":1712803686000}'),t={name:"interview/browser.md"};function r(i,e,p,n,s,l){return c(),d("div",null,e[0]||(e[0]=[a('<h3 id="说一下浏览器的同源策略" tabindex="-1">说一下浏览器的同源策略 <a class="header-anchor" href="#说一下浏览器的同源策略" aria-label="Permalink to &quot;说一下浏览器的同源策略&quot;">​</a></h3><p>同源策略是浏览器的一项安全策略 目的：用于保护用户数据的安全性 据同源策略，浏览器限制了不同源的网页之间的交互行为，以防止恶意网站获取用户的敏感信息</p><h3 id="有哪些方式可以实现跨域" tabindex="-1">有哪些方式可以实现跨域？ <a class="header-anchor" href="#有哪些方式可以实现跨域" aria-label="Permalink to &quot;有哪些方式可以实现跨域？&quot;">​</a></h3><p><code>JSONP</code>（JSON with Padding）：<code>JSONP</code> 是一种通过动态创建 <code>&lt;script&gt;</code> 标签来实现跨域请求的方法。服务器返回的数据会被包裹在一个函数调用中，前端通过定义一个同名的函数来接收返回的数据。</p><p><code>CORS</code>（跨域资源共享）：<code>CORS</code> 是一种基于 HTTP 头部的机制，允许浏览器向服务器发出跨域请求。通过在服务器端设置响应头中的 <code>CORS</code> 头部字段，指定哪些源可以访问该资源。</p><p>代理：通过在同源的服务器上设置代理，将跨域请求转发到目标服务器上。前端将请求发送给同源的服务器，再由服务器转发给目标服务器，并将目标服务器的响应返回给前端。</p><p><code>WebSocket</code>：<code>WebSocket</code> 是一种双向通信协议，它允许浏览器与服务器之间建立持久的连接。由于 <code>WebSocket</code> 采用了自定义的协议，不受同源策略的限制，因此可以实现跨域通信。</p><p>跨文档通信 API：HTML5 提供了一些跨文档通信的 API，如 <code>postMessage</code> 方法，可以在不同窗口或跨域的 <code>iframe</code> 之间传递消息。</p><p>反向代理：通过在服务器上设置反向代理，将外部请求转发到目标服务器上，并将响应返回给请求方。这样前端只需要与同源的服务器进行通信，而不需要直接与目标服务器进行跨域请求。</p><h3 id="浏览器的缓存策略" tabindex="-1">浏览器的缓存策略 <a class="header-anchor" href="#浏览器的缓存策略" aria-label="Permalink to &quot;浏览器的缓存策略&quot;">​</a></h3><p><strong>强缓存</strong> 强缓存是指浏览器在请求资源时，直接从本地缓存中获取资源，而不向服务器发送请求。这样可以减少网络流量和提高页面加载速度。</p><p>常用的强缓存控制字段包括：</p><p><code>Expires</code>：过期时间，由服务器在响应头中发送，指定资源的到期时间。客户端在这个过期时间之前可以直接从缓存中加载资源。</p><p><code>Cache-Control</code>：更为灵活和可靠的缓存控制方式，可以指定资源的缓存规则。常用的指令有：</p><p><code>public</code>：指示响应可以被任何缓存保存。 <code>private</code>：指示响应只能在特定条件下被客户端缓存，不能被共享缓存或代理服务器缓存。 <code>max-age=&lt;seconds&gt;</code>：指示缓存的最大有效时间，单位是秒。 <code>no-cache</code>：指示客户端在使用缓存之前必须先验证响应的有效性，可以向服务器发送条件请求。 <code>no-store</code>：指示客户端不应该缓存响应的任何部分。</p><p><strong>协商缓存</strong> 协商缓存是在客户端本地缓存失效时，向服务器发送请求来验证资源是否仍然有效的一种缓存机制。如果资源在服务器端未发生变化，则服务器返回 <code>304 Not Modified</code> 状态码，告诉浏览器可以使用本地缓存的副本。</p><p>常用的协商缓存控制字段包括：</p><p><code>Last-Modified</code> 和 <code>If-Modified-Since</code>：服务器在响应头中发送资源的最后修改时间，客户端在后续请求中发送 <code>If-Modified-Since</code> 条件请求头，如果资源在此时间之后未修改，则服务器返回 <code>304 Not Modified</code> 响应。</p><p><code>ETag</code> 和 <code>If-None-Match</code>：服务器在响应头中发送资源的唯一标识符<code>（ETag）</code>，客户端在后续请求中发送 <code>If-None-Match </code>条件请求头，如果资源的 <code>ETag</code> 值与客户端提供的值匹配，则服务器返回 <code>304 Not Modified</code> 响应。</p>',19)]))}const _=o(t,[["render",r]]);export{h as __pageData,_ as default};
