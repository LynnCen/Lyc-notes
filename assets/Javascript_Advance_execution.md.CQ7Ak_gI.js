import{_ as a,c as o,o as r,a8 as e}from"./chunks/framework.D9WC-p0B.js";const l="/Lyc-notes/assets/0117.EdzRgodI.png",s="/Lyc-notes/assets/compiler.CH0CFl2h.webp",i="/Lyc-notes/assets/0119.D_474Jak.png",n="/Lyc-notes/assets/v8struct.2oSN2LjR.png",c="/Lyc-notes/assets/lexicalAnalysis.BtqH6VNi.png",J=JSON.parse('{"title":"JS代码是如何被解析执行的？","description":"","frontmatter":{},"headers":[],"relativePath":"Javascript/Advance/execution.md","filePath":"Javascript/Advance/execution.md","lastUpdated":1714060185000}'),p={name:"Javascript/Advance/execution.md"};function h(g,t,d,u,b,S){return r(),o("div",null,[...t[0]||(t[0]=[e('<h1 id="js代码是如何被解析执行的" tabindex="-1">JS代码是如何被解析执行的？ <a class="header-anchor" href="#js代码是如何被解析执行的" aria-label="Permalink to &quot;JS代码是如何被解析执行的？&quot;">​</a></h1><h2 id="js引擎" tabindex="-1">JS引擎 <a class="header-anchor" href="#js引擎" aria-label="Permalink to &quot;JS引擎&quot;">​</a></h2><blockquote><p>虚拟机：一种特殊的软件，可以在计算机平台和终端用户之间创建一种环境，使得终端用户可以基于该软件所创建的环境来操作软件。有系统虚拟机和程序虚拟机之分：</p><ul><li>系统虚拟机 - 可以运行完整的操作系统，如 VMware</li><li>程序虚拟机 - 也叫进程虚拟机，支持单个进程，可以运行单个计算机程序，例如 Java 虚拟机</li></ul></blockquote><p><strong>定义：</strong> JS 引擎是一种虚拟机，是 JS 代码的运行环境，其作用就是将 JS 代码编译成机器可理解执行的机器代码，JavaScript解析引擎就是能够“读懂”JavaScript代码，并准确地给出代码运行结果的一段程序。比方说，当你写了 <code>var a = 1 + 1</code> 这样一段代码，JavaScript引擎做的事情就是看懂（解析）你这段代码，并且将a的值变为2。</p><h3 id="js引擎与渲染引擎" tabindex="-1">JS引擎与渲染引擎 <a class="header-anchor" href="#js引擎与渲染引擎" aria-label="Permalink to &quot;JS引擎与渲染引擎&quot;">​</a></h3><p>渲染引擎渲染页面，JS 引擎执行 JS 代码</p><ul><li>渲染引擎通过 JS 引擎提供的调用接口，使用 JS 引擎处理 JS 代码并获得结果</li><li>JS 引擎通过桥接接口访问或修改渲染引擎生成的 DOM 树</li></ul><p><img src="'+l+'" alt="alt text"></p><h3 id="编译器-vs-解释器" tabindex="-1">编译器 VS 解释器 <a class="header-anchor" href="#编译器-vs-解释器" aria-label="Permalink to &quot;编译器 VS 解释器&quot;">​</a></h3><p><strong>编译型语言</strong>：程序在执行之前需要一个专门的编译过程，把程序编译成 为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如C、C++、go等.</p><p><strong>解释型语言</strong>：程序不需要编译，程序在运行时才翻译成机器语言（所以执行前需要环境中安装了解释器），每执行一次都要翻译一次。因此效率比较低。效率比较低，依赖解释器，跨平台性好，如 Python、JS 等。</p><p>作为动态/解释执行的 JS，与静态/编译执行语言相比，低性能特性几乎是与生俱来的，制约其性能的因素主要有：</p><ol><li><p>类型，JS 是无类型的语言，对象标识和属性访问比静态语言存在更大的性能损失</p></li><li><p>解释执行，JS 无法像静态语言那样通过预编译转变成速度更快的本地代码</p></li></ol><p><img src="'+s+'" alt="alt text"></p><h3 id="js引擎是解释器or编译器" tabindex="-1">js引擎是解释器or编译器 <a class="header-anchor" href="#js引擎是解释器or编译器" aria-label="Permalink to &quot;js引擎是解释器or编译器&quot;">​</a></h3><p>JavaScript 引擎既可以是解释器，也可以是编译器，甚至是两者的结合体。</p><p><strong>解释器</strong>：在解释器模式下，JavaScript 引擎会逐行解释源代码，并将其转换为机器代码，然后立即执行。这种方式的好处是可以快速执行代码，但每次运行都需要解释源代码，可能会导致性能损失。</p><p><strong>编译器</strong>：在编译器模式下，JavaScript 引擎会将整个源代码文件转换为机器代码，然后执行机器代码。这种方式的好处是可以提高执行速度，因为不需要每次运行都重新解释代码。V8 引擎就是一个采用编译器的例子，它会将 JavaScript 代码编译成中间代码，然后再执行。</p><p><strong>即时编译器（JIT 编译器)</strong>：还有一种常见的方式是即时编译器，它将源代码解释成中间代码，并且在执行过程中将频繁执行的部分编译成机器代码，以提高执行速度。这种方式结合了解释器和编译器的优点，既可以快速执行代码，又可以提高性能。</p><p><strong>执行原理如下：</strong><img src="'+i+'" alt="alt text"></p><blockquote><ul><li><p><strong>编译器</strong>：将源代码编译成抽象语法树（AST），在一些引擎中，编译器还负责将 AST 转换成字节码</p></li><li><p><strong>解释器</strong>：主要解释执行字节码，同时依赖垃圾回收机制</p></li><li><p><strong>JIT 工具</strong>：即时编译工具，将 AST 或字节码转换成本地代码，同时依赖解释器告知哪些代码执行频次高</p></li><li><p><strong>垃圾回收器和分析工具</strong>：负责垃圾回收和收集引擎中的信息，帮助改善引擎性能</p></li></ul></blockquote><h2 id="解析流程" tabindex="-1">解析流程 <a class="header-anchor" href="#解析流程" aria-label="Permalink to &quot;解析流程&quot;">​</a></h2><h3 id="v8架构" tabindex="-1">v8架构 <a class="header-anchor" href="#v8架构" aria-label="Permalink to &quot;v8架构&quot;">​</a></h3><p><img src="'+n+'" alt="alt text"></p><h3 id="宏观流程" tabindex="-1">宏观流程 <a class="header-anchor" href="#宏观流程" aria-label="Permalink to &quot;宏观流程&quot;">​</a></h3><blockquote><ol><li><strong>生成抽象语法树AST(Parse)</strong></li></ol></blockquote><blockquote><ol start="2"><li><strong>生成字节码BytecodeGenerator(Ignition)</strong></li></ol></blockquote><blockquote><ol start="3"><li><strong>执行字节码（BytecodeExecution）</strong></li></ol></blockquote><blockquote><ol start="4"><li><strong>Turbofan</strong></li></ol></blockquote><p>参考 <a href="https://cloud.tencent.com/developer/article/1554112" target="_blank" rel="noreferrer">https://cloud.tencent.com/developer/article/1554112</a></p><h3 id="微观流程" tabindex="-1"><strong>微观流程</strong> <a class="header-anchor" href="#微观流程" aria-label="Permalink to &quot;**微观流程**&quot;">​</a></h3><blockquote><ol><li><strong>词法分析（Lexical Analysis）</strong></li></ol><p>v8解析器（parse）首先会对代码进行词法分析，将代码字符串分解成一个个的<strong>词法单元（Token）</strong>，比如关键字、标识符、运算符、分号等。</p><ol start="2"><li><strong>语法分析（Syntax Parsing）</strong></li></ol><p>在词法分析之后，引擎会将这些<strong>词法单元</strong>转换成一个个的语法结构，构建出<strong>抽象语法树（Abstract Syntax Tree，AST）</strong>。语法分析阶段会检查代码是否符合 JavaScript 的语法规范（ECMAScript），并在此过程中进行语法错误的检测。</p><ol start="3"><li><strong>执行上下文创建（Execution Context Creation）</strong></li></ol><p>在代码执行之前，JavaScript 引擎会创建全局执行上下文，并将其推入执行上下文栈（Execution Context Stack）中。此后，每当函数被调用时，都会创建一个新的执行上下文，并被推入执行上下文栈的顶部。</p><ol start="4"><li><strong>执行代码</strong></li></ol><p>引擎会按照执行上下文栈的顺序逐个执行其中的代码。在执行过程中，会根据代码的类型执行不同的操作，比如声明变量、执行函数、计算表达式等。</p><ol start="5"><li><strong>变量和函数声明</strong></li></ol><p>在执行代码的过程中，JavaScript 引擎会将变量和函数的<strong>声明提升（Hoisting）</strong>，即在代码执行前先进行声明，但初始化留在原处。这意味着变量和函数可以在声明之前被使用，但如果初始化在声明之后，则会出现未定义的行为。</p><ol start="6"><li><strong>执行栈管理</strong></li></ol><p>在函数调用时，会创建对应的执行上下文，并将其推入执行上下文栈的顶部；当函数执行完毕或返回时，对应的执行上下文会被从栈顶弹出，控制权交还给上一个执行上下文。</p><ol start="7"><li><strong>内存管理</strong></li></ol><p>在代码执行过程中，JavaScript 引擎会负责对内存的管理，包括变量的分配、垃圾回收等操作，确保代码的正常执行和内存的有效利用。</p></blockquote><h3 id="词法分析" tabindex="-1">词法分析 <a class="header-anchor" href="#词法分析" aria-label="Permalink to &quot;词法分析&quot;">​</a></h3><p>词法分析就是把源码的字符串按照 ECMAScript 标准分割出来，生成一系列的（记号流）token，如下图可知不同的字符串对应不同的token类型。</p><p><img src="'+c+'" alt="alt text"></p><h2 id="核心原理" tabindex="-1">核心原理 <a class="header-anchor" href="#核心原理" aria-label="Permalink to &quot;核心原理&quot;">​</a></h2><p>从JS引擎的执行流程来看，JS 引擎的核心实现原理历经以下几种方式：</p><blockquote><ol><li><p><strong>遍历语法树</strong></p></li><li><p><strong>字节码方式</strong></p></li><li><p><strong>JIT编译方式</strong></p></li><li><p><strong>WebAssembly</strong></p></li></ol></blockquote><h3 id="遍历语法树" tabindex="-1">遍历语法树 <a class="header-anchor" href="#遍历语法树" aria-label="Permalink to &quot;遍历语法树&quot;">​</a></h3><h3 id="字节码方式" tabindex="-1">字节码方式 <a class="header-anchor" href="#字节码方式" aria-label="Permalink to &quot;字节码方式&quot;">​</a></h3><h3 id="jit编译方式" tabindex="-1">JIT编译方式 <a class="header-anchor" href="#jit编译方式" aria-label="Permalink to &quot;JIT编译方式&quot;">​</a></h3><h3 id="webassembly" tabindex="-1">WebAssembly <a class="header-anchor" href="#webassembly" aria-label="Permalink to &quot;WebAssembly&quot;">​</a></h3>',42)])])}const m=a(p,[["render",h]]);export{J as __pageData,m as default};
