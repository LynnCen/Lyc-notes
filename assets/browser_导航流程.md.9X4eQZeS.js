import{_ as a,a as t}from"./chunks/重定向.BAeFG-mr.js";import{_ as p,c as o,o as r,a8 as n}from"./chunks/framework.D9WC-p0B.js";const s="/Lyc-notes/assets/%E5%AF%BC%E8%88%AA%E6%B5%81%E7%A8%8B.Dxz4bkGD.png",i="/Lyc-notes/assets/%E5%8A%A0%E8%BD%BDurl.CGViRvvr.png",l="/Lyc-notes/assets/%E5%AF%BC%E8%88%AA%E5%AE%8C%E6%88%90.CdJeGRvu.png",L=JSON.parse('{"title":"导航流程","description":"","frontmatter":{},"headers":[],"relativePath":"browser/导航流程.md","filePath":"browser/导航流程.md","lastUpdated":1736350751000}'),c={name:"browser/导航流程.md"};function d(h,e,g,m,b,u){return r(),o("div",null,[...e[0]||(e[0]=[n('<h1 id="导航流程" tabindex="-1">导航流程 <a class="header-anchor" href="#导航流程" aria-label="Permalink to &quot;导航流程&quot;">​</a></h1><h2 id="从输入-url-到页面展示-这中间发生了什么" tabindex="-1">从输入 URL 到页面展示，这中间发生了什么？ <a class="header-anchor" href="#从输入-url-到页面展示-这中间发生了什么" aria-label="Permalink to &quot;从输入 URL 到页面展示，这中间发生了什么？&quot;">​</a></h2><p><img src="'+s+'" alt="alt text"></p><ul><li>浏览器进程主要负责用户交互、子进程管理和文件储存等功能。</li><li>网络进程是面向渲染进程和浏览器进程等提供网络下载功能。</li><li>渲染进程的主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，就是为了保证系统的安全。</li></ul><p>流程描述：</p><p>● 首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程。</p><p>● 然后，在网络进程中发起真正的 URL 请求。</p><p>● 接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。</p><p>● 浏览器进程接收到网络进程的响应头数据之后，发送“提交导航(CommitNavigation)”消息到渲染进程；</p><p>● 渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道；</p><p>● 最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。</p><p>● 浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。</p><p>这其中，<strong>用户发出 URL 请求到页面开始解析的这个过程，就叫做导航</strong>。</p><h2 id="从输入-url-到页面展示" tabindex="-1">从输入 URL 到页面展示 <a class="header-anchor" href="#从输入-url-到页面展示" aria-label="Permalink to &quot;从输入 URL 到页面展示&quot;">​</a></h2><h4 id="用户输入" tabindex="-1">用户输入 <a class="header-anchor" href="#用户输入" aria-label="Permalink to &quot;用户输入&quot;">​</a></h4><p>当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL。</p><p>● 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。</p><p>● 如果判断输入内容符合 URL 规则，比如输入的是 time.geekbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL，如 <a href="https://time.geekbang.org" target="_blank" rel="noreferrer">https://time.geekbang.org</a>。</p><p>当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行<code>beforeunload</code>事件的机会，<code>beforeunload</code>事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过<code>beforeunload</code>事件来取消导航，让浏览器不再执行任何后续工作。</p><p>当前页面没有监听 beforeunload 事件或者同意了继续后续流程，那么浏览器便进入下图的状态：</p><p><img src="'+i+'" alt="alt text"></p><p>从图中可以看出，当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为极客时间的页面。因为需要等待<strong>提交文档阶段</strong>，页面内容才会被替换。</p><h4 id="url-请求过程" tabindex="-1">URL 请求过程 <a class="header-anchor" href="#url-请求过程" aria-label="Permalink to &quot;URL 请求过程&quot;">​</a></h4><p>接下来，便进入了页面资源请求过程。这时，浏览器进程会通过**进程间通信（IPC）**把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。那具体流程是怎样的呢？</p><p>① <strong>查找本地缓存</strong>。 网络进程会<strong>查找本地缓存</strong>是否缓存了该资源，缓存分为<a href="/Lyc-notes/interview/browser#浏览器的缓存策略">强制缓存和协商缓存</a>。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。</p><p>② <strong>DNS解析</strong>。这请求前的第一步是要进行<strong>DNS 解析</strong>，先查找本地域名服务器查看是否存在缓存，如果没有则采用迭代查询根域名服务器、顶级域名、权限域名（一、二、三级域名）等，以获取请求域名的服务器 IP 地址。如果请求协议是<a href="./../计网/https">HTTPS</a>，那么还需要建立<strong>TLS 连接</strong>。</p><p>接下来就是利用 IP 地址和服务器建立<strong>TCP 连接</strong>。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</p><p>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。（为了方便讲述，下面我将服务器返回的响应头和响应行统称为响应头。）</p><p><strong>（1）重定向</strong></p><p>在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。</p><p><img src="'+a+'" alt="alt text"></p><p>从图中可以看出，极客时间服务器会通过重定向的方式把所有 HTTP 请求转换为 HTTPS 请求。也就是说你使用 HTTP 向极客时间服务器请求时，服务器会返回一个包含有 301 或者 302 状态码响应头，并把响应头的 Location 字段中填上 HTTPS 的地址，这就是告诉了浏览器要重新导航到新的地址上。</p><p><strong>在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求</strong>。</p><p><strong>（2）响应数据类型处理</strong></p><p>URL 请求的数据类型，有时候是一个下载类型，有时候是正常的 HTML 页面，那么浏览器是如何区分它们呢？</p><p>答案是<code>Content-Type</code>。<code>Content-Type</code>是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据<code>Content-Type</code>的值来决定如何显示响应体的内容。</p><p><img src="'+t+`" alt="alt text"></p><p>响应头中的<code>Content-type</code>字段的值是<code>text/html</code>，这就是告诉浏览器，服务器返回的数据是 HTML 格式。</p><p>如果其<code>Content-Type</code>的值是<code>application/octet-stream</code>，显示数据是字节流类型的，通常情况下，浏览器会按照下载类型来处理该请求。</p><p>所以，不同<code>Content-Type</code>的后续处理流程也截然不同。如果<code>Content-Type</code>字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。但如果是 HTML，那么浏览器则会继续进行导航流程。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。</p><h4 id="准备渲染进程" tabindex="-1">准备渲染进程 <a class="header-anchor" href="#准备渲染进程" aria-label="Permalink to &quot;准备渲染进程&quot;">​</a></h4><p>默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。</p><p><strong>那什么情况下多个页面会同时运行在一个渲染进程中呢？</strong></p><p>要解决这个问题，我们就需要先了解下什么是同一站点（same-site）。具体地讲，我们将“同一站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者 http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>https://time.geekbang.org</span></span>
<span class="line"><span>https://www.geekbang.org</span></span>
<span class="line"><span>https://www.geekbang.org:8080</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>它们都是属于<strong>同一站点</strong>，因为它们的协议都是 HTTPS，而且根域名也都是 geekbang.org。</p><p>Chrome 的默认策略是，每个标签对应一个渲染进程。但<strong>如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程</strong>。官方把这个默认策略叫<code>process-per-site-instance</code>。</p><p>那若新页面和当前页面不属于同一站点，情况又会发生什么样的变化呢？</p><p>不属于同一站点，会使用一个新的渲染进程</p><p>总结来说，打开一个新页面采用的<strong>渲染进程策略</strong>就是：</p><p>● 通常情况下，打开新的页面都会使用单独的渲染进程；</p><p>● 如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。</p><p>渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了<strong>提交文档阶段</strong>。</p><h4 id="提交文档" tabindex="-1">提交文档 <a class="header-anchor" href="#提交文档" aria-label="Permalink to &quot;提交文档&quot;">​</a></h4><p>所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：</p><p>● 首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；</p><p>● 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；</p><p>● 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；</p><p>● 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</p><p>其中，当渲染进程确认提交之后，更新内容如下图所示： <img src="`+l+'" alt="alt text"></p><p>这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。</p><p>到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。</p><h4 id="渲染阶段" tabindex="-1">渲染阶段 <a class="header-anchor" href="#渲染阶段" aria-label="Permalink to &quot;渲染阶段&quot;">​</a></h4><p>一旦文档被提交，渲染进程便开始页面解析和子资源加载了(下章介绍)，一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>● 服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。</p><p>● Chrome 默认采用每个标签对应一个渲染进程，但是如果两个页面属于同一站点，那这两个标签会使用同一个渲染进程。</p><p>● 浏览器的导航过程涵盖了从用户发起请求到提交文档给渲染进程的中间所有阶段。</p><h2 id="思考" tabindex="-1">思考 <a class="header-anchor" href="#思考" aria-label="Permalink to &quot;思考&quot;">​</a></h2><p>从浏览器、网络、OS 和计算机组成原理角度分析</p><p>浏览器 - 导航流程、渲染流程</p><p>网络 - 建立链接，从 iso 五层模型角度分析（网段查询，ip 寻址，路由寻址，ARP 等）</p><p>OS - 进程通信，内存管理（分页），磁盘管理，IO</p><p>计算原理 - 一条指令（加法指令）上 CPU 上执行的过程，模拟数据通路走向</p>',74)])])}const P=p(c,[["render",d]]);export{L as __pageData,P as default};
