# 2015

## 1. 先序遍历得到二叉树的个数

枚举法：从左子树开始列举，然后再枚举右子树，得到14

根据二叉树前序遍历和中序遍历的递归算法中递归工作栈的状态变化得出:前序序列和中 序序列的关系相当于以前序序列为入栈次序，以中序序列为出栈次序。因为前序序列和中序序 列可以唯一地确定一棵二叉树，所以题意相当千“以序列 a, b, c, d 为入栈次序，则出栈序列的
个数为多少“

对于 n 个不同元素进栈，出栈序列的个数 (1 / (n+1))C(2n,n)  = 1/5 * (8!/4!*4!) 
 = 14 

排列组合C(n,m) = n! / (m! * (n-m)!)

## 2. 平衡二叉树中序遍历得到降序

- 只有两个结点的平衡二叉树的根结点的度为 1
- 中序遍历后可以得到一个降序序列，树中最大元素一定无左子树(可能有右子树)
- 最后插入的 结点可能会导致平衡调整，而不一定是叶结点

## 3. 折半查找判定序列

- [2010](/408/2010#_4-折半查找查找失败的最多比较次数)
  
折半查找的判定树是一棵二叉排序树


## 4. 比较次数与初始排列无关的排序算法

- [每趟不可确定一个元素的最终位置](/dataStructure/强化#第八章-排序)


基数排序


## 5. 希尔排序

- [2014-增量](/408/2014#_5-希尔排序的间隔-增量)
- [2009-插入排序](/408/2009#_4-插入排序)

组内选择直接插入排序

## 6. 浮点数对阶溢出判断（左归&右归）

- 对阶过程不会引起阶码上溢或者下溢，小阶向大阶看齐
- 右归和尾数舍入都可能引起阶码上溢（右归：尾数右移，阶码+1，尾数舍入可能会导致阶码+1）
- 左归时可能会导致阶码下溢（尾数左移，阶码-1）
- 尾数溢出时，仅代表精度表示不准确，不代表溢出

## 7. cache容量计算

**假定主存地址为32位，按字节编址，主存和 Cache 之间采用直接映射方式，主存块大小为4个字，每字32位，采用回写（Write Back）方式，则能存放4K 字数据的Cache 的总容量的位数至少是**

块的大小为4*32位 = 16B ，因为按字节编址，故需要4位为字块内地址

主存块4字，需要存放4K字数据，故需要4K字/4字 = 1K行，行号为10位

主存地址32位，故标记位 = 32-10-4 = 18位

直接映射地址结构：
| 标记18位   | 行号10   | 块内地址4位    | 
| -------| ---- | ------- |

**cache容量 = 1K行（18位标记 + 有效位1位 + 回写位1位 + 块4*32位）=148K**

## 8. 指令访存次数

**假定编译器将赋值语句`“x=x+3：”`转換为指令 `“add xaddr, 3”`，其中 xaddr是x 对应的存储单元地址。若执行该指令的计算机采用页式虚拟存储管理方式，并配有相应的TLB，且Cache 使用直写（Write Through）方式，则完成该指令功能需要访问主存的次数至少是**

题中说的是访问主存次数至少是多少

假定取指时该指令已经在cache中，虚拟地址转换时，对应存储单元在TLB中，所以无需访问内存。

执行写操作时，由于cache采用直写法，写cache的同时需要写入内存中保证一致性，故至少需要访存内存1次。

## 9. 存储器交叉模块访问冲突

**某计算机使用4体交叉编址存储器，假定在存储器总线上出现的主存地址（十进制）序列为8005,8006,8007,8008,8001,8002,8003,8004,8000，则可能发生访存冲突的地址对是_**

| 访存地址 | 模块序号 |
| -------- | -------- |
| 8005     | 1        |
| 8006     | 2        |
| 8007     | 3        |
| 8008     | 0        |
| 8001     | 1        |
| 8002     | 2        |
| 8003     | 3        |
| 8004     | 0        |
| 8000     | 0        |

模块序号=访存地址%存储器交叉模块数。

判断可能发生访存冲突的规则是:给定的访存地址在相邻的四次访问中出现在同一个存储模块内。据此，根据上表可知8004和8000对应的模块号都为0, 即表明这两次的访问出现在同一模块内且在相邻的访问请求中，满足发生冲突的条件

## 10. 总线定时

- [总线定时](/组成原理/chapter6#总线定时)

同步定时方式：指**系统**采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。时钟产生相等的时间间隔，每个间隔构成一个总线周期

异布通信方式中，全互锁协议最慢，因为需要双方采用握手信号，但可靠性高，非互锁协议的可靠性最差

半同步定时方式保留了同步定时的特点，如所有地址、命令、数据信号的发出时间都严格参照系统时钟的某个前沿开始，而接收方都采用系统时钟后沿时刻来进行判断识别:同时，又像异步定时那样，允许不同速度的设备和谐地工作。为此增设一条Wait 响应信号线。

## 11. 扇区存取时间（‼️）

-  [2010-磁盘](/408/2010#_22-磁盘)
-  [2013-磁盘读取时间](/408/2013#_11-磁盘读取时间-转速-%EF%B8%8F)
  

**若磁盘转速为7200rpm，平均寻道时间为8ms，每个磁道包含1000个扇区，则访问一个扇区的平均存取时间大约是_**

**存取时间 = 寻道时间 + 延迟时间 + 传输时间**

寻道时间 = 8ms

延迟时间 = 60 * 1000 / 2*7200rpm = 4.17ms


传输时间如何确定？
- 传输时间 = 所需要读写的字节数 / 每秒转数 * 每扇区的字节数
- 如果题目中给出的是读取一个扇区所需要的时间 = 磁盘转一圈的时间 / 一圈的扇区数

传输时间 = 转一圈时间 / 一圈的扇区数 = (60 * 1000 / 7200 )/ 1000 = 0.01ms

**平均存取时间 = 8ms + 4.17ms + 0.01ms = 12.18ms**


## 12. CPU与IO端口传送的信息

- [2013-IO接口](408/2013#_8-设备和控制器-io接口-之间互连的接口标准)
- [2014-IO接口](/408/2014#_12-io接口和io端口)

在采用中断 I/O方式控制打印输出的情况下，CPU 和打印控制接口中的I/O 端口之间交换的信息不可能是

主存地址

在程序中断I/0方式中，CPU和打印机直接交换，打印字符直接传输到打印机的 I/0端口，不会涉及主存地址，而 CPU和打印机通过I/0端口中状态口和控制口来实现交互。



