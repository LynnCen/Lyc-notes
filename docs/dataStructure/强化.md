# 数据结构强化

## 第一章 

**时间复杂度和空间复杂度的计算**

**时间复杂度**：一个语句在算法中被重复执行的**次数**

常见形式：

1️⃣ 阶乘n!：1*2*...*n ，时间复杂度O(n)

2️⃣ 单个循环++：O(n)

3️⃣ 单个循环i*2: O(logn)

4️⃣ 双循环i与j无关联：O(n^2)

5️⃣ 双循环i与j关联：计算总次数

无论哪种形式 穷举各层的执行次数即可


## 第二章 线性表

大题算法题的重点！首选暴力解

### 线性表（顺序表示）

线性表的数据结构定义

插入、删除和查找

位序和数组下标的区别

带头节点和不带头节点的区别

### 链式表示

单链表的定义、双链表的定义、循环单链表、循环双链表、静态链表

基本操作：插入、删除和查找


## 第三章 栈和队列

选择题和应用题

### 栈

栈的基本概念 LIFO

栈的顺序存储数据结构

栈的基本操作：

入栈先++ 再入栈

出栈先弹出栈顶元素，后--

栈满和栈空判断

共享栈（判断栈满）

栈的链式存储数据结构

### 队列 

基本概念（FIFO）

队列的顺序存储数据结构

入队：先送值到队尾元素，再将队尾指针加1 rear++

出队：先取队尾元素，再将队头指针++

判断队空和队满（什么是假溢出）

循环队列（解决假溢出）

循环队列判断队空：`Q.front == Q.rear`

循环队列判断队满的三种方式 `(Q.rear+1)% MaxSize == Q.front`

循环队列入队：`Q.rear  = (Q.rear + 1)% MaxSize`

循环队列出队：`Q.front == (Q.front + 1)% MaxSize`

队列的链式存储（带头节点和不带头节点）

双端队列

### 栈和队列的应用

栈在括号匹配中的应用

栈在表达式求值中的应用（计算栈的深度和栈中元素）

中缀转后缀、后缀表达式求值

栈在递归中的应用

队列在层次遍历中的应用

队列在计算机系统中的应用（buffer、就绪队列、阻塞队列）


## 数组和特殊矩阵

特殊矩阵的压缩存储

按行或列优先存储，计算下标（不用背公式，直接穷举），注意区分下标从0还是从1开始

三角矩阵和三对角矩阵存储

稀疏矩阵的存储：三元组（行标i，列标j，值a；还需要保存稀疏矩阵的行数、列数和非零元素的个数），十字链表存储



## 第四章 串

简单模式匹配算法 需要后退次数 时间复杂度O(mn)

KMP算法： 先计算部分比配值，再将其右移再加1，得到next数组，时间复杂度O(m+n),主串不回退

求nextval数组（复杂）如何记忆？


## 第五章 树与二叉树

考点：树的基本概念、二叉树的定义和基本特征、二叉树的顺序存储结构和链式存储结构、二叉树的遍历、线索二叉树构造、树的存储结构、森林与二叉树的转换、树和森林的遍历、树与二叉树的应用（哈夫曼树、哈夫曼编码、并查集）

### 树的基本概念

结点树n = 分支数 + 1 =  n1 + 2n2 + ... + 1  = n0 + n1 + n2 + ...

分支数 = 树中各结点的度之和

树的最大高度（满m叉树）和最小高度（上1下m）

### 二叉树的概念

满二叉树的定义、结点总数、各层的结点数

完全二叉树定义、高度、叶子结点出现的情况、

二叉排序树

平衡二叉树

正则二叉树

结点总数 = n0 + n1 + n2    n0 = n2 + 1

### 二叉树的存储结构

顺序存储：按照层次遍历的顺序依次填入，如果该节点为空则使用0补位（注意下标位置）。

链式存储（空链域的个数n+1）

### 二叉树的遍历

先序遍历（根左右）

中序遍历（左根右）

后序遍历（左右根）

层次遍历（从根开始从左至右扫描，需要使用队列）

中 + 其余三种遍历中任意一种 即可唯一确定一棵树

如果无中 则无法唯一确定一棵树

递归和非递归的转换（利用栈）


### 线索二叉树

线索二叉树的数据结构 ltag和rtag的含义 0表示孩子 1表示前驱或者后继

使用二叉树遍历算法的到遍历序列 按照序列前后关系确定线索指针


## 树和森林

### 树的存储结构

1. 双亲表示法 

数据结构定义：items：存储值的data，双亲在数组中的下标。双亲即为item[](ts);

可以很快找到一个结点的双亲，

但是求一个结点的孩子则需要遍历整个结构 ⚠️

2. 孩子表示法

数组存放所有元素item，item：存放数据data，一个链表（表示该结点的孩子）

解决双亲表示法找孩子节点需要遍历整个结构，故使用一个链表来存储孩子节点

但是找一个结点的双亲很困难，需要遍历整个结构中的链表，寻找该结点在哪个结点的孩子链表中出现过

3. 孩子兄弟表示法（二叉树表示法）

数据data，左孩子指针，右孩子指针

实现树与二叉树的转换，便于查找结点的孩子，找双亲困难


### 树、森林、二叉树的转换

左孩子右兄弟


### 森林和树的遍历

先序和二叉树相同

树的后根和二叉树的中序遍历相同

森林中和二叉的中相同

## 树和二叉树的应用

### 哈夫曼树

1. 定义

路径、路径长度、权值、带权路径长度、WPL（哈夫曼树、最优二叉树）

2. 哈夫曼树的构造

取最小的两个节点的权值相加，将相加之后的权值加入原数据，依次重复

3. 哈夫曼树的性质

1️⃣、每个结点在哈夫曼树中都是叶子结点。

2️⃣ 新增n-1个结点，哈夫曼树的总结点数为2n-1

3️⃣ 不存在度为1的结点

4. 哈夫曼编码、前缀编码

任何编码都不是另一个编码的前缀，前缀编码

左0右1活着左1右0

哈夫曼树并不唯一，但是WPL唯一

加权平均长度 = WPL / 权值之和 

### 并查集

数组下标为个结点的编号，对应的值为其双亲的下标

优化：小树合并到大树




## 第六章 图

掌握图的基本概念、存储结构、遍历、应用

### 基本概念

顶点集、边集

有向图

无向图

简单图：不存在重复的边，自己到自己（仅讨论简单图）

多重图：与简单图相反

完全图：n(n-1)/2条边（无向图）、n(n-1)条变（有向图）

子图：

连通：存在路径

极大连通子图（连通分量）

强连通图、强连通分量

生成树、生成森林

顶点的度、入度和出度：无向图的度 = 边数的*2 、 有向图的度 = 入度 + 出度

边的权值和网

稠密图和稀疏图：

路径：顶点序列

路径长度：边数

回路：


### 图的存储及基本操作

1. 邻接矩阵法

数据结构定义：边表，顶点表

顶点的度的计算：对矩阵按行遍历非0元素的个数，得到出度，按列遍历，得到入度

优点：查看两个顶点是否相联很容易O(1)`A[i][j]`

缺点：确定边的个数，需要遍历矩阵中1的个数

A^n[i][j]的含义：表示顶点i到顶点j的长度为n的路径的数目

适合稠密图

2. 邻接表法

数据结构定义：数组存储顶点表（数据、指向第一个弧的的指针），边表（链表）

适用于稀疏图

找一个点相邻的边（容易 遍历该点的邻接表）

确定两个顶点间是否存在边（遍历该点的邻接表）

求某个顶点的度 只需计算该点边表结点的个数（无向图）

对于有向图 求某个点的度 出度遍历该点的边表 入度则需要遍历整个邻接表

邻接表不唯一

3. 十字链表

有向图

解决邻接表存储有向图计算出度需要遍历整个邻接表，因此十字链表很容易求得顶点的出度和入度

数据结构：弧结点包含 弧尾 弧头 弧头相同的下一结点 弧尾相同的下一结点 

弧头相同的结点属于一个链表 弧尾相同的结点属于一个链表

十字链表表示唯一确定一个图


4. 邻接多重表

无向图

解决邻接表无向图求两个顶点间是否存在边和对边执行删除等操作时，需要分辨在两个顶点的边表中遍历

### 图的遍历

1. 广度优先遍历（BFS）

与二叉树的层序遍历一致

复杂度分析：

邻接表：空间O(V) 时间O(V+E)

邻接矩阵:空间O(V) 时间O(V^2)

广度优先生成树 唯一性的判定

2. 深度优先遍历

与二叉树的 先序遍历一致

复杂度分析：

递归栈：空间复杂度O(V)

邻接矩阵：O(V^2)

邻接表：O(V+E)

深度优先生成树和生成森领

### 图的应用

1. 最小生成树

唯一性的判断 是否有相同权值的边

Prim算法：

取相邻不重复的最小权值的边加入

时间复杂度：O(V^2) 不依赖于E 适合边稠密图

Kruskal算法：

按照权值递增次序选择合适的边来构造

时间复杂度O(ElogE)，不依赖于V，适合边稀疏而顶点多的图

2. 最短路径

Dijkstra算法求解单源最短路径：

每轮确定一个最近的点作为中转点，判断以该点到达其余点的路径是否比上一轮更小，若更小则更新。

三个辅助数组：final[]、dist[]、path[]

不适合带负权值的图

时间复杂度O(V^2)

Floyd求解各点之间的最短路径问题：

图中的各个顶点轮流称为中间结点 判断以此结点为中转到其余结点的权值是否更小 是的话就更新 否则不更新

时间复杂度O(V^3)

适合带负权值的图


3. 有向无环图描述表达式


4. 拓扑排序

AOV网（有向无环图）

是对有向无环图的一种排序，可用于判断是否存在回路

每次选择入度为0的结点，并消去与之相连的边，直到当前图中不存在无前驱的结点为止。

可利用DFS实现拓扑排序，利用结束时间从大到小排列（父结点的结束时间大于孩子结点的结束时间）

存在性和唯一性的判断：

各个点仅有唯一的前驱或后继，拓扑排序唯一，否则不唯一

邻接矩阵存储 若为三角矩阵，则存在拓扑排序，反之不一定

5. 关键路径

AOE网（带权有向无环图）

事件的最早发生时间Vk

事件的最晚发生时间V


## 第七章 查找

平均查找长度 = 查找的总次数 / 查找表的长度

### 顺序查找和折半查找

顺序查找哨兵的作用

平均查找长度和平均失败查找长度分析

折半查找的代码（熟悉掌握），模拟查找过程和查找次数（成功和失败）查找树

分块查找：先分块，块内无序（顺序查找），块间有序（第一块的最大小于第二块的所有）

### 树形查找

1. 二叉排序树

左 < 根 < 右

中序遍历为递增有序序列

二叉排序树的构造、插入和删除

删除后填补，利用中序遍历序列中删除该结点的后一个结点填补

查找效率分析

二叉排序树并不唯一

2. 平衡二叉树

左右子树高度之差（平衡因子）不超过1

插入以及调整操作过程：LL、RR、LR、RL

每次调整的都是最小不平衡子树

构造平衡二叉树的过程、删除过程以及查找过程

查找过程与二叉排序树相同

平均查找效率为树的高度（log2n）

3. B树和B+树

B树的定义和特点 

关键字个数：`[m/2]-1 <= n <= m-1`（注意区分根结点最少1）

叶子结点代表查找失败

树的高度（磁盘存取次数） 关键字最多和关键字最少树的高度推导公式

B树的插入和删除（分裂和合并策略）

B+树的定义和特点

关键字个数`[m/2] <= n <=m` (注意区分根结点最少2)

叶子结点包含全部关键字信息（非叶结点仅起索引作用）

B+树和B树的区别！

从关键字个数 根结点 叶子结点分析 关键字对应树的个数

4. 散列表（hash）

散列表的概念：散列函数、冲突、散列表

**散列函数的构造：**

直接定址法

除留余数法 选质数p

数字分析法

平方取中法

**解决冲突的方法：**

开放定址法：（H(key) + di）% m

对于增量d的取值采用以下方法：

线性探测法：1，2，... m-1，顺序的查看表中的下一个单元（存在堆积现象）

平方探测法：1^2，2^2...k^2

双散列法：第一个散列函数得到的地址发生冲突时，则利用第二个散列函数计算该关键字的地址增量。

伪随机序列法：增量为随机序列

开放定址法的删除操作采用软删除（逻辑删除）

拉链法：将产生冲突的同义词使用一个链表存储起来（适合经常插入和删除）

**散列表查找性能分析：**

查找成功 = 各关键字查找次数之和 / 关键字个数 （⚠️ 不是散列表的长度）

查找失败 = 各关键字查找失败次数之和 / 表长（要模以的数字）

⚠️：假设质数为7 那么饿只有可能在0-6 依次计算0-6间各数查找失败的情况的次数 当下一个位置为空即为查找失败

https://blog.csdn.net/cj151525/article/details/109435869

影响散列表查找效率的因素：散列函数、处理冲突的方法和装填因子

装填因子：表中记录数n / 散列表的长度m 








