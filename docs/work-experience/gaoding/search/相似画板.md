📋 一、背景与目标
1.1 业务背景
在采集详情页的推荐画板功能中，当用户点击"更多"按钮打开推荐画板弹窗（RelatedBoardsModal）后，目前只展示推荐画板数据。为了提升用户体验和内容发现能力，需要在推荐画板数据加载完毕后，自动展示相似画板推荐，让用户能够发现更多相关画板内容。
用户场景：
场景一：推荐画板 Swiper（横向滚动组件）
1. 用户在采集详情页看到推荐画板横向滚动组件（BoardSwiper）
2. 用户横向滚动浏览推荐画板，系统自动加载更多推荐画板
3. 当推荐画板数据加载完毕后（hasMore = false），系统自动触发相似画板加载
4. 相似画板数据自动追加到 swiper 中，在推荐画板和相似画板之间插入分隔卡片（显示"相似画板"标题），用户可以继续横向滚动浏览相似画板
5. 分隔卡片用于清晰区分推荐画板和相似画板数据，确保用户能够识别数据来源
场景二：推荐画板弹窗（Modal）
1. 用户点击推荐画板 swiper 的"更多"按钮，打开推荐画板弹窗（RelatedBoardsModal）
2. 弹窗中展示已加载的推荐画板和相似画板数据（数据共享自 Context）
3. 推荐画板和相似画板之间有分隔标题（显示"相似画板"），用于清晰区分两个模块
4. 用户在弹窗中浏览画板，通过滚动加载更多推荐画板
5. 当推荐画板加载完毕后，系统自动触发相似画板加载（如果 swiper 中还未加载）
6. 用户可以继续滚动加载更多相似画板
解决的问题：
● 提升内容发现能力：推荐画板用完后，自动提供相似画板推荐
● 增强用户体验：无缝衔接，无需用户额外操作
● 提高内容消费深度：让用户发现更多相关画板内容
1.2 功能需求
1.2.1 核心功能需求
1. 触发时机
    ○ 在推荐画板 Swiper 中：当推荐画板数据加载完毕（hasMore = false）时，自动触发相似画板加载
    ○ 在推荐画板弹窗中：当推荐画板数据加载完毕（hasMore = false）时，自动触发相似画板加载（如果 swiper 中还未加载）
    ○ 仅触发一次，避免重复加载
2. 展示位置
    ○ 推荐画板 Swiper：相似画板数据自动追加到 swiper 中，与推荐画板数据之间插入分隔卡片（显示"相似画板"标题），用户可以继续横向滚动浏览。分隔卡片用于区分推荐画板和相似画板数据。
    ○ 推荐画板弹窗：相似画板紧跟在推荐画板后面展示，使用分隔线和标题"相似画板"进行区分，在同一个 InfiniteScroll 容器中，使用 Masonry 瀑布流布局展示
3. 数据共享
    ○ 相似画板数据需要在 swiper 和 modal 之间共享
    ○ 避免重复请求，提升性能和用户体验
    ○ 数据管理建议放在 Context 或父组件中，确保数据一致性
4. 数据加载
    ○ 相似画板支持无限滚动加载更多
    ○ 初始加载数量：20 个（与推荐画板一致）
    ○ 后续每次加载：20 个
    ○ 最大页码限制：100 页
    ○ 接口说明：暂时使用推荐画板接口（getRelatedBoardsWeb），后续需要替换为专门的相似画板接口（TODO）
5. 交互体验
    ○ 推荐画板 Swiper：推荐画板和相似画板在同一个横向滚动容器中，中间有分隔卡片（显示"相似画板"标题），用户可以连续滚动浏览。分隔卡片用于清晰区分推荐画板和相似画板数据。
    ○ 推荐画板弹窗：推荐画板和相似画板在同一个滚动容器中，中间有分隔标题（显示"相似画板"），分隔标题清晰可见，区分两个模块
    ○ 加载状态有明确的视觉反馈
6. 数据共享机制
    ○ 相似画板数据需要在 swiper 和 modal 之间共享
    ○ 建议将相似画板数据管理提升到 Context 或父组件层级
    ○ swiper 中加载的相似画板数据，在打开 modal 时可以直接使用
    ○ modal 中加载的相似画板数据，也需要同步到 swiper（如果 swiper 还在显示）
1.2.2 非功能需求
1. 性能要求
    ○ 相似画板加载不应阻塞推荐画板的展示和交互
    ○ 初始加载时间 < 500ms
    ○ 滚动加载响应时间 < 300ms
2. 兼容性要求
    ○ 同时支持新版详情页（index@full.tsx）和旧版详情页（OldFullDetial/index@full.tsx）
    ○ 不影响现有推荐画板功能
    ○ 向后兼容，不影响已有数据流
3. 代码质量要求
    ○ 不改动现有推荐画板逻辑（成本控制）
    ○ 增量添加相似画板功能
    ○ 代码复用现有组件和工具函数
    ○ 遵循现有代码规范和架构设计
1.2.3 边界情况
1. 数据为空
    ○ 如果相似画板接口返回空数据，不展示分隔标题和相似画板区域
    ○ 不影响推荐画板的正常展示
    ○ swiper 和 modal 中都不展示相似画板
2. 加载失败
    ○ 相似画板加载失败时，静默失败，不影响推荐画板展示
    ○ 记录错误日志，便于排查问题
    ○ swiper 和 modal 中都不展示相似画板
3. 数据同步
    ○ swiper 中加载的相似画板数据，在打开 modal 时可以直接使用（数据共享）
    ○ modal 中加载的相似画板数据，如果 swiper 还在显示，需要同步更新（数据共享）
    ○ 确保 swiper 和 modal 中的数据一致性
4. 弹窗关闭
    ○ 弹窗关闭时，不重置相似画板状态（数据保留在 Context 中）
    ○ 下次打开弹窗时，直接使用已加载的相似画板数据
    ○ 如果相似画板还未加载，则触发加载逻辑
5. pinId 变化
    ○ 当 pinId 变化时，重置相似画板状态（在 Context 中重置）
    ○ 重新触发推荐画板加载，然后触发相似画板加载
    ○ 确保新 pinId 的数据不会与旧数据混淆
1.3 技术目标
1. 最小改动原则
    ○ 不改动现有推荐画板相关代码
    ○ 在 BoardSwiper 和 RelatedBoardsModal 组件中增量添加相似画板功能
    ○ 复用现有的数据加载、状态管理、UI 组件
2. 代码复用
    ○ 复用 Masonry 瀑布流布局组件
    ○ 复用 BoardCardNew 画板卡片组件
    ○ 复用 InfiniteScroll 无限滚动组件
    ○ 复用 BoardSwiper 横向滚动组件
    ○ 复用现有的 API 调用模式
3. 状态管理
    ○ 相似画板状态需要在 swiper 和 modal 之间共享
    ○ 建议将相似画板数据管理提升到 PinDetailContext 中，与推荐画板数据管理方式一致
    ○ 使用 React Hooks 进行状态管理
    ○ 合理使用 useMemo 和 useCallback 优化性能
    ○ 确保数据同步，避免重复请求

🎯 二、技术方案
2.1 技术选型
技术点
选型
理由
状态管理
useRequest (来自 @/utils/useReq)
与推荐画板保持一致，复用现有 hook，简化状态管理
API 调用
复用现有 services 层
保持代码一致性，复用现有错误处理
UI 组件
复用现有 Masonry、BoardCardNew、InfiniteScroll
保持视觉一致性，减少开发成本
样式方案
CSS Modules (index.module.less)
与现有组件样式方案保持一致
2.2 架构设计
PinDetailContext (数据共享层)
├── 推荐画板数据管理
│   ├── boards (推荐画板列表)
│   ├── page (当前页码)
│   ├── hasMore (是否还有更多)
│   └── loading (加载状态)
│
└── 相似画板数据管理（新增，使用 useRequest）
    ├── similarBoardsList (useRequest 返回的数据)
    │   ├── data.boards (相似画板列表)
    │   ├── loading (加载状态)
    │   └── error (错误信息)
    ├── shouldLoadSimilarBoards (是否应该加载相似画板)
    ├── similarBoardsPage (当前页码)
    ├── loadMoreSimilarBoards (加载更多方法)
    └── resetSimilarBoards (重置方法)

BoardSwiper (横向滚动组件)
├── 从 Context 获取推荐画板数据
├── 从 Context 获取相似画板数据
├── 分开渲染：
│   ├── 先渲染推荐画板卡片
│   ├── 然后渲染分隔卡片（如果有相似画板）
│   └── 最后渲染相似画板卡片
└── 横向滚动展示，分隔卡片清晰可见

RelatedBoardsModal (弹窗组件)
├── 从 Context 获取推荐画板数据
├── 从 Context 获取相似画板数据
├── 分开渲染：
│   ├── 先渲染推荐画板（使用 Masonry）
│   ├── 然后渲染分隔标题（如果有相似画板）
│   └── 最后渲染相似画板（使用 Masonry）
└── 使用 Masonry 瀑布流布局展示

数据流：
场景一：推荐画板 Swiper
1. 用户浏览推荐画板 swiper → 展示推荐画板数据
2. 用户横向滚动 → 触发推荐画板加载更多
3. 推荐画板 hasMore = false → 自动触发相似画板首次加载
4. 相似画板数据加载完成后，在推荐画板后面渲染分隔卡片和相似画板 → 用户可以继续横向滚动浏览相似画板
5. 用户继续横向滚动 → 触发相似画板加载更多
场景二：推荐画板弹窗
1. 用户点击"更多"按钮 → 打开弹窗，展示已加载的推荐画板和相似画板数据（共享自 Context）
2. 弹窗中分开渲染：先渲染推荐画板，然后渲染分隔标题，最后渲染相似画板
3. 用户滚动 → 触发推荐画板加载更多（如果还有）
4. 推荐画板 hasMore = false → 自动触发相似画板首次加载（如果 swiper 中还未加载）
5. 用户继续滚动 → 触发相似画板加载更多
6. 相似画板 hasMore = false → 显示"已经看到最后了"
2.3 核心实现
2.3.1 相似画板状态管理（在 PinDetailContext 中，使用 useRequest）
```tsx
// 在 PinDetailContext 中新增相似画板状态管理，使用 useRequest hook
import useRequest from "@/utils/useReq";

// 在 PinDetailProvider 中使用 useRequest 管理相似画板数据
const similarBoardsList = useRequest(
  async () => {
    if (!pinId) {

      return { boards: [] };

    }

    // 仅在推荐画板加载完毕后触发（通过依赖控制）
    if (!shouldLoadSimilarBoards) {

      return { boards: [] };

    }

    const data = await getSimilarBoardsWeb({
      pin_id: pinId,
      limit: 20,
      page: similarBoardsPage,
    });


    return data || { boards: [] };

  },
  {
    refreshDeps: [pinId, shouldLoadSimilarBoards, similarBoardsPage],
    ready: !!pinId && shouldLoadSimilarBoards, // 仅在推荐画板加载完毕后触发
  }
);

// 在 Context 中暴露相似画板数据和方法
interface PinDetailContextValue {
  // ... 现有字段
  similarBoardsList: {

    data: { boards: `IBoardInfo[]` };

    loading: boolean;
    error: Error | null;
  };
  loadMoreSimilarBoards: () => void; // 加载更多方法
  resetSimilarBoards: () => void; // 重置方法
}

2.3.2 自动触发相似画板加载（在 Context 中，通过 useRequest 依赖控制）
// 在 PinDetailContext 中，通过 shouldLoadSimilarBoards 控制 useRequest 的触发
const [shouldLoadSimilarBoards, setShouldLoadSimilarBoards] = useState(false);
const [similarBoardsPage, setSimilarBoardsPage] = useState(1);

// 监听推荐画板完成，设置 shouldLoadSimilarBoards 为 true
useEffect(() => {
  if (
    pinId &&
    !recommendedBoards.hasMore && // 推荐画板已加载完毕
    !recommendedBoards.loading && // 推荐画板不在加载中
    !shouldLoadSimilarBoards // 还未触发过相似画板加载
  ) {
    setShouldLoadSimilarBoards(true);
  }
}, [
  pinId,
  recommendedBoards.hasMore,
  recommendedBoards.loading,
  shouldLoadSimilarBoards,
]);

// 使用 useRequest 管理相似画板数据，通过 ready 和 refreshDeps 控制触发时机
// TODO: 后续需要替换为专门的相似画板接口 getSimilarBoardsWeb
// 暂时使用推荐画板接口 getRelatedBoardsWeb，因为数据结构一致
const similarBoardsList = useRequest(
  async () => {
    if (!pinId) {

      return { boards: [] };

    }

    // TODO: 替换为 getSimilarBoardsWeb 接口
    const data = await getRelatedBoardsWeb({
      pin_id: pinId,
      limit: 20, // 每次加载 20 个
      page: similarBoardsPage,
    });


    return data || { boards: [] };

  },
  {
    refreshDeps: [pinId, shouldLoadSimilarBoards, similarBoardsPage],
    ready: !!pinId && shouldLoadSimilarBoards, // 仅在推荐画板加载完毕后触发
  }
);

2.3.3 相似画板加载更多逻辑（在 Context 中）
// 在 PinDetailContext 中实现相似画板加载更多逻辑
// TODO: 后续需要替换为专门的相似画板接口 getSimilarBoardsWeb
const loadMoreSimilarBoards = useCallback(() => {
  if (
    similarBoardsList.loading || // 正在加载中
    !pinId ||
    similarBoardsPage >= 100 || // 最大页码限制
    (similarBoardsList?.data?.boards?.length === 0 && similarBoardsPage > 1) // 已无更多数据
  ) {
    return;
  }

  // 通过更新 similarBoardsPage 触发 useRequest 重新执行
  setSimilarBoardsPage((prev) => prev + 1);
}, [
  similarBoardsList.loading,
  similarBoardsList?.data?.boards?.length,
  pinId,
  similarBoardsPage,
]);

// 重置相似画板状态
const resetSimilarBoards = useCallback(() => {
  setShouldLoadSimilarBoards(false);
  setSimilarBoardsPage(1);

}, []);
```

2.3.4 BoardSwiper 中的分开渲染（推荐画板和相似画板分开）
```tsx
// 在 BoardSwiper 组件中，从 Context 获取数据，分开渲染推荐画板和相似画板
function BoardSwiper({ ...props }) {
  const { recommendedBoards, similarBoardsList, loadMoreSimilarBoards } =
    usePinDetailContext();

  // 推荐画板数据（如果有所在画板，添加到第一位）
  const recommendedDisplayData = useMemo(() => {
    const boards = [...recommendedBoards.boards];
    if (currentPin?.board) {
      return [currentPin.board, ...boards];
    }
    return boards;
  }, [recommendedBoards.boards, currentPin?.board]);

  // 相似画板数据
  const similarDisplayData = useMemo(() => {

    return similarBoardsList?.data?.boards || [];

  }, [similarBoardsList?.data?.boards]);

  // 处理加载更多：优先加载推荐画板，推荐画板用完后加载相似画板
  const handleLoadMore = useCallback(async () => {
    if (recommendedBoards.hasMore) {
      await recommendedBoards.loadMore(20);
    } else if (similarBoardsList?.data?.boards?.length > 0) {
      // 触发相似画板加载更多
      loadMoreSimilarBoards();
    }
  }, [recommendedBoards, similarBoardsList, loadMoreSimilarBoards]);

  // 分开渲染：先渲染推荐画板，然后渲染分隔卡片，最后渲染相似画板
  return (
    <HBSwiper>
      {/* 渲染推荐画板 */}
      {recommendedDisplayData.map((board, index) => {
        const isCurrentBoard =
          index === 0 && board?.board_id === currentPin?.board?.board_id;
        return (
          <div
            key={`recommended-${stackIndex}-${board?.board_id || index}`}
            className={styles.boardSwiperCard}
          >
            <BoardCardNew
              record={board}
              hideButton={true}
              hideUser={true}
              location={index + 1}
              viewSource={isCurrentBoard ? pinId : undefined}
              stackIndex={stackIndex}
              searchWord={searchWord}
              isCurrentBoard={isCurrentBoard}
            />
          </div>
        );
      })}

      {/* 如果有相似画板，渲染分隔卡片 */}
      {similarDisplayData.length > 0 && (
        <div key="similar-boards-separator" className={styles.separatorCard}>
          <div className={styles.separatorTitle}>相似画板</div>
        </div>
      )}

      {/* 渲染相似画板 */}
      {similarDisplayData.map((board, index) => {
        return (
          <div
            key={`similar-${stackIndex}-${board?.board_id || index}`}
            className={styles.boardSwiperCard}
          >
            <BoardCardNew
              record={board}
              hideButton={true}
              hideUser={true}
              location={recommendedDisplayData.length + index + 1}
              stackIndex={stackIndex}
              searchWord={searchWord}
            />
          </div>
        );
      })}
    </HBSwiper>
  );
}
```

2.3.5 RelatedBoardsModal 中的分开渲染（推荐画板和相似画板分开）
```tsx
// 在 RelatedBoardsModal 组件中，从 Context 获取数据，分开渲染推荐画板和相似画板
function RelatedBoardsModal({ ...props }) {
  const { recommendedBoards, similarBoardsList, loadMoreSimilarBoards } =
    usePinDetailContext();

  // 推荐画板数据
  const recommendedBoardsData = useMemo(() => {
    return [...recommendedBoards.boards];
  }, [recommendedBoards.boards]);

  // 相似画板数据
  const similarBoardsData = useMemo(() => {

    return similarBoardsList?.data?.boards || [];

  }, [similarBoardsList?.data?.boards]);

  // 处理加载更多：优先加载推荐画板，推荐画板用完后加载相似画板
  const handleLoadMore = useCallback(async () => {
    if (recommendedBoards.hasMore) {
      await recommendedBoards.loadMore(20);
    } else if (similarBoardsList?.data?.boards?.length > 0) {
      // 触发相似画板加载更多
      loadMoreSimilarBoards();
    }
  }, [recommendedBoards, similarBoardsList, loadMoreSimilarBoards]);

  // 渲染画板卡片（处理分隔标题）
  const renderBoardCard = useCallback(
    (board: any, index: number) => {
      const isCurrentBoard =
        index === 0 && board?.board_id === currentPin?.board?.board_id;
      return (
        <BoardCardNew
          key={board?.board_id || index}
          record={board}
          hideButton={true}
          hideUser={true}
          location={index + 1}
          viewSource={isCurrentBoard ? pinId : undefined}
          stackIndex={stackIndex}
          searchWord={searchWord}
          isCurrentBoard={isCurrentBoard}
        />
      );
    },
    [pinId, stackIndex, searchWord, currentPin]
  );

  // 合并数据用于 Masonry 布局，但添加 source 字段标识来源
  const allBoardsForMasonry = useMemo(() => {

    const boards: `any[]` = [];


    // 添加推荐画板，标记来源
    recommendedBoardsData.forEach((board) => {
      boards.push({
        ...board,
        _source: "recommended", // 标识为推荐画板
      });
    });

    // 添加相似画板，标记来源
    similarBoardsData.forEach((board) => {
      boards.push({
        ...board,
        _source: "similar", // 标识为相似画板
      });
    });

    return boards;
  }, [recommendedBoardsData, similarBoardsData]);

  // 渲染画板卡片，处理分隔标题
  const renderBoardCard = useCallback(
    (board: any, index: number) => {
      // 如果是第一个相似画板，先渲染分隔标题
      const isFirstSimilarBoard =
        board._source === "similar" &&
        (index === 0 ||
          allBoardsForMasonry[index - 1]?._source === "recommended");

      const isCurrentBoard =
        index === 0 && board?.board_id === currentPin?.board?.board_id;

      return (
        <>
          {/* 如果是第一个相似画板，渲染分隔标题 */}
          {isFirstSimilarBoard && (
            <div className={styles.separator}>
              <div className={styles.separatorTitle}>相似画板</div>
            </div>
          )}

          {/* 渲染画板卡片 */}
          <BoardCardNew
            key={board?.board_id || index}
            record={board}
            hideButton={true}
            hideUser={true}
            location={index + 1}
            viewSource={isCurrentBoard ? pinId : undefined}
            stackIndex={stackIndex}
            searchWord={searchWord}
            isCurrentBoard={isCurrentBoard}
          />
        </>
      );
    },
    [pinId, stackIndex, searchWord, currentPin, allBoardsForMasonry]
  );

  // 分开渲染：使用一个 Masonry 组件，但在 render 函数中处理分隔标题
  return (
    <InfiniteScroll
      dataLength={allBoardsForMasonry.length}
      hasMore={
        recommendedBoards.hasMore ||
        (similarBoardsList?.data?.boards?.length > 0 &&
          !similarBoardsList.loading)
      }
      next={handleLoadMore}
      // ... 其他 props
    >
      <div className={styles.masonryWrapper}>
        <Masonry
          bricks={allBoardsForMasonry}
          brickId="board_id"
          render={renderBoardCard}
          // ... 其他 props
        />
      </div>
    </InfiniteScroll>
  );
}
```

📦 三、文件结构
[修改的文件]
├── components/
│   └── PinDetail/
│       ├── Full/
│       │   └── PinDetailContext.tsx (修改：新增相似画板数据管理，使用 useRequest)
│       ├── BoardSwiper/
│       │   ├── index.tsx (修改：新增相似画板展示逻辑，插入分隔卡片)
│       │   └── index.module.less (修改：新增分隔卡片样式)
│       └── RelatedBoardsModal/
│           ├── index.tsx (修改：新增相似画板功能)
│           └── index.module.less (修改：新增分隔标题样式)

[新增的文件]
├── services/
│   └── pin.js (修改：新增 getSimilarBoardsWeb API 接口)


⚠️ 四、风险评估与应对
风险点
影响程度
应对方案
API 接口未就绪
高
提前与后端确认接口规范，使用 Mock 数据先行开发
相似画板数据为空
中
静默处理，不展示分隔标题和相似画板区域
加载性能问题
中
使用防抖、节流，合理使用 useMemo 和 useCallback
状态管理混乱
中
相似画板状态独立管理，与推荐画板状态隔离
兼容性问题
低
增量添加，不影响现有功能，充分测试

📊 五、性能考虑
5.1 性能指标
● 相似画板初始加载时间：< 500ms
● 滚动加载响应时间：< 300ms
● 内存占用：合理控制，避免内存泄漏
5.2 优化措施
1. 代码优化
    ○ 使用 useMemo 缓存合并后的数据列表
    ○ 使用 useCallback 缓存回调函数
    ○ 避免不必要的重新渲染
2. 加载优化
    ○ 仅在推荐画板加载完毕后触发相似画板加载
    ○ 使用防抖避免频繁请求
    ○ 合理设置 scrollThreshold，避免过早触发加载
3. 渲染优化
    ○ 使用 Masonry 虚拟滚动，只渲染可见区域
    ○ 分隔标题使用轻量级 DOM 结构
    ○ 避免在渲染函数中进行复杂计算

📈 六、埋点方案
6.1 埋点类型
埋点类型
触发时机
事件 ID/事件名

说明
曝光埋点
相似画板首次加载完成
content_expose

曝光相似画板模块
点击埋点
点击相似画板卡片
button_click

点击相似画板卡片
加载埋点
相似画板加载更多
custom_event

记录加载更多行为
6.2 埋点实现方式
6.2.1 自动埋点
```tsx
// 相似画板分隔标题曝光埋点
<div
  className={styles.separator}
  data-gd-expose="content_expose"
  data-content-type="similar_boards_separator"
  data-module-name="相似画板"
>
  <div className={styles.separatorTitle}>相似画板</div>
</div>

// 相似画板卡片点击埋点（在 BoardCardNew 组件中已实现）
<BoardCardNew
  data-gd-click="button_click"
  data-button-name="相似画板卡片"
  data-module-name="相似画板"
  // ...其他 props
/>
```

6.2.2 手动埋点
```tsx
import reporter from "@/tracker/report/reporter";

// 相似画板加载更多埋点
const loadSimilarBoards = useCallback(
  async () => {
    // ...加载逻辑

    // 记录加载更多行为
    if (newBoards.length > 0) {
      reporter({
        event_name: "similar_boards_load_more",
        page_nm: "采集详情页",
        sub_page_nm: "推荐画板弹窗",
        module_name: "相似画板",
        page: similarBoardsPage,
        count: newBoards.length,
      });
    }
  },
  [
    /* ... */
  ]
);
```

6.3 埋点参数说明
参数名
类型
必填
说明
示例
event_name
string
是
事件名称
"button_click"
page_nm
string
是
页面名称
"采集详情页"
sub_page_nm
string
是
子页面名称
"推荐画板弹窗"
module_name
string
是
模块名称
"相似画板"
content_id
string
否
内容 ID
"123456"
board_id
string
否
画板 ID
"789012"
location
number
否
位置索引
1
page
number
否
当前页码
2
count
number
否
加载数量
20
6.4 埋点验证
● 开发环境：URL 添加 __tracker_log=1 参数查看埋点日志
● 测试环境：通过埋点平台查看上报数据
● 生产环境：通过数据分析平台验证

🧪 七、测试方案
7.1 测试范围
1. 功能测试
    ○ 推荐画板加载完毕后，自动触发相似画板加载
    ○ Swiper 中：相似画板正常展示，分隔卡片清晰可见，能够区分推荐画板和相似画板
    ○ Modal 中：相似画板正常展示，分隔标题清晰可见，能够区分推荐画板和相似画板
    ○ 相似画板支持无限滚动加载更多
    ○ 数据为空时的处理
    ○ 加载失败时的处理
2. 兼容性测试
    ○ 新版详情页（index@full.tsx）
    ○ 旧版详情页（OldFullDetial/index@full.tsx）
    ○ 不同浏览器（Chrome、Safari、Firefox、Edge）
    ○ 不同屏幕尺寸（桌面端、平板、移动端）
3. 性能测试
    ○ 初始加载时间
    ○ 滚动加载响应时间
    ○ 内存占用情况
    ○ 长时间滚动后的性能表现
7.2 测试用例
用例编号
测试场景
预期结果
推荐画板 Swiper 测试


TC001
在 swiper 中横向滚动，推荐画板加载完毕后
自动触发相似画板加载，相似画板数据追加到 swiper 中，中间有分隔卡片（显示"相似画板"标题）
TC002
swiper 中相似画板加载完成后，继续横向滚动
触发相似画板加载更多，正常展示新数据，分隔卡片始终在推荐画板和相似画板之间
TC003
swiper 中相似画板数据为空
不展示相似画板和分隔卡片，只展示推荐画板
TC004
swiper 中相似画板加载失败
静默失败，不影响推荐画板展示，不展示分隔卡片和相似画板
推荐画板弹窗测试


TC005
打开推荐画板弹窗，推荐画板加载完毕后
自动触发相似画板加载（如果 swiper 中还未加载），展示分隔标题和相似画板
TC006
弹窗中相似画板加载完成后，继续滚动
触发相似画板加载更多，正常展示新数据
TC007
弹窗中相似画板数据为空
不展示分隔标题和相似画板区域
TC008
弹窗中相似画板加载失败
静默失败，不影响推荐画板展示
数据共享测试


TC009
在 swiper 中加载相似画板后，打开弹窗
弹窗中直接展示已加载的相似画板数据（数据共享）
TC010
在弹窗中加载相似画板后，swiper 还在显示
swiper 中同步更新相似画板数据（数据共享）
TC011
关闭弹窗后重新打开
直接使用已加载的相似画板数据（如果已加载），不重复请求
边界情况测试


TC012
切换不同的 pinId
重置相似画板状态，重新触发推荐画板加载，然后触发相似画板加载
TC013
推荐画板数据为空
不触发相似画板加载
TC014
推荐画板加载失败
不触发相似画板加载

📅 八、排期计划
阶段
内容
工期
负责人
开发
API 接口对接、相似画板功能开发
2 天
前端开发
测试
功能测试、兼容性测试、性能测试
1 天
QA
上线
灰度发布、全量发布
1 天
前端开发

📝 九、后续优化
1. 性能优化
    ○ 考虑使用虚拟滚动优化大量数据渲染
    ○ 优化图片加载策略，使用懒加载
2. 功能增强
    ○ 支持相似画板的筛选和排序
    ○ 支持相似画板的收藏和分享
3. 用户体验优化
    ○ 添加加载动画和过渡效果
    ○ 优化分隔标题的视觉设计

🔗 十、参考资料
● 推荐画板功能技术文档（待补充）
● RelatedBoardsModal 组件代码：apps/huaban/components/PinDetail/RelatedBoardsModal/index.tsx
● BoardCardNew 组件代码：apps/huaban/components/PinDetail/BoardCardNew/index.tsx
● API 接口文档（待补充）

❓ 待确认问题
1. API 接口
    ○ ✅ 已确认：暂时使用推荐画板接口（getRelatedBoardsWeb），数据结构一致
    ○ ⚠️ TODO：后续需要实现专门的相似画板接口 getSimilarBoardsWeb
    ○ 接口参数格式与推荐画板一致（{ pin_id, limit, page }）
    ○ 返回数据格式与推荐画板一致（
    ☐ }）
2. 数据量
    ○ ✅ 已确认：初始加载数量：20 个
    ○ ✅ 已确认：后续每次加载数量：20 个
3. 样式设计
    ○ Swiper 中的分隔卡片：✅ 已确认 - 参考 Figma 设计稿中的选中元素样式（需要查看当前 Figma 选中元素）
    ○ Modal 中的分隔标题：分隔标题的具体样式要求？（间距、颜色、字体大小等）
    ○ 是否需要分隔线？（建议：需要，视觉区分更清晰）
4. 埋点需求
    ○ 是否需要额外的埋点需求？
    ○ 埋点参数是否需要调整？