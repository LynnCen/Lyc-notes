# 软件测试

> 软件测试是通过执行软件发现程序中的错误和缺陷，衡量软件质量的过程。

---

## 一、软件测试基础

### 1.1 定义与目的

**定义**：评价程序或系统的属性或能力，确定是否达到预期结果的过程

**核心目的**：
- 尽可能早地发现软件中的错误和缺陷
- 为软件质量提供保证

### 1.2 测试原则

| 原则 | 说明 |
|------|------|
| 尽早持续测试 | 缺陷发现越早，修复成本越低 |
| 避免测试自己的程序 | 开发者难以发现自己代码的问题 |
| 覆盖有效和无效输入 | 测试正常情况和异常情况 |
| 修改后回归测试 | 确保修改没有引入新问题 |
| 缺陷集中性 | 80%缺陷集中在20%模块（Pareto原则） |
| 不能证明无缺陷 | 测试只能证明存在缺陷，不能证明没有缺陷 |
| 杀虫剂悖论 | 同样的测试用例反复执行将不再发现新缺陷 |

---

## 二、测试级别

### 2.1 测试级别划分

| 级别 | 测试对象 | 测试目的 | 执行者 |
|------|----------|----------|--------|
| **单元测试** | 最小可测试单元（函数、方法、类） | 验证单元正确性 | 开发人员 |
| **集成测试** | 模块组合 | 检查模块接口和协同工作 | 开发/测试人员 |
| **系统测试** | 整个系统 | 验证系统满足需求规格 | 测试团队 |
| **验收测试** | 完整产品 | 确认满足用户需求 | 用户/客户 |

### 2.2 各级别详解

#### 单元测试

**特点**：
- 最低级别测试
- 与其他部分隔离进行
- 通常使用白盒测试技术

**测试内容**：
- 模块接口
- 局部数据结构
- 边界条件
- 独立路径
- 错误处理

#### 集成测试

**策略**：

| 策略 | 说明 | 优点 | 缺点 |
|------|------|------|------|
| 大爆炸 | 所有模块一次性集成 | 简单快速 | 难以定位问题 |
| 自顶向下 | 从主模块开始，逐步集成 | 早期验证架构 | 需要桩模块 |
| 自底向上 | 从底层模块开始 | 不需要桩模块 | 需要驱动模块 |
| 三明治 | 结合自顶向下和自底向上 | 兼顾优点 | 较复杂 |

#### 系统测试

**测试类型**：
- 功能测试
- 性能测试
- 安全测试
- 兼容性测试
- 易用性测试

#### 验收测试

**类型**：
- **Alpha测试**：在开发环境下由用户进行
- **Beta测试**：在用户实际环境下由用户进行

### 2.3 与V模型的对应关系

```
需求分析  ←————————————→  验收测试
    ↓                        ↑
概要设计  ←————————————→  系统测试
    ↓                        ↑
详细设计  ←————————————→  集成测试
    ↓                        ↑
   编码   ←————————————→  单元测试
```

---

## 三、黑盒测试

### 3.1 概述

**定义**：不关心内部结构，只根据需求规格设计测试用例

**别名**：功能测试、数据驱动测试

### 3.2 等价类划分法

**定义**：将输入域划分为若干等价类，从每类选取代表性数据测试

**等价类类型**：
- **有效等价类**：符合规格说明的合理输入
- **无效等价类**：不符合规格说明的非法输入

**步骤**：
1. 分析输入条件
2. 划分等价类
3. 为每个等价类选取测试数据

**示例**：
```
需求：输入年龄（1-150的整数）

有效等价类：1 ≤ 年龄 ≤ 150
无效等价类：年龄 < 1
            年龄 > 150
            非整数
            空值

测试用例：
- 有效：25（代表正常年龄）
- 无效：0, -1, 151, 200, 3.5, 空
```

### 3.3 边界值分析法

**定义**：着重测试等价类边界上的值

**原理**：大量错误发生在输入或输出范围的边界

**边界值选取**：

| 边界类型 | 选取值 |
|----------|--------|
| 上点 | 边界值本身 |
| 离点 | 刚好超出边界的值 |
| 内点 | 边界内的任意值 |

**示例**：
```
需求：输入1-100的整数

边界值测试用例：
- 下边界：0, 1, 2
- 上边界：99, 100, 101
```

### 3.4 决策表法

**定义**：分析多个输入条件组合与对应操作的关系

**结构**：
```
┌─────────────┬────┬────┬────┬────┐
│   条件桩    │ 规则1│ 规则2│ 规则3│ 规则4│
├─────────────┼────┼────┼────┼────┤
│ 条件1       │  Y │  Y │  N │  N │
│ 条件2       │  Y │  N │  Y │  N │
├─────────────┼────┼────┼────┼────┤
│   动作桩    │    │    │    │    │
├─────────────┼────┼────┼────┼────┤
│ 动作1       │  X │    │  X │    │
│ 动作2       │    │  X │    │  X │
└─────────────┴────┴────┴────┴────┘
```

**适用场景**：输入条件组合影响输出的情况

### 3.5 因果图法

**定义**：分析输入条件之间的因果关系，转换为决策表

**步骤**：
1. 找出原因（输入）和结果（输出）
2. 画出因果图
3. 标明约束关系
4. 转换为决策表
5. 设计测试用例

### 3.6 错误推测法

**定义**：基于经验推测可能存在的错误，设计测试用例

**常见错误点**：
- 空值处理
- 边界条件
- 特殊字符
- 并发操作
- 资源耗尽

---

## 四、白盒测试

### 4.1 概述

**定义**：了解内部结构，根据程序逻辑设计测试用例

**别名**：结构测试、逻辑驱动测试、基于代码的测试

### 4.2 逻辑覆盖标准

#### 覆盖强度（由弱到强）

```
语句覆盖 < 判定覆盖 < 条件覆盖 < 判定/条件覆盖 < 条件组合覆盖 < 路径覆盖
```

#### 各覆盖标准详解

| 覆盖标准 | 定义 | 要求 |
|----------|------|------|
| **语句覆盖** | 每个可执行语句至少执行一次 | 最弱覆盖 |
| **判定覆盖** | 每个判定的真假分支至少执行一次 | 又称分支覆盖 |
| **条件覆盖** | 每个判定中每个条件的真假取值至少执行一次 | 关注条件本身 |
| **判定/条件覆盖** | 同时满足判定覆盖和条件覆盖 | 结合两者 |
| **条件组合覆盖** | 每个判定中所有条件取值组合至少执行一次 | 较强覆盖 |
| **路径覆盖** | 所有可能的执行路径至少执行一次 | 最强覆盖 |

#### 示例分析

```c
if (A && B) {
    语句1;
} else {
    语句2;
}
```

**语句覆盖**：执行语句1和语句2各一次
- 用例1：A=true, B=true → 语句1
- 用例2：A=false, B=false → 语句2

**判定覆盖**：判定为真和假各一次
- 用例1：A=true, B=true → 判定为真
- 用例2：A=false, B=false → 判定为假

**条件覆盖**：A和B的真假各出现一次
- 用例1：A=true, B=false
- 用例2：A=false, B=true

**条件组合覆盖**：A和B的所有组合
- 用例1：A=true, B=true
- 用例2：A=true, B=false
- 用例3：A=false, B=true
- 用例4：A=false, B=false

### 4.3 MC/DC覆盖

**Modified Condition/Decision Coverage**

**定义**：每个条件独立地影响判定结果

**要求**：当其他条件不变时，该条件的变化导致判定结果变化

**示例**：
```
判定：A && B

需要证明A独立影响结果：
- B=true, A=true → true
- B=true, A=false → false

需要证明B独立影响结果：
- A=true, B=true → true
- A=true, B=false → false
```

### 4.4 基本路径测试法

**定义**：基于程序控制流图，设计覆盖所有独立路径的测试用例

#### 步骤

1. **绘制控制流图**
2. **计算环路复杂度**
3. **确定独立路径**
4. **设计测试用例**

#### 环路复杂度（圈复杂度）计算

**方法一**：V(G) = E - N + 2

其中：E = 边数，N = 节点数

**方法二**：V(G) = P + 1

其中：P = 判定节点数

**方法三**：V(G) = 区域数

（包括图形外的无限区域）

#### 示例

```
程序代码：
1. if (a > 0)
2.     x = 1;
3. else
4.     x = 2;
5. if (b > 0)
6.     y = 1;
7. print(x + y);

控制流图：
    ①
   / \
  ②   ③
   \ /
    ④
   / \
  ⑤   ⑥
   \ /
    ⑦

计算：
- 边数 E = 8
- 节点数 N = 7
- V(G) = 8 - 7 + 2 = 3

独立路径数 = 3
```

---

## 五、其他测试类型

| 测试类型 | 目的 |
|----------|------|
| **回归测试** | 修改后验证没有引入新问题 |
| **性能测试** | 评估响应速度、吞吐量、稳定性 |
| **安全测试** | 检查安全漏洞 |
| **兼容性测试** | 测试不同环境下的运行情况 |
| **易用性测试** | 评估用户体验 |
| **冒烟测试** | 快速验证核心功能 |

---

## 六、逻辑覆盖对比总结

| 覆盖方法 | 定义 | 覆盖强度 | 特点 |
|----------|------|----------|------|
| 语句覆盖 | 每条语句执行一次 | 最弱 | 不能发现分支错误 |
| 判定覆盖 | 每个判定真假各一次 | 弱 | 不能保证条件覆盖 |
| 条件覆盖 | 每个条件真假各一次 | 中 | 不能保证判定覆盖 |
| 判定/条件 | 同时满足两者 | 中强 | 未考虑条件组合 |
| 条件组合 | 所有条件组合 | 强 | 用例数可能很多 |
| 路径覆盖 | 所有路径 | 最强 | 实践中难以完全覆盖 |

---

## 七、考试要点

### 高频考点

1. **逻辑覆盖强度排序**
2. **环路复杂度计算**
3. **等价类和边界值分析**
4. **测试级别与V模型对应**
5. **黑盒白盒方法区分**

### 典型例题

**题1**：以下哪种覆盖强度最高？
A. 语句覆盖  B. 判定覆盖  C. 条件覆盖  D. 路径覆盖

**答案**：D

**题2**：某程序有5条边、4个节点，其环路复杂度为？

**答案**：V(G) = 5 - 4 + 2 = 3

**题3**：某输入范围为1-100，应选择哪些边界值测试？

**答案**：0, 1, 2, 99, 100, 101

### 记忆口诀

```
语判条件判条组合路径全
覆盖强度依次增加记心间
等价划分分有效，边界值分析在边沿
圈复杂度边减点加二，独立路径要走完
```
