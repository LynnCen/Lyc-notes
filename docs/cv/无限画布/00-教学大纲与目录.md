# 无限画布技术深度解析 - 教学大纲

> 本系列文档旨在系统性地讲解无限画布（Infinite Canvas）的设计理念、核心架构和实现细节，帮助读者从零开始理解并掌握这一复杂的图形编辑器核心技术。

---

## 📚 系列文档结构

```
无限画布/
├── 00-教学大纲与目录.md           ← 当前文档
├── 01-代码路径与模块映射.md        ← 功能-代码对照表
├── 02-基础概念与技术选型.md        ← 入门必读
├── 03-坐标系统与矩阵变换.md        ← 数学基础
├── 04-Surface画布表面层.md        ← 核心架构
├── 05-Viewport视口管理.md         ← 视口控制
├── 06-VmEngine视图模型引擎.md     ← 渲染核心
├── 07-元素生命周期与渲染.md        ← 元素渲染
├── 08-事件系统与碰撞检测.md        ← 交互系统
├── 09-插件系统架构.md              ← 扩展机制
├── 10-性能优化策略.md              ← 性能调优
├── 11-PixiJS与WebGL基础.md        ← 附录-渲染引擎
└── 12-常见问题与最佳实践.md        ← 附录-FAQ
```

---

## 📖 第一部分：基础概念篇

### 第1章：基础概念与技术选型

**核心问题**：为什么需要无限画布？与传统 DOM 渲染有什么区别？

**内容要点**：
- 1.1 什么是无限画布
  - 定义与特征
  - 应用场景（Figma、Miro、Canva、稿定设计）
  - 与传统 DOM 方案的对比
- 1.2 技术选型分析
  - Canvas 2D vs WebGL vs SVG
  - 为什么选择 PixiJS（Piso）
  - 渲染性能对比数据
- 1.3 整体架构概览
  - 五层架构设计
  - 核心模块关系图
  - 数据流与渲染流

**学习目标**：理解无限画布的本质和技术选型背景

---

### 第2章：坐标系统与矩阵变换

**核心问题**：如何在无限画布中精确定位和变换元素？

**内容要点**：
- 2.1 坐标系统基础
  - 世界坐标系（World Coordinates）
  - 屏幕坐标系（Screen Coordinates）
  - 局部坐标系（Local Coordinates）
  - 三者之间的关系
- 2.2 矩阵变换原理
  - 2D 仿射变换矩阵
  - 平移（Translation）
  - 缩放（Scale）
  - 旋转（Rotation）
  - 复合变换
- 2.3 坐标转换实现
  - `getLocalPoint` - 屏幕坐标转世界坐标
  - `getGlobalPoint` - 世界坐标转屏幕坐标
  - `decomposeTransform` - 矩阵分解
- 2.4 包围盒计算
  - AABB（轴对齐包围盒）
  - OBB（有向包围盒）
  - 包围盒应用场景

**学习目标**：掌握坐标系统和矩阵变换的数学原理

---

## 📖 第二部分：核心渲染引擎篇

### 第3章：Surface 画布表面层

**核心问题**：画布的顶层管理者是如何工作的？

**内容要点**：
- 3.1 Surface 架构设计
  - Surface 抽象基类
  - 核心组件组合
- 3.2 三种画布模式
  - `BoardSurface` - 无限画布模式
  - `PosterSurface` - 海报模式
  - `FlowSurface` - 长图模式
- 3.3 渲染循环机制
  - Ticker 渲染帧管理
  - 渲染更新策略
  - 性能监控
- 3.4 分辨率与 DPI
  - 高清屏适配
  - 动态分辨率切换

**学习目标**：理解 Surface 层的设计模式和职责划分

---

### 第4章：Viewport 视口管理

**核心问题**：如何实现无限大的画布只显示用户可见的部分？

**内容要点**：
- 4.1 视口核心概念
  - 视口状态：position、zoom
  - 视口边界与限制
  - 视口 padding
- 4.2 缩放系统
  - 缩放算法实现
  - 以鼠标位置为中心缩放
  - 缩放限制（minZoom、maxZoom）
- 4.3 平移系统
  - 平移边界计算
  - 惯性滚动
  - 边缘吸附
- 4.4 视口命令
  - `zoomTo` / `zoomToFit`
  - `zoomToElement` / `zoomToBounds`
  - `scrollToElement` / `scrollToBounds`
- 4.5 视口动画
  - 贝塞尔曲线缓动
  - 动画帧管理
- 4.6 视口持久化
  - LRU 缓存策略
  - 状态恢复

**学习目标**：掌握视口管理的核心算法和实现细节

---

### 第5章：VmEngine 视图模型引擎

**核心问题**：数据模型如何转换为可渲染的视图对象？

**内容要点**：
- 5.1 引擎架构设计
  - 数据模型 → 视图模型映射
  - 对象池管理
  - Pointer 引用机制
- 5.2 元素类型系统
  - 30+ 种元素类型映射
  - 元素继承体系
  - 元素创建工厂
- 5.3 视图模型管理
  - `buildVm` - 构建视图模型
  - `createVm` - 创建视图模型
  - `cloneVm` - 克隆视图模型
  - `removeVm` - 移除视图模型
- 5.4 增量更新机制
  - Action 类型定义
  - Processor 处理器模式
  - 批量更新优化

**学习目标**：理解数据驱动渲染的核心机制

---

### 第6章：元素生命周期与渲染

**核心问题**：一个元素从创建到销毁经历了哪些阶段？

**内容要点**：
- 6.1 BaseElementVm 基类设计
  - 类继承体系
  - 核心属性和方法
  - 图层结构
- 6.2 数据模型生命周期
  - `modelCreated` - 模型创建
  - `modelUpdated` - 模型更新
  - `modelRemoved` - 模型移除
- 6.3 视图模型生命周期
  - `shouldUpdate` - 是否需要更新
  - `beforeUpdate` - 更新前钩子
  - `render` - 渲染方法
  - `afterUpdate` - 更新后钩子
- 6.4 具体元素实现
  - ImageVm - 图片元素
  - TextVm - 文本元素
  - ShapeVm - 形状元素
  - GroupVm - 组元素
- 6.5 特殊元素解析
  - LayoutVm - 画板元素
  - ConnectorVm - 连接线
  - MagnifierVm - 放大镜

**学习目标**：掌握元素渲染的完整流程

---

## 📖 第三部分：事件与交互篇

### 第7章：事件系统与碰撞检测

**核心问题**：如何精确判断用户点击了哪个元素？

**内容要点**：
- 7.1 EventBoundary 事件边界
  - 事件边界设计
  - 遍历策略
- 7.2 碰撞检测算法
  - 点击检测 `hitTest`
  - 区域检测 `intersect`
  - 包围盒检测
  - 有向包围盒检测
- 7.3 SAT 分离轴算法
  - 算法原理
  - 实现细节
  - 性能优化
- 7.4 遮罩层处理
  - 遮罩检测
  - 透明区域穿透
- 7.5 Bypass 策略
  - Skip - 跳过元素
  - Pass - 穿透元素
  - Hits - 直接命中
  - None - 正常检测

**学习目标**：掌握事件系统和碰撞检测的实现原理

---

### 第8章：手势与交互处理

**核心问题**：如何优雅地处理用户的各种交互操作？

**内容要点**：
- 8.1 鼠标事件处理
  - 滚轮缩放
  - 滚轮平移
  - 右键菜单
- 8.2 触摸事件处理
  - 双指缩放
  - 单指平移
  - 惯性滚动
- 8.3 键盘快捷键
  - 快捷键系统
  - 组合键处理
- 8.4 性能优化
  - 节流与防抖
  - Mipmap 策略切换

**学习目标**：理解交互处理的最佳实践

---

## 📖 第四部分：插件系统篇

### 第9章：插件系统架构

**核心问题**：如何设计一个可扩展的插件系统？

**内容要点**：
- 9.1 PluginSystem 设计
  - 插件注册机制
  - 插件生命周期
- 9.2 渲染插件分类
  - 视口类插件（viewport、scrollbar、ruler）
  - 交互类插件（hand、hover、guide）
  - 渲染类插件（outline、highlight、mosaic）
  - 功能类插件（magic-brush、connector）
- 9.3 核心插件解析
  - `viewport-plugin` - 视口控制
  - `guide-plugin` - 对齐参考线
  - `ruler-plugin` - 标尺
  - `transform-plugin` - 元素变换
- 9.4 自定义插件开发
  - 插件接口定义
  - 开发规范
  - 示例代码

**学习目标**：掌握插件系统的设计模式和扩展方法

---

## 📖 第五部分：性能优化篇

### 第10章：性能优化策略

**核心问题**：如何让画布在万级元素时仍然流畅？

**内容要点**：
- 10.1 虚拟化渲染
  - 视口剔除（Viewport Culling）
  - 按需创建/销毁
  - 空间索引
- 10.2 纹理管理
  - 纹理复用
  - 纹理池
  - 懒加载策略
- 10.3 渲染优化
  - 脏矩形检测
  - 批处理渲染
  - LOD 分级渲染
- 10.4 内存优化
  - 对象池复用
  - 资源回收
  - 内存监控
- 10.5 性能监控
  - FPS 监控
  - 渲染时间统计
  - 性能分析工具

**学习目标**：掌握无限画布的性能优化技巧

---

## 📖 附录

### 第11章：PixiJS 与 WebGL 基础

- 11.1 WebGL 渲染原理
- 11.2 PixiJS 核心概念
  - Container、Sprite、Graphics
  - Texture 与 BaseTexture
  - Transform 与 Matrix
- 11.3 Piso（PixiJS 定制版）

---

### 第12章：常见问题与最佳实践

- 12.1 常见问题 FAQ
- 12.2 开发最佳实践
- 12.3 调试技巧
- 12.4 性能测试方法

---

## 📊 学习路线图

```
入门阶段（建议 2-3 天）
├── 第1章：基础概念与技术选型
├── 第2章：坐标系统与矩阵变换
└── 第11章：PixiJS 与 WebGL 基础（可选）

进阶阶段（建议 3-5 天）
├── 第3章：Surface 画布表面层
├── 第4章：Viewport 视口管理
├── 第5章：VmEngine 视图模型引擎
└── 第6章：元素生命周期与渲染

高级阶段（建议 3-5 天）
├── 第7章：事件系统与碰撞检测
├── 第8章：手势与交互处理
├── 第9章：插件系统架构
└── 第10章：性能优化策略
```

---

## 🎯 预期收获

完成本系列学习后，你将能够：

1. **理解原理**：深入理解无限画布的设计理念和实现原理
2. **阅读代码**：能够独立阅读和理解编辑器渲染引擎代码
3. **排查问题**：具备定位和解决渲染相关问题的能力
4. **性能优化**：掌握画布性能优化的核心策略
5. **二次开发**：能够基于现有架构进行功能扩展和定制

---

## 📝 文档约定

- **代码块**：所有代码示例均来自实际项目，路径会在代码块上方标注
- **关键概念**：首次出现的关键术语会用 **粗体** 标注
- **注意事项**：重要提示会用 `> ⚠️` 标注
- **扩展阅读**：推荐的延伸阅读会在章节末尾列出

---

> 📅 文档更新时间：2026-01-27
> 
> 👤 维护者：前端团队
