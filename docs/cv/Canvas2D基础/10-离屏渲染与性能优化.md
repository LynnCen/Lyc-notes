# 第10章：离屏渲染与性能优化

## 10.1 章节概述

随着 Canvas 应用的复杂度增加，性能问题变得越来越重要。一个复杂的游戏或数据可视化应用可能需要每秒绑制数万个图形元素，如果不进行优化，很容易出现卡顿、掉帧。

本章将深入讲解：

- **离屏 Canvas**：预渲染和缓存技术
- **OffscreenCanvas**：Web Worker 中的 Canvas
- **渲染优化**：减少绑制调用、批量操作
- **内存管理**：避免内存泄漏
- **性能分析**：使用开发者工具
- **最佳实践**：高性能 Canvas 应用指南

---

## 10.2 理解 Canvas 性能

### 10.2.1 性能瓶颈来源

Canvas 性能问题通常来自以下几个方面：

| 瓶颈类型 | 说明 | 示例 |
|---------|------|------|
| **CPU 瓶颈** | JavaScript 计算量大 | 复杂的物理计算、大量循环 |
| **GPU 瓶颈** | 渲染命令过多 | 绘制大量图形、频繁切换状态 |
| **内存瓶颈** | 内存占用过高 | 大量 ImageData、未释放资源 |
| **带宽瓶颈** | 数据传输量大 | 频繁的 getImageData/putImageData |

### 10.2.2 性能指标

| 指标 | 理想值 | 说明 |
|------|--------|------|
| **FPS** | 60 | 帧率 |
| **帧时间** | <16.67ms | 每帧处理时间 |
| **内存** | 稳定 | 不应持续增长 |
| **CPU 占用** | <50% | 留出余量 |

### 10.2.3 性能测量

```javascript
/**
 * 简单的性能监控器
 */
class PerformanceMonitor {
    constructor() {
        this.frames = [];
        this.maxFrames = 60;
        this.lastTime = performance.now();
    }
    
    begin() {
        this.frameStart = performance.now();
    }
    
    end() {
        const frameTime = performance.now() - this.frameStart;
        this.frames.push(frameTime);
        
        if (this.frames.length > this.maxFrames) {
            this.frames.shift();
        }
    }
    
    getFPS() {
        const now = performance.now();
        const elapsed = now - this.lastTime;
        this.lastTime = now;
        return Math.round(1000 / elapsed);
    }
    
    getAverageFrameTime() {
        if (this.frames.length === 0) return 0;
        const sum = this.frames.reduce((a, b) => a + b, 0);
        return (sum / this.frames.length).toFixed(2);
    }
    
    draw(ctx) {
        const fps = this.getFPS();
        const avgTime = this.getAverageFrameTime();
        
        ctx.save();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(10, 10, 150, 50);
        
        ctx.fillStyle = fps >= 55 ? '#4CAF50' : fps >= 30 ? '#FF9800' : '#F44336';
        ctx.font = '14px monospace';
        ctx.fillText(`FPS: ${fps}`, 20, 30);
        ctx.fillText(`Frame: ${avgTime}ms`, 20, 50);
        ctx.restore();
    }
}

// 使用
const monitor = new PerformanceMonitor();

function animate() {
    monitor.begin();
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // ... 渲染逻辑
    
    monitor.end();
    monitor.draw(ctx);
    
    requestAnimationFrame(animate);
}
```

---

## 10.3 离屏 Canvas（Off-screen Canvas）

### 10.3.1 什么是离屏 Canvas？

离屏 Canvas 是一个**不在页面上显示**的 Canvas 元素，用于：

- 预渲染复杂图形
- 缓存静态内容
- 图像处理
- 后台计算

```javascript
// 创建离屏 Canvas
const offscreen = document.createElement('canvas');
offscreen.width = 200;
offscreen.height = 200;
const offCtx = offscreen.getContext('2d');

// 在离屏 Canvas 上绘制
offCtx.fillStyle = '#4D7CFF';
offCtx.fillRect(0, 0, 200, 200);

// 将离屏 Canvas 绘制到主 Canvas
ctx.drawImage(offscreen, 0, 0);
```

### 10.3.2 预渲染复杂图形

```javascript
/**
 * 预渲染复杂的星形图案
 */
function createStarCache(size, points, color) {
    const cache = document.createElement('canvas');
    cache.width = size;
    cache.height = size;
    const ctx = cache.getContext('2d');
    
    const cx = size / 2;
    const cy = size / 2;
    const outerRadius = size / 2 - 2;
    const innerRadius = outerRadius / 2;
    
    ctx.beginPath();
    for (let i = 0; i < points * 2; i++) {
        const radius = i % 2 === 0 ? outerRadius : innerRadius;
        const angle = (i * Math.PI) / points - Math.PI / 2;
        const x = cx + radius * Math.cos(angle);
        const y = cy + radius * Math.sin(angle);
        
        if (i === 0) {
            ctx.moveTo(x, y);
        } else {
            ctx.lineTo(x, y);
        }
    }
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
    
    return cache;
}

// 创建缓存
const starCache = createStarCache(50, 5, '#FFD700');

// 使用缓存绘制多个星形（非常快）
function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    for (let i = 0; i < 1000; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        
        // 直接绘制缓存图像，比重新绘制路径快得多
        ctx.drawImage(starCache, x - 25, y - 25);
    }
    
    requestAnimationFrame(animate);
}
```

### 10.3.3 图层缓存

```javascript
/**
 * 分层缓存系统
 */
class LayerSystem {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this.layers = new Map();
    }
    
    createLayer(name) {
        const canvas = document.createElement('canvas');
        canvas.width = this.width;
        canvas.height = this.height;
        
        this.layers.set(name, {
            canvas,
            ctx: canvas.getContext('2d'),
            dirty: true
        });
        
        return this.layers.get(name).ctx;
    }
    
    getLayer(name) {
        return this.layers.get(name);
    }
    
    markDirty(name) {
        const layer = this.layers.get(name);
        if (layer) layer.dirty = true;
    }
    
    render(mainCtx) {
        // 按顺序合成所有图层
        for (const [name, layer] of this.layers) {
            mainCtx.drawImage(layer.canvas, 0, 0);
        }
    }
}

// 使用
const layers = new LayerSystem(800, 600);

// 创建背景层（静态，只绘制一次）
const bgCtx = layers.createLayer('background');
drawBackground(bgCtx);

// 创建游戏对象层（动态，每帧更新）
const gameCtx = layers.createLayer('game');

// 创建 UI 层
const uiCtx = layers.createLayer('ui');
drawUI(uiCtx);

function animate() {
    const gameLayer = layers.getLayer('game');
    
    // 只清空和重绘游戏层
    gameLayer.ctx.clearRect(0, 0, 800, 600);
    updateGameObjects(gameLayer.ctx);
    
    // 合成到主 Canvas
    mainCtx.clearRect(0, 0, 800, 600);
    layers.render(mainCtx);
    
    requestAnimationFrame(animate);
}
```

### 10.3.4 精灵缓存

```javascript
/**
 * 精灵缓存管理器
 */
class SpriteCache {
    constructor() {
        this.cache = new Map();
    }
    
    /**
     * 创建或获取缓存的精灵
     */
    getSprite(key, width, height, drawFunc) {
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }
        
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        
        drawFunc(ctx, width, height);
        
        this.cache.set(key, canvas);
        return canvas;
    }
    
    clear() {
        this.cache.clear();
    }
}

// 使用
const spriteCache = new SpriteCache();

// 获取或创建圆形精灵
function getCircleSprite(radius, color) {
    const key = `circle_${radius}_${color}`;
    const size = radius * 2;
    
    return spriteCache.getSprite(key, size, size, (ctx, w, h) => {
        ctx.beginPath();
        ctx.arc(w / 2, h / 2, radius, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
    });
}

// 绘制 1000 个圆形
function drawCircles() {
    const colors = ['#FF6B6B', '#4D7CFF', '#51CF66', '#FAB005'];
    
    for (let i = 0; i < 1000; i++) {
        const color = colors[i % colors.length];
        const sprite = getCircleSprite(20, color);
        
        ctx.drawImage(sprite, 
            Math.random() * canvas.width - 20,
            Math.random() * canvas.height - 20
        );
    }
}
```

---

## 10.4 OffscreenCanvas API

### 10.4.1 什么是 OffscreenCanvas？

`OffscreenCanvas` 是现代浏览器提供的 API，允许在 **Web Worker** 中进行 Canvas 渲染，完全不阻塞主线程。

```javascript
// 检查支持
if (typeof OffscreenCanvas !== 'undefined') {
    console.log('OffscreenCanvas 可用');
}
```

### 10.4.2 在主线程使用 OffscreenCanvas

```javascript
// 创建 OffscreenCanvas
const offscreen = new OffscreenCanvas(800, 600);
const ctx = offscreen.getContext('2d');

// 正常绑制
ctx.fillStyle = '#4D7CFF';
ctx.fillRect(0, 0, 100, 100);

// 转换为 ImageBitmap 用于显示
const bitmap = offscreen.transferToImageBitmap();

// 绘制到主 Canvas
mainCtx.drawImage(bitmap, 0, 0);
```

### 10.4.3 转移 Canvas 控制权到 Worker

```javascript
// main.js
const canvas = document.getElementById('canvas');

// 转移控制权到 Worker
const offscreen = canvas.transferControlToOffscreen();

const worker = new Worker('canvas-worker.js');
worker.postMessage({ canvas: offscreen }, [offscreen]);

// 注意：转移后主线程不能再操作这个 canvas
```

```javascript
// canvas-worker.js
self.onmessage = function(e) {
    const canvas = e.data.canvas;
    const ctx = canvas.getContext('2d');
    
    let frame = 0;
    
    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 复杂的渲染操作，不会阻塞主线程
        for (let i = 0; i < 1000; i++) {
            ctx.fillStyle = `hsl(${(frame + i) % 360}, 70%, 50%)`;
            ctx.fillRect(
                Math.sin(frame / 50 + i) * 200 + 400,
                Math.cos(frame / 50 + i) * 200 + 300,
                10, 10
            );
        }
        
        frame++;
        requestAnimationFrame(animate);
    }
    
    animate();
};
```

### 10.4.4 Worker 中的图像处理

```javascript
// image-processor-worker.js
self.onmessage = async function(e) {
    const { imageData, filter } = e.data;
    
    const offscreen = new OffscreenCanvas(imageData.width, imageData.height);
    const ctx = offscreen.getContext('2d');
    
    // 创建 ImageData
    const data = new ImageData(
        new Uint8ClampedArray(imageData.data),
        imageData.width,
        imageData.height
    );
    
    // 应用滤镜
    applyFilter(data, filter);
    
    // 绘制处理后的数据
    ctx.putImageData(data, 0, 0);
    
    // 返回 ImageBitmap
    const bitmap = offscreen.transferToImageBitmap();
    self.postMessage({ bitmap }, [bitmap]);
};

function applyFilter(imageData, filter) {
    const data = imageData.data;
    
    switch (filter) {
        case 'grayscale':
            for (let i = 0; i < data.length; i += 4) {
                const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                data[i] = data[i + 1] = data[i + 2] = gray;
            }
            break;
        // ... 其他滤镜
    }
}
```

```javascript
// main.js
const worker = new Worker('image-processor-worker.js');

worker.onmessage = function(e) {
    const { bitmap } = e.data;
    ctx.drawImage(bitmap, 0, 0);
    bitmap.close();  // 释放资源
};

// 发送图像数据到 Worker
const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
worker.postMessage({
    imageData: {
        data: imageData.data.buffer,
        width: imageData.width,
        height: imageData.height
    },
    filter: 'grayscale'
}, [imageData.data.buffer]);
```

---

## 10.5 渲染优化技巧

### 10.5.1 减少状态切换

```javascript
// ❌ 低效：频繁切换状态
for (let i = 0; i < 100; i++) {
    ctx.fillStyle = 'red';
    ctx.fillRect(i * 10, 0, 8, 8);
    ctx.fillStyle = 'blue';
    ctx.fillRect(i * 10, 10, 8, 8);
}

// ✅ 高效：批量绘制相同状态
ctx.fillStyle = 'red';
for (let i = 0; i < 100; i++) {
    ctx.fillRect(i * 10, 0, 8, 8);
}

ctx.fillStyle = 'blue';
for (let i = 0; i < 100; i++) {
    ctx.fillRect(i * 10, 10, 8, 8);
}
```

### 10.5.2 使用路径批量绘制

```javascript
// ❌ 低效：每个圆单独绘制
for (let i = 0; i < 1000; i++) {
    ctx.beginPath();
    ctx.arc(points[i].x, points[i].y, 5, 0, Math.PI * 2);
    ctx.fill();
}

// ✅ 高效：合并到一个路径
ctx.beginPath();
for (let i = 0; i < 1000; i++) {
    ctx.moveTo(points[i].x + 5, points[i].y);
    ctx.arc(points[i].x, points[i].y, 5, 0, Math.PI * 2);
}
ctx.fill();
```

### 10.5.3 避免浮点数坐标

```javascript
// ❌ 浮点坐标导致子像素渲染，性能下降
ctx.fillRect(10.5, 20.7, 100, 50);

// ✅ 整数坐标更高效
ctx.fillRect(Math.round(10.5), Math.round(20.7), 100, 50);

// 或使用位运算快速取整
ctx.fillRect(10.5 | 0, 20.7 | 0, 100, 50);
```

### 10.5.4 只重绘变化区域（脏矩形）

```javascript
/**
 * 脏矩形优化
 */
class DirtyRectRenderer {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.dirtyRects = [];
        this.objects = [];
    }
    
    addDirtyRect(x, y, width, height) {
        this.dirtyRects.push({ x, y, width, height });
    }
    
    markObjectDirty(obj) {
        // 添加对象的旧位置和新位置
        if (obj.prevBounds) {
            this.addDirtyRect(...obj.prevBounds);
        }
        this.addDirtyRect(obj.x, obj.y, obj.width, obj.height);
        
        // 保存当前边界
        obj.prevBounds = [obj.x, obj.y, obj.width, obj.height];
    }
    
    render() {
        if (this.dirtyRects.length === 0) return;
        
        // 合并重叠的脏矩形
        const merged = this.mergeDirtyRects();
        
        // 只清除和重绘脏区域
        merged.forEach(rect => {
            this.ctx.save();
            this.ctx.beginPath();
            this.ctx.rect(rect.x, rect.y, rect.width, rect.height);
            this.ctx.clip();
            
            // 清除区域
            this.ctx.clearRect(rect.x, rect.y, rect.width, rect.height);
            
            // 重绘该区域内的对象
            this.objects.forEach(obj => {
                if (this.intersects(obj, rect)) {
                    obj.draw(this.ctx);
                }
            });
            
            this.ctx.restore();
        });
        
        this.dirtyRects = [];
    }
    
    intersects(obj, rect) {
        return !(obj.x + obj.width < rect.x ||
                 obj.x > rect.x + rect.width ||
                 obj.y + obj.height < rect.y ||
                 obj.y > rect.y + rect.height);
    }
    
    mergeDirtyRects() {
        // 简化实现：返回包围所有脏矩形的矩形
        if (this.dirtyRects.length === 0) return [];
        
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        
        this.dirtyRects.forEach(rect => {
            minX = Math.min(minX, rect.x);
            minY = Math.min(minY, rect.y);
            maxX = Math.max(maxX, rect.x + rect.width);
            maxY = Math.max(maxY, rect.y + rect.height);
        });
        
        return [{
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
        }];
    }
}
```

### 10.5.5 使用 willReadFrequently 提示

```javascript
// 如果需要频繁读取像素数据
const ctx = canvas.getContext('2d', { willReadFrequently: true });

// 这告诉浏览器优化 getImageData 操作
```

### 10.5.6 减少 save/restore 调用

```javascript
// ❌ 频繁 save/restore
for (let i = 0; i < 1000; i++) {
    ctx.save();
    ctx.translate(i * 10, 0);
    ctx.fillRect(0, 0, 8, 8);
    ctx.restore();
}

// ✅ 手动管理状态
for (let i = 0; i < 1000; i++) {
    ctx.fillRect(i * 10, 0, 8, 8);
}

// 或者只在必要时 save/restore
ctx.save();
ctx.globalAlpha = 0.5;
for (let i = 0; i < 1000; i++) {
    ctx.fillRect(i * 10, 0, 8, 8);
}
ctx.restore();
```

---

## 10.6 内存管理

### 10.6.1 释放 ImageBitmap

```javascript
// ImageBitmap 需要手动释放
const bitmap = await createImageBitmap(blob);
ctx.drawImage(bitmap, 0, 0);
bitmap.close();  // 释放内存
```

### 10.6.2 清理离屏 Canvas

```javascript
// 不再需要的离屏 Canvas
function disposeCanvas(canvas) {
    // 清空内容
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 设置为最小尺寸
    canvas.width = 1;
    canvas.height = 1;
    
    // 如果保存了引用，置空
    canvas = null;
}
```

### 10.6.3 对象池模式

```javascript
/**
 * 对象池 - 复用对象避免频繁创建
 */
class ObjectPool {
    constructor(createFunc, resetFunc, initialSize = 10) {
        this.createFunc = createFunc;
        this.resetFunc = resetFunc;
        this.pool = [];
        
        // 预创建对象
        for (let i = 0; i < initialSize; i++) {
            this.pool.push(this.createFunc());
        }
    }
    
    get() {
        if (this.pool.length > 0) {
            return this.pool.pop();
        }
        return this.createFunc();
    }
    
    release(obj) {
        this.resetFunc(obj);
        this.pool.push(obj);
    }
    
    clear() {
        this.pool = [];
    }
}

// 粒子对象池
const particlePool = new ObjectPool(
    // 创建函数
    () => ({
        x: 0, y: 0,
        vx: 0, vy: 0,
        life: 0,
        color: '#fff'
    }),
    // 重置函数
    (p) => {
        p.x = p.y = p.vx = p.vy = p.life = 0;
    },
    100  // 初始数量
);

// 使用
function emitParticle(x, y) {
    const p = particlePool.get();
    p.x = x;
    p.y = y;
    p.vx = Math.random() * 100 - 50;
    p.vy = Math.random() * 100 - 50;
    p.life = 1;
    particles.push(p);
}

function updateParticles(deltaTime) {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= deltaTime;
        
        if (p.life <= 0) {
            particlePool.release(p);  // 回收而非销毁
            particles.splice(i, 1);
        }
    }
}
```

### 10.6.4 避免内存泄漏

```javascript
// ❌ 常见内存泄漏

// 1. 未清除的事件监听
canvas.addEventListener('click', handleClick);
// 应该在不需要时移除：canvas.removeEventListener('click', handleClick);

// 2. 闭包持有大对象引用
function createHandler(largeData) {
    return () => {
        console.log(largeData);  // largeData 无法被回收
    };
}

// 3. 全局数组无限增长
const history = [];
function addToHistory(item) {
    history.push(item);  // 永远增长
}
// 应该限制大小或定期清理

// 4. 定时器未清除
const timerId = setInterval(tick, 16);
// 应该在不需要时清除：clearInterval(timerId);
```

---

## 10.7 Canvas 性能对比

### 10.7.1 不同操作的性能

```javascript
/**
 * 性能测试工具
 */
function benchmark(name, iterations, testFunc) {
    const start = performance.now();
    
    for (let i = 0; i < iterations; i++) {
        testFunc();
    }
    
    const end = performance.now();
    console.log(`${name}: ${(end - start).toFixed(2)}ms for ${iterations} iterations`);
}

// 测试不同操作
benchmark('fillRect', 10000, () => {
    ctx.fillRect(0, 0, 100, 100);
});

benchmark('arc', 10000, () => {
    ctx.beginPath();
    ctx.arc(50, 50, 50, 0, Math.PI * 2);
    ctx.fill();
});

benchmark('drawImage', 10000, () => {
    ctx.drawImage(img, 0, 0);
});

benchmark('getImageData', 100, () => {
    ctx.getImageData(0, 0, 100, 100);
});

// 典型结果（相对速度）：
// fillRect: 最快
// drawImage: 快
// arc: 中等
// getImageData: 慢
```

### 10.7.2 优化前后对比

```javascript
// 场景：绘制 10000 个彩色圆形

// 优化前
function drawCirclesSlow() {
    for (let i = 0; i < 10000; i++) {
        ctx.save();
        ctx.fillStyle = `hsl(${i % 360}, 70%, 50%)`;
        ctx.beginPath();
        ctx.arc(
            Math.random() * canvas.width,
            Math.random() * canvas.height,
            5, 0, Math.PI * 2
        );
        ctx.fill();
        ctx.restore();
    }
}
// 约 50-100ms

// 优化后：按颜色分组 + 缓存
function drawCirclesFast() {
    const colors = [];
    for (let h = 0; h < 360; h += 10) {
        colors.push(`hsl(${h}, 70%, 50%)`);
    }
    
    // 每种颜色的圆形分组
    colors.forEach(color => {
        const sprite = getCircleSprite(5, color);
        
        for (let i = 0; i < Math.ceil(10000 / colors.length); i++) {
            ctx.drawImage(sprite,
                Math.random() * canvas.width - 5,
                Math.random() * canvas.height - 5
            );
        }
    });
}
// 约 5-10ms（快 10 倍）
```

---

## 10.8 本章小结

本章介绍了 Canvas 性能优化的核心技术：

### 核心策略

| 策略 | 效果 |
|------|------|
| **离屏 Canvas** | 预渲染和缓存 |
| **批量绘制** | 减少 API 调用 |
| **状态分组** | 减少状态切换 |
| **脏矩形** | 只重绘变化区域 |
| **对象池** | 减少 GC 压力 |

### 优化检查清单

- [ ] 静态内容使用离屏 Canvas 缓存
- [ ] 相同样式的图形批量绘制
- [ ] 避免浮点数坐标
- [ ] 减少 save/restore 调用
- [ ] 使用对象池管理频繁创建的对象
- [ ] 及时释放不需要的资源
- [ ] 使用开发者工具分析性能

---

## 10.9 练习题

### 基础练习

1. 实现一个精灵缓存系统

2. 创建性能监控面板

3. 对比优化前后的渲染性能

### 进阶练习

4. 实现分层渲染系统

5. 使用 Web Worker 进行图像处理

### 挑战练习

6. 构建一个高性能粒子系统：
   - 使用对象池
   - 批量渲染
   - 稳定 60fps 渲染 10000+ 粒子

---

**下一章预告**：在第11章中，我们将通过实战案例综合运用所学知识。

---

**文档版本**：v1.0  
**字数统计**：约 13,000 字  
**代码示例**：40+ 个
