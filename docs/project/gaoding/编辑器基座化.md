# 编辑器基座化

近期接AI+编辑器中，了解到编辑器基座化，查看了相关文档和代码，以下简述下个人见解。

## 一、什么是基座

进行谷歌搜索"前端基座"，跳出来的信息大都和微前端相管理，那么是否可以认为基座相似于微前端，但又有其各自的特殊性，我司编辑器基座可以理解为主应用，不存在子应用说法，如需增加可拓展性，基座提供了拓展插件的功能。基座的目的是为了将公共业务部分抽离出来，变成通用型架构，符合当前大部分业务场景。

## 二、基座的职责

主要职责有以下几个方面：

1. 视图布局框架
2. 权限管理
3. 全局状态管理
4. 拓展管理

## 三、编辑器基座

在编辑器中基座化（@design/design-foundation）是一个独立的包，是Exitor-Next项目的核心基座，负责整个编辑器的初始化、配置管理、布局渲染、模块协调、生命周期管理和核心功能集，为上层业务应用提供稳定可靠的技术底座。

### 3.1 架构预览

接下来，我们将对编辑器基座的四大核心模块——基座核心、初始化子系统、布局系统和功能组合——进行逐一深入的剖析。我们将结合架构图与关键源代码，详细阐述每个模块的设计理念、职责边界以及它们之间如何高效协作，从而全面揭示编辑器能够稳定、高效运行的内部机制。

### 3.2 基座核心

基座核心是整个 @design/design-foundation 包的"心脏"与"门户"，它定义了编辑器的启动方式、配置结构和初始化流程的起点。所有外部应用想要使用编辑器，都必须通过这个核心模块。它主要由三大支柱构成：统一安装入口 (installDesign)、配置管理 (DesignConfig) 和 初始化流程 (initDesign)。

#### 统一安装入口（installDesign）

installDesign是整个基座对外暴露的唯一入口，想要实例化一个编辑器都必须调用这个函数。

**主要职责：**

- 接收指令: 接收两个关键参数：selector (一个DOM选择器字符串，告诉编辑器应该在哪个HTML元素中渲染) 和 config (一个配置对象DesignConfig，用于定制编辑器的功能和外观)。
- 启动引擎: 调用内部的 initDesign 函数，将配置传递下去，并正式启动整个编辑器的初始化流程。
- 返回实例: 初始化完成后，返回创建的Vue应用实例，以便上层应用可以进行进一步操作（尽管通常不需要）。

#### 配置管理（DesignConfig）

DesignConfig类似于编辑器的控制面板，定义了所有可以用来定制编辑器的配置项。

**DesignConfig API 参考**

| 属性 (Property) | 类型 (Type) | 描述 (Description) |
|----------------|------------|-------------------|
| env | `Partial<Env>` | 环境变量配置。用于覆盖默认的环境变量，如 API 服务地址、功能开关（Feature Flags）、应用名称等。 |
| apis | `Partial<CustomApisConfig>` | 自定义 API 接口。允许重写或提供自定义的后端服务接口实现，用于对接不同的后端系统。 |
| permissions | `PermissionConfig` | 权限点配置。用于设置用户的初始权限集，控制用户对编辑器中各项功能的访问权限。 |
| extensionConfig | `ExtensionConfig[]` | 扩展插件配置列表。定义了需要加载的插件及其相关配置，是实现编辑器功能模块化和可扩展性的核心。 |
| editorConfig | `Partial<EditorConfig>` | 编辑器功能配置。包含与编辑器核心功能、UI 表现和交互相关的详细设置（详见下表）。 |
| healthCheck | `HealthOptions` | 健康检查配置。用于配置编辑器健康状态监控服务的相关参数，如上报间隔、监控指标等。 |
| slsConfig | `Partial<IConfig>` | 日志服务配置。用于配置阿里云 SLS 日志服务的参数，如项目名、地域、日志存储等。 |
| beforeMountEditor | `() => void` | 挂载前回调钩子。一个在编辑器核心UI挂载到DOM之前执行的函数。可用于执行一些前置操作，例如覆盖在编辑器之上的AI绘图界面初始化。 |

#### 初始化流程（initDesign）

initDesign 是基座内部的"启动总指挥"，它位于 src/init/index.ts 文件中。该函数接收来自 installDesign 的配置，并严格按照预设的依赖顺序，一步步地创建和启动编辑器所需的所有服务和模块。这个流程是整个基座能够稳定运行的关键，它确保了所有模块在被使用之前都已正确初始化。

**Phase 1: 基础环境与核心服务启动 (Pre-Vue)**

这个阶段完全不依赖Vue，负责构建整个应用运行的基石。

- setDefaultFavIcon: 一个微小但重要的UI初始化，设置网站的图标。
- initEnv: 至关重要的一步。它将外部传入的 env 配置与默认配置合并，并设置到全局。后续所有模块（如API地址、功能开关）都将从此获取环境信息。
- webRecordInit: 初始化可选的用户行为录制服务。
- initAPI: 基于环境变量配置好API服务，包括设置请求/响应拦截器、统一的错误处理和身份认证逻辑。
- initPermission: 启动权限控制器，为后续的功能权限校验提供基础。
- 其他基础服务: 启动如 initEditable, initIntercept, initStoragePermission 等不依赖配置和Vue的原子服务。

**Phase 2: 配置注入 (Configuration Injection)**

在此阶段，我们将外部传入的、决定编辑器行为的配置信息，注入到整个系统可以访问的服务中。

- extensionConfigService: 存储插件列表配置，供后续的扩展系统按需加载。
- editorConfigService: 存储所有与UI、功能相关的配置。这是一个核心配置服务，后续组件和模块将从中读取配置来决定自己的行为。
- setDefaultFontUrl: 根据配置，设置默认字体的URL。
- initResourceManage: 初始化资源管理器。

**Phase 3: Vue应用创建与预挂载配置 (Pre-Mount)**

这个阶段的核心是创建Vue实例，并完成所有挂载到DOM之前的配置工作。

- createApp: 在内存中创建Vue应用实例，并注入 pinia 和 router 的根实例。
- initEditorStore: 初始化所有Pinia Stores。此步必须在 createApp 之后，因为它需要 pinia 实例。
- 注册Vue插件和UI库: 调用 app.use() 来注册Vue插件（如vueBEMPlugin）和UI组件库（Antd）。
- initRouterGuards: 为router实例附加全局导航守卫，实现登录拦截和页面权限校验。
- initOSS: 初始化对象存储服务。
- initLog: 初始化日志服务，并附加到Vue的全局错误处理器上，以便捕获所有组件的运行时错误。
- initHealthCheck: 初始化健康检查服务，它依赖日志服务进行上报，所以必须在initLog之后。

**Phase 4: 特定业务与挂载前回调 (Business Logic & Hooks)**

在即将渲染UI之前，处理一些特定的业务逻辑和提供给应用层的自定义钩子。

- AppLinkService.init: 初始化用于处理应用间跳转和权益合并等特定业务的服务。
- autoMergeEquity: 异步执行权益合并检查，这个过程不阻塞UI渲染。
- beforeMountEditor: 执行应用层传入的自定义回调函数，给予应用在UI渲染前的最后干预机会。

**Phase 5: 挂载到DOM (Mounting)**

这是整个流程的"分水岭"。

- app.mount(selector): Vue将内存中的虚拟DOM渲染为真实DOM，并挂载到指定节点。此刻，用户终于看到了编辑器界面。

**Phase 6: 后置初始化 (Post-Mount)**

在UI已经渲染完成后，执行那些依赖于真实DOM或完整Vue实例的收尾工作。

- initTracker: 初始化用户行为追踪SDK。它通常需要绑定到已挂载的Vue实例上才能正常工作。
- initTrackerSubscription: 启动事件订阅器，开始监听编辑器内部的各种业务事件（如模板加载、元素选中等），并将它们转化为埋点数据发送出去。

### 3.3 布局系统

该系统的核心是位于 src/layout/design.vue 的主布局组件，它采用"宏观-微观"的组件化策略，将整个编辑器界面划分为几个独立的、职责明确的核心区块：顶部工具栏 (Header)、左侧面板(ResourceStation)、中央主编辑区 (Main) 和 右侧属性面板 (RightPanel)。

#### 3.3.1 布局预览

通过基座核心提供的 layoutSlots 配置，应用层可以像搭积木一样，轻松地替换或扩展这些核心区块，从而在不修改基座源码的情况下，实现截然不同的UI布局，满足多样化的业务需求。

#### 3.3.2 编辑器初始化

**Phase 1: 即时设置 (组件创建时) - 准备"后台监听"**

这个阶段在 design.vue 组件实例被创建的那一刻立即执行，甚至在它被挂载到 DOM 之前。它负责设置那些需要长期存在、贯穿整个组件生命周期的"后台监听"逻辑。

- useBeforeunload(): 页面关闭守卫。此函数调用后，会立即向 window 对象注册一个 beforeunload 事件监听器。这个监听器会持续存在，当用户尝试关闭或刷新页面时，它会检查 SaveStatusStore 来判断是否有未保存的修改。如果有，它会触发浏览器原生的弹窗，询问用户是否确认离开，从而有效防止工作成果的意外丢失。
- useRouteReplaceQuery(): URL 规范化器。编辑器支持通过 URL 参数执行一次性操作（例如，?from=magic-studio&command=matting）。此函数会设置一个 Vue Router 的 watch，持续监控路由 query 的变化。一旦它检测到模板 ID 等核心参数发生变化（通常意味着操作已完成或已进入新的设计），它就会自动清理掉 URL 中那些一次性的命令参数，确保用户刷新页面时不会重复执行，并保持地址栏的整洁。

**Phase 2: 主动编排 (onMounted) - 系统"唤醒"**

当组件成功挂载到 DOM 后，onMounted 钩子被触发。这是业务逻辑的"点火"阶段，design.vue 在此扮演"总指挥"，按照精确的顺序主动调用并初始化一系列核心功能。

- initDamConfig: 配置数字资产管理（DAM）系统。
- initEditor: 实例化编辑器核心引擎。这是所有后续画布操作的基础，引擎实例被创建并存入 EditorStore。
- initFontsService: 初始化字体服务，加载和管理所有需要用到的字体。
- useCollabInit: 启动协同服务，建立 WebSocket 连接。
- initGlobalCommand: 注册所有全局命令（如撤销/重做、保存、对齐等）。
- initTemplateLoad: 启动模板加载流程。这是核心业务流程，通过 API 获取设计稿数据并将其渲染到画布上。
- loadExtension: 动态加载所有在 extensionConfig 中配置的插件，为编辑器注入AI工具、批量处理等扩展功能。
- initEditorHotKey: 在所有命令都注册完毕后，将键盘快捷键与这些命令进行绑定。

**Phase 3: 响应式事件处理 - "握手"与"收尾"**

这个阶段不是一次性的，而是一个持续的、被动的"监听与响应"过程。design.vue 在此扮演"父组件"，等待并处理来自其子组件（尤其是 Main.vue）的关键生命周期信号。

- onTemplateLoaded(): 当子组件 Main.vue 内部的模板加载逻辑成功完成后，它会通过 emit('templateLoaded') 发出信号。design.vue 捕获此事件并执行 onTemplateLoaded 处理器，可以用于记录日志或触发依赖于模板加载的下一步逻辑。
- onEditorReady(): 这是最重要的"握手"信号。当 Main.vue 确认编辑器引擎不仅已实例化，而且已完全准备好接受用户交互时，它会 emit('editorReady')。onEditorReady 处理器在收到这个最终确认信号后，会执行最关键的一步操作：mainLoaded.value = true。这会立即触发模板中所有 v-if="mainLoaded" 的UI区块进行渲染，用户至此才看到一个完整、可交互的编辑器界面。
- onPartMounted(): 这是一个持续发生的过程。每一个主要的布局子组件（Header, ResourceStation, RightPanel）在它们各自挂载完成后，都会 emit('mounted')。design.vue 的 onPartMounted 处理器会接收到这些信号，并更新对应的状态（如 asideMounted.value = true）。这会移除为该组件预留的 padding，实现平滑无抖动的加载效果。

## 四、模版加载

## 五、权限点Permissions

## 六、拓展Extension

## 七、环境变量Env
