📋 一、背景与目标
1.1 业务背景
在发现页瀑布流中，当用户对内容进行操作（点击、右键点击、采集、下载）后，根据用户的操作行为推荐相关的灵感词，帮助用户发现更多感兴趣的内容。同时，在搜索框底纹词中，整合词推荐和运营配置的底纹词，提升搜索体验。
功能范围：
● 灵感词功能：在发现页瀑布流中，当用户满足触发条件时，在内容卡片下方展示推荐词模块
● 搜索底纹词功能：在搜索框顶部展示词推荐和运营配置的底纹词
1.2 技术目标
● 实现操作行为追踪和推荐词展示功能
● 支持推荐词模块在瀑布流中的动态插入
● 实现搜索底纹词的合并展示
● 保证功能性能，不影响页面流畅度
● 兼容现有埋点系统和组件结构

📝 二、需求说明
2.1 灵感词功能需求
页面范围
发现页
功能需求
1. 推荐词获取与排序
    ○ 只取实时行为召回链路推荐词（real_time_behavior），按照词推荐模型排序离线词已有排序，展示排序最前的 5 个
    ○ 若当前页面下有操作行为的内容不只一个，则需要计算最新操作的内容召回推荐词中与其他内容推荐词的共现次数，然后进行重排：

        ■ 优先展示共现次数多的词
        ■ 同样共现次数的词保留排序模型排序离线词已有排序
    ○ 示例：若内容 1 推荐词：C D E A B F G H I J K、内容 2 推荐词：B C A E G I J K L M、内容 3 推荐词：L D I M N O P，用户操作内容 3 后需要展示灵感推荐词，"I"共现次数为 3，"D L M"的共现次数都为 2，重排后的顺序为"I L D M N"
2. 推荐词展示位置
    ○ 当用户点击/右键点击/采集/下载后，在瀑布流列表中灵感卡片下方插入推荐词模块
    ○ 文案：你可能感兴趣的灵感
    ○ 点击推荐词后，新页面打开页签，搜索对应搜索词，搜索词类型为"灵感推荐词"
3. 触发方案
    ○ 采用累计统计触发，用户在一个页面对内容操作，只在满足条件后才展示
    ○ 触发条件（满足一个即可）：

        ■ 2 分钟内，用户点击 2 个及以上内容后，若出现共现词，则展示词推荐
        ■ 3 分钟内，用户点击 3 个及以上内容，即使无共现词，也展示词推荐
        ■ 同一触发条件在 5 分钟内只触发一次
    ○ 展示规则：

        ■ 只在最新操作的内容卡片下方展示推荐词模块
        ■ 已展示的推荐词模块保持展示状态，不会消失
        ■ 5 分钟后属于下一个展示阶段，屏幕中可能存在多个推荐词模块（每个对应一次触发）
2.2 搜索底纹词功能需求
1. 推荐词获取与排序
    ○ 取实时行为召回链路和历史搜索召回链路推荐词，各取 3 个，不足 3 个的链路用另一个链路补齐。排序按照词推荐排序模型排序
    ○ 需要保留运营后台干预配置的底纹词
    ○ 过滤词推荐中与运营配置重复的词
    ○ 排序规则：词推荐在前，运营配置在后
2. 更新机制
    ○ 用户切换页面时更新（监听路由变化）
3. 展示形式
    ○ 通过搜索框的 placeholder 属性展示
    ○ 支持数组轮播（5 秒切换一次）
    ○ 保留现有的 placeholderPrefix（如"好灵感来花瓣"）
2.3 后端接口需求
2.3.1 灵感推荐词接口
● 方法/路径：POST /hb/search-words/idea-recommend
● 请求参数：
字段
类型
说明
备注
limit
int
返回数量
默认 15
position
string
位置

● 响应参数：
[
  {
    "recommend_word": "红色背景",
    "ext": {}
  },
  {
    "recommend_word": "蓝色背景",
    "ext": {}
  }
]

2.3.2 搜索框底纹词接口
● 方法/路径：POST /hb/search-words/placeholder
● 请求参数：
字段
类型
说明
备注
limit
int
返回数量
默认 10
position
string
位置

● 响应参数：
[
  {
    "recommend_word": "红色背景",
    "ext": {}
  },
  {
    "recommend_word": "蓝色背景",
    "ext": {}
  }
]

2.4 后端召回逻辑
词推荐数据构建
1. 内容关联词数据构建
    ○ 统计内容 365 天历史"被搜索-点击/采集/下载"的搜索词
    ○ 考虑被关联次数，结合内容核心 term 生成关联词数据集
    ○ @小星
实时行为召回
1. 召回规则
    ○ 取 10 分钟内，用户有交互行为的灵感，最多 5 个
    ○ 后端通过埋点自动维护用户操作历史，前端无需传递
    ○ 每个灵感的召回词数量：

        ■ 点击/右键点击行为：召回 10 个词
        ■ 采集/下载行为：召回 15 个词
历史搜索召回
1. 召回最近 14 天，累计搜索天数超过 3 天的搜索词，累计最多的 10 个词

    ○ @小星
2. 召回当天最近一次搜索时间超过 3 小时的搜索词
候选集融合及过滤
1. 融合以下三个链路的推荐词进行去重：

    ○ 词推荐模型（分发标识：word_recommend_v1）
    ○ 实时行为召回（real_time_behavior_v1）
    ○ 历史搜索召回（historica_search_v1）
2. 重复词需要带上所有来源标识
3. 过滤过气节日节点
词推荐排序模型
1. 通过词推荐排序模型对融合候选集所有词进行排序
2. 排序需要增加考虑实时行为召回中多个内容召回的共现词

🔄 三、业务流程
3.1 灵感词业务流程
操作行为
用户在发现页瀑布流中对内容进行以下四种操作：
● 点击
● 右键点击
● 采集
● 下载
前端处理流程
1. 操作记录与推荐词请求
    ○ 用户每次操作内容后，前端记录：

        ■ 内容 ID
        ■ 操作类型（点击/右键点击/采集/下载）
        ■ 操作时间戳
    ○ 立即请求该内容的灵感推荐词接口（POST /hb/search-words/idea-recommend）
    ○ 将推荐词结果与内容 ID 关联存储
2. 触发条件判断
    ○ 采用累计统计触发，每次操作后判断是否满足触发条件（满足一个即可）：

        ■ 条件 1：2 分钟内，用户操作了 2 个及以上内容，且存在共现词 → 展示词推荐
        ■ 条件 2：3 分钟内，用户操作了 3 个及以上内容，即使无共现词 → 展示词推荐
    ○ 同一触发条件在 5 分钟内只触发一次（需要检查距离上次触发是否已超过 5 分钟）
3. 共现词计算与排序
    ○ 当满足触发条件时，计算最新操作内容的推荐词与触发时间范围内所有其他内容的推荐词的共现次数
    ○ 共现计算范围：使用前端触发条件的时间范围（2 分钟或 3 分钟）
    ○ 排序规则：

        ■ 优先展示共现次数多的词
        ■ 同样共现次数的词保留后端词推荐排序模型的原有排序
    ○ 最终展示排序最前的 5 个词
4. 推荐词展示
    ○ 只在最新操作内容的卡片下方插入推荐词模块
    ○ 已展示的推荐词模块保持展示状态，不会消失
    ○ 5 分钟后属于下一个展示阶段，屏幕中可能存在多个推荐词模块（每个对应一次触发）
    ○ 文案：你可能感兴趣的灵感
    ○ 点击推荐词后，新页面打开页签，搜索对应搜索词，搜索词类型为"灵感推荐词"
流程说明
● 后端操作历史维护：后端通过埋点自动维护用户操作历史，前端无需传递操作历史记录
● 共现计算时间范围：使用前端触发条件的时间范围（2 分钟或 3 分钟），而非后端召回的时间范围（10 分钟）
● 展示位置：只在最新操作的内容卡片下展示，已展示的推荐词模块保持展示状态
● 多模块共存：5 分钟后属于下一个展示阶段，屏幕中可能存在多个推荐词模块（每个对应一次触发）
3.2 搜索底纹词业务流程
数据来源说明
搜索框顶部底纹词由两部分组成：
● 词推荐底纹词：通过接口获取的推荐词
● 运营配置底纹词：后台运营配置的底纹词
处理流程
1. 底纹词获取
    ○ 请求搜索框底纹词接口（POST /hb/search-words/placeholder）获取词推荐底纹词
    ○ 获取运营后台配置的底纹词（通过现有配置接口或数据源）
2. 底纹词处理
    ○ 词推荐底纹词处理：

        ■ 取实时行为召回链路和历史搜索召回链路推荐词，各取 3 个
        ■ 不足 3 个的链路用另一个链路补齐
        ■ 排序按照词推荐排序模型排序
    ○ 运营配置底纹词处理：

        ■ 保留运营后台干预的底纹词
        ■ 过滤与词推荐重复的词（如果词推荐中已存在，则过滤掉运营配置中的相同词）
3. 底纹词合并与排序
    ○ 合并规则：

        ■ 词推荐底纹词在前
        ■ 运营配置底纹词在后
    ○ 去重规则：过滤词推荐中与运营配置重复的词
    ○ 最终展示顺序：[词推荐底纹词 1, 词推荐底纹词 2, ..., 运营配置底纹词 1, 运营配置底纹词 2, ...]
4. 更新机制
    ○ 用户切换页面时，重新请求接口并更新底纹词
    ○ 每次更新时重新执行合并与排序逻辑
搜索底纹词流程说明
● 数据来源：词推荐通过接口获取，运营配置通过现有配置系统获取
● 去重规则：如果词推荐和运营配置存在重复词，保留词推荐中的词，过滤掉运营配置中的重复词
● 排序规则：严格按照"词推荐在前，运营配置在后"的顺序展示

🔍 四、现有业务情况分析
4.1 发现页瀑布流实现
页面结构
发现页位于 pages/discovery/index.jsx，主要使用以下组件：
● DiscoveryFeaturePinList：瀑布流列表组件（pageComponents/DiscoveryPinList/feature.jsx）
● HBList：瀑布流布局组件，负责多列布局和响应式渲染
● PinCard / PurePinCard：单个内容卡片组件
数据加载机制
1. 服务端渲染（SSR）
    ○ 首次加载通过 getServerSideProps 获取初始数据（40 条）
    ○ 支持分类筛选和排序
2. 客户端分页加载
    ○ 使用 useRequest hook 进行数据请求管理
    ○ 通过 page_num 和 page_size 控制分页
    ○ 支持滚动加载更多（onLoadMore）
3. 数据更新
    ○ 通过事件机制支持手动刷新（EVENT.DISCOVERY_PIN_LIST_RESET）
    ○ 注意：DiscoveryFeaturePinList 组件本身不支持轮询更新，轮询更新功能在 DiscoveryPinList/index.jsx 组件中（60 秒轮询），但发现页使用的是 feature.jsx 版本
瀑布流布局
● 使用多列布局（4-8 列，根据屏幕宽度自适应）
● 支持广告位插入（按规则插入到指定位置）
● 使用 Masonry 布局算法进行自动重排
卡片组件结构
PinCard / PurePinCard 组件结构：
● 图片展示区域（带懒加载）
● 用户信息区域
● 操作按钮区域（悬停显示）
● 描述文字区域（可选）
● 卡片是一个完整的组件，没有预留的底部扩展区域
卡片通过 data-pin-id 属性标识。
列表渲染机制：
● PinList 组件通过 render 方法根据 record.type 渲染不同类型的卡片
● 支持插入特殊类型的列表项（如 RENDERCARDTYPE.recommendSearchWordsA、RENDERCARDTYPE.recommendSearchWordsB、RENDERCARDTYPE.aiGameplay 等）
● 推荐词模块插入方式：在数据源（dataSource）中，在对应内容项之后插入一个特殊类型的数据项，设置 type 为新的 RENDERCARDTYPE（如 inspirationRecommendWords），并在 PinList 的 render 方法中添加对应的渲染逻辑
● 这种方式可以实现"在卡片下方插入推荐词模块"的效果，推荐词模块作为独立的列表项渲染
4.2 操作行为追踪
埋点系统
项目使用统一的埋点系统追踪用户行为：
1. 点击事件
    ○ 通过 data-gd-click="material_click" 属性标识
    ○ 在 tracker/collecter/materialClick.js 中处理
    ○ 记录内容 ID、页面信息、来源等
2. 操作类型
    ○ 点击：通过 onPinClick 处理，跳转到详情页
    ○ 右键点击：通过右键菜单触发
    ○ 采集：通过 PinActions 组件中的采集按钮
    ○ 下载：通过 PinDownload 组件处理
3. 事件触发位置
    ○ 点击事件在 components/PurePinCard/index.jsx 的 onOperate 方法中（发现页使用 PurePinCard）
    ○ 采集操作在 components/PinCard/actions/button.jsx 中（通过 PurePinActions 组件）
    ○ 下载操作在 components/PinDownload 组件中
    ○ 右键点击通过浏览器的右键菜单事件处理
操作记录方式
● 埋点数据自动上报到后端
● 后端通过埋点数据维护用户操作历史（10 分钟内，最多 5 个内容）
● 前端无需手动传递操作历史
4.3 搜索框实现
组件位置
搜索框位于 components/Header/search/index.tsx，使用以下组件：
● HBSearch：搜索输入框组件（components/HBInput/search.jsx）
● 支持联想词、快捷搜索等功能
底纹词（Placeholder）实现
1. 当前实现
    ○ 通过 placeholder prop 传入，支持字符串或数组
    ○ 数组形式支持轮播显示（5 秒切换一次）
    ○ 通过 placeholderPrefix 设置前缀文案
2. 展示位置
    ○ 在输入框内部，作为占位符显示
    ○ 当输入框有值时自动隐藏
    ○ 支持多词轮播展示
3. 数据结构

placeholder: string | string[ ]

placeholderPrefix: string // 如 "你可能感兴趣："

4.4 需要改造的点
4.4.1 灵感词功能需要改造的点
1. 操作记录管理缺失
    ○ 问题：前端没有维护用户操作历史的机制，需要新建状态管理来存储操作记录（内容 ID、操作类型、时间戳）
    ○ 影响：无法判断触发条件，无法计算共现词
    ○ 改造方案：在 DiscoveryFeaturePinList 组件中新增状态管理，使用 useState 或 useRef 存储操作历史，并实现定时清理过期记录
2. 右键点击追踪缺失
    ○ 问题：现有埋点系统只追踪 material_click（左键点击），没有追踪右键点击事件
    ○ 影响：无法准确记录用户的右键点击操作
    ○ 改造方案：需要在 PurePinCard 组件中添加 onContextMenu 事件监听，或通过埋点系统扩展支持右键点击事件
3. 数据源动态插入复杂度
    ○ 问题：DiscoveryFeaturePinList 的数据源管理较为复杂，涉及分页、广告插入、列表合并等逻辑，在特定位置插入推荐词模块需要谨慎处理索引
    ○ 影响：插入位置可能不准确，或影响其他功能（如广告位、分页等）
    ○ 改造方案：参考 PinDetail/FullPinList.jsx 中的 recommendSearchWordsA 插入方式，使用 splice 在特定位置插入，注意处理索引偏移问题
4. 触发条件实时判断性能
    ○ 问题：每次操作后都需要遍历操作历史，判断时间窗口内的操作数量，可能影响性能
    ○ 影响：频繁操作时可能导致页面卡顿
    ○ 改造方案：使用 useMemo 优化判断逻辑，或使用防抖/节流机制
5. 共现词计算性能
    ○ 问题：前端需要计算多个内容的推荐词共现次数，如果推荐词数量较多，计算量可能较大
    ○ 影响：可能影响页面响应速度
    ○ 改造方案：优化计算算法，使用 Map 数据结构提高查找效率，或考虑后端计算
6. 推荐词接口调用时机
    ○ 问题：每次操作后都需要调用推荐词接口，如果用户操作频繁，可能导致接口调用过多
    ○ 影响：增加服务器压力，可能触发限流
    ○ 改造方案：使用防抖机制，或批量请求多个内容的推荐词
7. 推荐词模块持久化
    ○ 问题：推荐词模块插入后，如果用户滚动或刷新，需要保持展示状态
    ○ 影响：用户体验不一致
    ○ 改造方案：需要将推荐词模块的状态持久化，或通过数据源标识来保持展示
4.4.2 搜索底纹词功能需要改造的点
1. 底纹词获取方式冲突
    ○ 问题：当前搜索框通过 getSearchPlaceholder 从轻舟（qingzhou）获取底纹词，新需求需要从新接口 POST /hb/search-words/placeholder 获取
    ○ 影响：需要处理两套数据源的合并，可能产生冲突
    ○ 改造方案：需要确认轻舟接口是否会被替换，或需要同时支持两套数据源，并明确优先级
2. 运营配置获取方式不明确
    ○ 问题：文档中提到"从现有配置系统获取运营配置的底纹词"，但具体配置系统位置和接口不明确
    ○ 影响：无法确定如何获取运营配置数据
    ○ 改造方案：需要确认运营配置的获取方式，可能是通过 getGrocery 或其他配置接口
3. 数据合并去重逻辑
    ○ 问题：需要合并词推荐和运营配置，并去重（保留词推荐，过滤运营配置中的重复词），逻辑相对复杂
    ○ 影响：如果处理不当，可能导致展示异常
    ○ 改造方案：需要仔细实现去重逻辑，确保词推荐在前，运营配置在后，且无重复
4. 页面切换更新时机
    ○ 问题：需求要求"用户切换页面时更新"，但搜索框是全局组件，需要明确"切换页面"的定义
    ○ 影响：更新时机不准确可能导致数据不及时
    ○ 改造方案：需要明确是路由切换、还是发现页内的分类切换，并在对应时机调用接口更新
5. 底纹词缓存机制
    ○ 问题：当前实现中有 cachePlaceholder.current[position] 缓存机制，新需求需要考虑缓存更新策略
    ○ 影响：如果缓存不及时更新，可能导致展示旧数据
    ○ 改造方案：在页面切换时清除缓存，或设置合理的缓存过期时间
6. 轮播展示逻辑
    ○ 问题：当前底纹词支持数组轮播（5 秒切换），新需求需要合并词推荐和运营配置后轮播
    ○ 影响：需要确保合并后的数组能正常轮播
    ○ 改造方案：合并后的数组直接传入 placeholder prop，现有轮播逻辑应该能正常工作

🎯 五、技术方案设计
5.1 技术选型
技术点
选型
理由
状态管理
useState + Hook
状态跟随组件生命周期，离开页面自动清理
服务层
Class + 静态方法
命名空间清晰，无需实例化，保持纯函数特性
数据请求
fetch API
轻量级，符合现代标准
工具函数
lodash
排序等工具函数，与现有代码保持一致
类型约束
TypeScript
严格类型检查，提升代码质量
组件优化
React.memo
优化推荐词组件渲染性能
计算优化
Map 数据结构
优化共现词计算，时间复杂度 O(n)
5.2 总体设计思路
本方案采用分层架构 + 组件内聚的设计理念：
1. 灵感词功能：采用传统的分层架构（类型层 → 服务层 → Hook 层 → 组件层），因为逻辑复杂，需要清晰的职责划分
2. 搜索底纹词功能：采用组件内聚方式（所有逻辑在一个文件），因为只有搜索框使用，不需要过度抽象
5.3 灵感词技术方案
5.3.1 设计原则
1. 职责分离：服务层（业务逻辑）、Hook 层（状态管理）、组件层（UI 渲染）各司其职
2. 纯函数优先：服务层使用 Class + 静态方法，保持纯函数特性，易于测试
3. 状态局部化：使用 useState 管理组件内状态，离开页面自动清理
4. 性能优化：使用 Map 数据结构优化共现词计算，时间复杂度 O(n)
5.3.2 核心流程说明
操作记录流程：
1. 用户操作（点击/右键/采集/下载）触发 recordOperation()
2. 调用 fetchRecommendWords() 获取推荐词
3. 将操作记录（pinId + 推荐词 + 时间戳）存入状态
4. 调用 checkTrigger() 检查是否满足触发条件
5. 如果触发，计算共现词并排序，更新 displayedModules
6. 组件根据 displayedModules 渲染推荐词模块
共现词计算逻辑：
● 遍历历史记录，统计每个推荐词在多少个内容中出现
● 使用 Map 数据结构存储词频，避免重复遍历
● 按共现次数降序排序，次数相同时保持原顺序
● 取前 5 个词展示
触发条件判断：
● 检查冷却时间：5 分钟内同一条件只触发一次
● 检查 2 分钟内是否有 2 个及以上操作记录
● 检查 3 分钟内是否有 3 个及以上操作记录
● 满足任一条件即触发展示
5.2 架构设计
5.2.1 灵感词分层架构
┌─────────────────────────────────────────────┐
│          组件层 (Component Layer)            │
│  DiscoveryFeaturePinList                    │
│  - 渲染瀑布流列表                            │
│  - 调用 Hook 获取状态和方法                  │
│  - 根据 displayedModules 渲染推荐词组件      │
└─────────────────────────────────────────────┘
                     ↓ 调用
┌─────────────────────────────────────────────┐
│            Hook 层 (Hook Layer)             │
│  useInspirationWords                        │
│  - 管理状态 (useState)                       │
│  - 调用服务层方法                            │
│  - 提供 recordOperation、displayedModules   │
└─────────────────────────────────────────────┘
                     ↓ 调用
┌─────────────────────────────────────────────┐
│        服务层 (Service Layer - Class)       │
│  InspirationWordsService (静态方法)         │
│  - fetchRecommendWords: 获取推荐词           │
│  - calculateCooccurrence: 计算共现词         │
│  - sortWords: 排序推荐词                     │
│  - checkTrigger: 检查触发条件                │
│  - filterExpired: 过滤过期记录               │
└─────────────────────────────────────────────┘

5.2.2 灵感词数据流
用户操作（点击/右键/采集/下载）
    ↓
recordOperation(pinId, type)
    ↓
├─ 1. fetchRecommendWords(pinId) → 获取推荐词
├─ 2. 创建 OperationRecord 并添加到 records
├─ 3. checkTrigger() → 检查触发条件
│      ├─ 检查冷却时间
│      ├─ 检查 2 分钟内 2 个内容
│      └─ 检查 3 分钟内 3 个内容
└─ 4. 如果触发：
       ├─ calculateCooccurrence() → 计算共现词
       ├─ sortWords() → 排序推荐词
       ├─ 更新 lastTriggerTime
       ├─ 添加到 displayedModules
       └─ 渲染推荐词组件

5.2.3 灵感词状态管理
┌──────────────┐
│ PurePinCard  │ 用户操作
└──────┬───────┘
       ↓
┌──────────────────────────────┐
│ useInspirationWords Hook     │
│ ┌──────────────────────────┐ │
│ │ State:                   │ │

│ │ - records: [ ]            │ │

│ │ - lastTriggerTime: 0     │ │
│ │ - displayedModules: Map  │ │
│ └──────────────────────────┘ │
└──────┬───────────────────────┘
       ↓
┌──────────────────────────────┐
│ InspirationWordsService      │
│ (静态方法 - 无状态)           │
└──────┬───────────────────────┘
       ↓
┌──────────────────────────────┐
│ 返回推荐词数据                │
└──────┬───────────────────────┘
       ↓
┌──────────────────────────────┐
│ InspirationRecommendWords    │
│ (推荐词组件)                  │
└──────────────────────────────┘

5.2.4 搜索底纹词功能架构
搜索框组件 (Header/search)
├── 词推荐获取
│   └── POST /hb/search-words/placeholder
├── 运营配置获取
│   └── 现有配置系统 (getGrocery)
├── 数据合并
│   ├── 去重处理
│   └── 排序（词推荐在前，运营配置在后）
└── 展示
    └── 传入 placeholder prop，支持轮播

5.4 灵感词核心实现
本节提供灵感词功能的完整代码实现，包括类型定义、服务层、Hook 层和组件层。
实现要点：
1. 严格类型约束：所有接口和函数都有明确的 TypeScript 类型定义
2. 服务层纯函数：使用 Class + 静态方法，无副作用，易于单元测试
3. Hook 管理状态：使用 useState 管理操作记录、触发时间、展示模块等状态
4. 自动清理机制：定时清理过期记录，避免内存泄漏
5.4.1 类型定义
// types/inspirationWords.ts

/** 操作类型枚举 */
export enum OperationType {
  CLICK = "click",
  RIGHT_CLICK = "right_click",
  COLLECT = "collect",
  DOWNLOAD = "download",
}

/** 操作记录 */
export interface OperationRecord {
  pinId: string;
  type: OperationType;
  timestamp: number;

  recommendWords?: string[ ];

}

/** 触发配置 */
export interface TriggerConfig {
  twoMinutesCount: number;
  threeMinutesCount: number;
  cooldownMinutes: number;
}

/** 触发结果 */
export interface TriggerResult {
  triggered: boolean;
  pinId?: string;

  words?: string[ ];

}

5.4.2 服务层（Class + 静态方法）
设计说明：
服务层使用 Class + 静态方法的设计，主要考虑：
1. 命名空间：InspirationWordsService.xxx 提供清晰的命名空间
2. 常量封装：DEFAULT_CONFIG、MAX_WORDS 等常量集中管理
3. 纯函数特性：所有方法都是静态的，无副作用，易于测试
4. 无需实例化：直接调用静态方法，避免实例化开销
// services/inspirationWords.ts

import { sortBy } from "lodash";
import type {
  OperationRecord,
  TriggerConfig,
  TriggerResult,
} from "@/types/inspirationWords";

/**
 * 灵感词服务类（静态方法）
 *
 * 设计理念：
 * 1. 使用 Class 提供命名空间
 * 2. 所有方法都是静态方法（无需实例化）
 * 3. 保持纯函数特性（无副作用）
 * 4. 封装常量配置
 */
export class InspirationWordsService {
  /** 默认触发配置 */
  static readonly DEFAULT_CONFIG: TriggerConfig = {
    twoMinutesCount: 2,
    threeMinutesCount: 3,
    cooldownMinutes: 5,
  };

  /** 推荐词最大数量 */
  static readonly MAX_WORDS = 5;

  /** 记录最大保留时间（5分钟） */
  static readonly MAX_AGE = 5 * 60 * 1000;

  /**
   * 获取推荐词
   * @param pinId 内容ID
   * @param position 位置标识（页面范围）
   */
  static async fetchRecommendWords(
    pinId: string,
    position: string

  ): Promise<string[ ]> {

    try {
      const response = await fetch("/hb/search-words/idea-recommend", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ pin_id: pinId, position }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();

      // 只取 real_time_behavior 类型的推荐词
      const realTimeBehavior = data.data?.find(
        (item: any) => item.key === "real_time_behavior"
      );


      return realTimeBehavior?.value || [ ];

    } catch (error) {
      console.error(
        "[InspirationWordsService] fetchRecommendWords error:",
        error
      );

      return [ ];

    }
  }

  /**
   * 计算共现词次数
   * @param currentWords 当前内容的推荐词
   * @param historyRecords 历史操作记录
   * @returns 共现次数 Map
   */
  static calculateCooccurrence(

    currentWords: string[ ],


    historyRecords: OperationRecord[ ]

  ): Map<string, number> {
    const map = new Map<string, number>();

    // 初始化当前词的计数为 1
    currentWords.forEach((word) => map.set(word, 1));

    // 遍历历史记录，累加共现次数
    historyRecords.forEach((record) => {
      record.recommendWords?.forEach((word) => {
        if (currentWords.includes(word)) {
          map.set(word, (map.get(word) || 0) + 1);
        }
      });
    });

    return map;
  }

  /**
   * 排序推荐词
   * 规则：
   * 1. 按共现次数降序
   * 2. 相同次数保持原顺序
   * 3. 取前 5 个
   *
   * @param words 推荐词列表（已排序）
   * @param cooccurrenceMap 共现次数 Map
   * @returns 排序后的推荐词（最多5个）
   */
  static sortWords(

    words: string[ ],

    cooccurrenceMap: Map<string, number>

  ): string[ ] {

    const wordsWithMeta = words.map((word, index) => ({
      word,
      count: cooccurrenceMap.get(word) || 0,
      originalIndex: index,
    }));

    // 使用 lodash sortBy 进行稳定排序
    const sorted = sortBy(wordsWithMeta, [
      (item) => -item.count, // 共现次数降序
      (item) => item.originalIndex, // 原顺序升序
    ]);

    return sorted.slice(0, this.MAX_WORDS).map((item) => item.word);
  }

  /**
   * 检查触发条件
   * @param records 操作记录列表
   * @param config 触发配置
   * @param lastTriggerTime 上次触发时间
   * @returns 触发结果
   */
  static checkTrigger(

    records: OperationRecord[ ],

    config: TriggerConfig,
    lastTriggerTime: number
  ): TriggerResult {
    const now = Date.now();

    // 检查冷却时间
    if (now - lastTriggerTime < config.cooldownMinutes * 60 * 1000) {
      return { triggered: false };
    }

    if (records.length === 0) {
      return { triggered: false };
    }

    // 检查 2 分钟内 2 个内容
    const twoMinutesRecords = records.filter(
      (r) => now - r.timestamp <= 2 * 60 * 1000
    );

    if (twoMinutesRecords.length >= config.twoMinutesCount) {
      return this.processTriggered(records);
    }

    // 检查 3 分钟内 3 个内容
    const threeMinutesRecords = records.filter(
      (r) => now - r.timestamp <= 3 * 60 * 1000
    );

    if (threeMinutesRecords.length >= config.threeMinutesCount) {
      return this.processTriggered(records);
    }

    return { triggered: false };
  }

  /**
   * 处理触发逻辑（私有方法）
   * @param records 操作记录列表
   * @returns 触发结果
   */

  private static processTriggered(records: OperationRecord[ ]): TriggerResult {

    const latestRecord = records[records.length - 1];
    const historyRecords = records.slice(0, -1).filter((r) => r.recommendWords);

    // 计算共现词
    const cooccurrenceMap = this.calculateCooccurrence(

      latestRecord.recommendWords || [ ],

      historyRecords
    );

    // 排序推荐词
    const sortedWords = this.sortWords(

      latestRecord.recommendWords || [ ],

      cooccurrenceMap
    );

    return {
      triggered: true,
      pinId: latestRecord.pinId,
      words: sortedWords,
    };
  }

  /**
   * 过滤过期记录
   * @param records 操作记录列表
   * @param maxAge 最大保留时间（毫秒），默认 5 分钟
   * @returns 过滤后的记录
   */
  static filterExpired(

    records: OperationRecord[ ],

    maxAge: number = this.MAX_AGE

  ): OperationRecord[ ] {

    const now = Date.now();
    return records.filter((r) => now - r.timestamp <= maxAge);
  }
}

5.4.3 Hook 层
设计说明：
Hook 层负责状态管理和业务逻辑调度：
1. 状态管理：使用 useState 管理操作记录、触发时间、展示模块
2. 生命周期管理：状态跟随组件，离开页面自动清理
3. 自动清理：每分钟清理一次过期记录，避免内存泄漏
4. 对外接口：提供 recordOperation()、displayedModules、clearRecords() 等方法
// hooks/useInspirationWords.ts

import { useState, useCallback, useEffect, useRef } from "react";
import { InspirationWordsService } from "@/services/inspirationWords";
import type {
  OperationRecord,
  OperationType,
  TriggerConfig,
} from "@/types/inspirationWords";

export interface UseInspirationWordsOptions {
  /** 页面范围标识（用于接口请求） */
  pageScope: string;
  /** 触发配置（可选） */
  triggerConfig?: Partial<TriggerConfig>;
  /** 触发回调（可选） */

  onTriggered?: (pinId: string, words: string[ ]) => void;

}

export interface UseInspirationWordsReturn {
  /** 记录操作方法 */
  recordOperation: (pinId: string, type: OperationType) => Promise<void>;
  /** 已展示的推荐词模块（key 是 pinId） */

  displayedModules: Map<string, string[ ]>;

  /** 清空记录方法 */
  clearRecords: () => void;
}

/**
 * 灵感词功能 Hook
 *
 * 特点：
 * 1. 状态完全在组件内（useState）
 * 2. 离开页面自动清理
 * 3. 业务逻辑在服务层
 * 4. 自动清理过期记录
 *
 * @example
 * ```tsx
 * const { recordOperation, displayedModules } = useInspirationWords({
 *   pageScope: 'discovery',
 * });
 * ```
 */
export function useInspirationWords(
  options: UseInspirationWordsOptions
): UseInspirationWordsReturn {
  const { pageScope, triggerConfig = {}, onTriggered } = options;

  // 合并配置
  const config = {
    ...InspirationWordsService.DEFAULT_CONFIG,
    ...triggerConfig,
  };

  // 状态：操作记录

  const [records, setRecords] = useState<OperationRecord[ ]>([ ]);


  // 状态：上次触发时间
  const [lastTriggerTime, setLastTriggerTime] = useState(0);

  // 状态：已展示的推荐词模块
  const [displayedModules, setDisplayedModules] = useState<

    Map<string, string[ ]>

  >(new Map());

  // 清理定时器引用
  const cleanupTimerRef = useRef<NodeJS.Timeout>();

  /**
   * 记录操作
   */
  const recordOperation = useCallback(
    async (pinId: string, type: OperationType) => {
      try {
        // 1. 获取推荐词
        const recommendWords =
          await InspirationWordsService.fetchRecommendWords(pinId, pageScope);

        // 2. 创建操作记录
        const record: OperationRecord = {
          pinId,
          type,
          timestamp: Date.now(),
          recommendWords,
        };

        // 3. 更新记录列表并检查触发条件
        setRecords((prevRecords) => {
          const newRecords = [...prevRecords, record];

          // 4. 检查触发条件
          const result = InspirationWordsService.checkTrigger(
            newRecords,
            config,
            lastTriggerTime
          );

          if (result.triggered && result.pinId && result.words) {
            // 更新触发时间
            setLastTriggerTime(Date.now());

            // 添加到展示模块
            setDisplayedModules((prevModules) => {
              const newModules = new Map(prevModules);
              newModules.set(result.pinId!, result.words!);
              return newModules;
            });

            // 触发回调
            onTriggered?.(result.pinId, result.words);
          }

          return newRecords;
        });
      } catch (error) {
        console.error("[useInspirationWords] recordOperation error:", error);
      }
    },
    [pageScope, config, lastTriggerTime, onTriggered]
  );

  /**
   * 清空记录
   */
  const clearRecords = useCallback(() => {

    setRecords([ ]);

    setLastTriggerTime(0);
    setDisplayedModules(new Map());

  }, [ ]);


  /**
   * 自动清理过期记录
   */
  useEffect(() => {
    cleanupTimerRef.current = setInterval(() => {
      setRecords((prevRecords) =>
        InspirationWordsService.filterExpired(prevRecords)
      );
    }, 60 * 1000); // 每分钟清理一次

    return () => {
      if (cleanupTimerRef.current) {
        clearInterval(cleanupTimerRef.current);
      }
    };

  }, [ ]);


  return {
    recordOperation,
    displayedModules,
    clearRecords,
  };
}

5.4.4 推荐词组件
设计说明：
推荐词组件基于 Figma 设计稿实现：
1. 样式还原：完全按照 Figma 设计稿的样式实现
2. 埋点集成：集成曝光埋点和点击埋点
3. 交互优化：点击推荐词新标签页打开搜索结果
4. 性能优化：使用 React.memo 避免不必要的重渲染
// components/InspirationRecommendWords/index.tsx

import React from "react";
import TrackerDiv from "@/components/TrackerDiv";
import styles from "./index.module.less";

export interface InspirationRecommendWordsProps {
  /** 推荐词列表 */

  words: string[ ];

  /** 关联的内容ID */
  relatedPinId: string;
}

/**
 * 灵感推荐词组件
 * 基于 Figma 设计稿实现
 */
export const InspirationRecommendWords: React.FC<InspirationRecommendWordsProps> =
  React.memo(({ words, relatedPinId }) => {
    const handleWordClick = (word: string) => {
      // 新标签页打开搜索结果
      const searchUrl = `/search?q=${encodeURIComponent(
        word
      )}&type=pin&source=inspiration_recommend`;
      window.open(searchUrl, "_blank");
    };

    if (!words || words.length === 0) {
      return null;
    }

    return (
      <TrackerDiv
        className={styles.container}
        data-gd-expose="content_expose"
        data-content-type="inspiration_recommend_words"
        data-content-id={relatedPinId}
        data-module-name="灵感推荐词"
      >
        <div className={styles.title}>你可能感兴趣的灵感</div>

        <div className={styles.wordsList}>
          {words.map((word, index) => (
            <TrackerDiv
              key={index}
              className={styles.wordItem}
              onClick={() => handleWordClick(word)}
              data-gd-click="button_click"
              data-button-name="灵感推荐词"
              data-search-word={word}
              data-search-word-type="灵感推荐词"
              data-content-id={relatedPinId}
            >
              {word}
            </TrackerDiv>
          ))}
        </div>
      </TrackerDiv>
    );
  });

InspirationRecommendWords.displayName = "InspirationRecommendWords";

// components/InspirationRecommendWords/index.module.less

.container {
  display: flex;
  flex-direction: column;
  gap: 4px;
  padding: 8px;
  background: #ffffff;
  border: 1px solid #e8eaec;
  border-radius: 8px;
  margin-top: 12px;
}

.title {
  padding: 4px 0;
  font-size: 14px;
  font-weight: 600;
  line-height: 1.3;
  color: #222529;
  text-align: center;
}

.wordsList {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.wordItem {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 52px;
  padding: 4px;
  background: rgba(0, 0, 0, 0.03);
  border-radius: 6px;
  font-size: 14px;
  line-height: 1.3;
  color: #222529;
  cursor: pointer;
  transition: background 0.2s;

  &:hover {
    background: rgba(0, 0, 0, 0.06);
  }
}

5.4.5 组件集成示例
集成说明：
在发现页瀑布流组件中集成灵感词功能：
1. Hook 调用：使用 useInspirationWords Hook，传入页面标识
2. 事件监听：为卡片的四种操作（点击、右键、采集、下载）添加事件处理
3. 条件渲染：根据 displayedModules 判断是否需要渲染推荐词组件
4. 位置控制：推荐词组件渲染在对应内容卡片的下方
// pageComponents/DiscoveryPinList/feature.jsx

import { useInspirationWords } from "@/hooks/useInspirationWords";
import { InspirationRecommendWords } from "@/components/InspirationRecommendWords";
import { OperationType } from "@/types/inspirationWords";

function DiscoveryFeaturePinList() {

  const [dataSource, setDataSource] = useState([ ]);


  // 使用灵感词 Hook
  const { recordOperation, displayedModules } = useInspirationWords({
    pageScope: "discovery",
  });

  // 处理卡片点击
  const handlePinClick = async (pinId: string) => {
    await recordOperation(pinId, OperationType.CLICK);
  };

  // 处理右键点击
  const handlePinContextMenu = async (pinId: string) => {
    await recordOperation(pinId, OperationType.RIGHT_CLICK);
  };

  // 处理采集
  const handlePinCollect = async (pinId: string) => {
    await recordOperation(pinId, OperationType.COLLECT);
  };

  // 处理下载
  const handlePinDownload = async (pinId: string) => {
    await recordOperation(pinId, OperationType.DOWNLOAD);
  };

  return (
    <HBList>
      {dataSource.map((pin) => (
        <div key={pin.id}>
          {/* 渲染卡片 */}
          <PurePinCard
            {...pin}
            onOperate={() => handlePinClick(pin.id)}
            onContextMenu={() => handlePinContextMenu(pin.id)}
            onCollect={() => handlePinCollect(pin.id)}
            onDownload={() => handlePinDownload(pin.id)}
          />

          {/* 根据 displayedModules 判断是否展示推荐词 */}
          {displayedModules.has(pin.id) && (
            <InspirationRecommendWords
              words={displayedModules.get(pin.id)!}
              relatedPinId={pin.id}
            />
          )}
        </div>
      ))}
    </HBList>
  );
}

5.5 搜索底纹词技术设计
5.5.1 设计目标与原则
设计目标：
1. 功能内聚：所有底纹词相关代码集中在一个文件，易于维护
2. 统一数据源：支持多数据源（词推荐 + 运营配置）的自动合并去重
3. 策略化配置：不同页面的底纹词配置通过策略函数统一管理
4. 易于扩展：未来如需复用，可轻松重构为独立模块
设计原则：
1. YAGNI 原则：当前只有搜索框使用，不过度抽象到全局
2. 就近原则：功能代码和使用者在同一目录下
3. 高内聚低耦合：相关代码集中，减少跨文件依赖
5.5.2 分层架构
┌─────────────────────────────────────────────┐
│        配置层 (Config Layer)                 │
│  placeholderStrategies                      │
│  - 管理不同页面的策略                        │
│  - 集中配置底纹词规则                        │
└─────────────────────────────────────────────┘
                     ↓ 使用
┌─────────────────────────────────────────────┐
│          组件层 (Component Layer)            │
│  Header/search                              │
│  - 获取当前页面策略                          │
│  - 调用 Hook 获取底纹词                      │
└─────────────────────────────────────────────┘
                     ↓ 调用
┌─────────────────────────────────────────────┐
│            Hook 层 (Hook Layer)             │
│  useSearchPlaceholder                       │
│  - 状态管理（placeholder, loading）         │
│  - 内置缓存机制                              │
│  - 并行获取多数据源                          │
│  - 自动合并去重                              │
└─────────────────────────────────────────────┘
                     ↓ 调用
┌─────────────────────────────────────────────┐
│        服务层 (Service Layer - 纯函数)       │
│  - fetchPlaceholderWords()                  │
│  - mergePlaceholderWords()                  │
└─────────────────────────────────────────────┘

5.5.3 数据流
数据流说明：
底纹词功能的数据流程简洁清晰：
1. 触发时机：路由变化（router.pathname）时触发 Hook 更新
2. 策略获取：根据当前路由和查询参数，获取对应的底纹词策略
3. 并行请求：同时请求词推荐接口和运营配置接口，提升性能
4. 数据合并：将两个数据源合并去重，词推荐在前，运营配置在后
5. 缓存机制：合并后的结果缓存，避免重复请求
6. 组件渲染：将底纹词数组传给 HBSearch 组件，支持轮播展示
路由变化 / 页面加载
    ↓
getPlaceholderStrategy(pathname, query)
    ↓
useSearchPlaceholder(strategy)
    ↓
并行请求：
├── fetchPlaceholderWords(position)  → apiWords
└── getSearchPlaceholder(position)   → operationWords
    ↓
mergePlaceholderWords(apiWords, operationWords)
    ├── 过滤重复词（保留运营配置）
    └── 合并数组（词推荐在前，运营配置在后）
    ↓
更新 placeholder 状态
    ↓
HBSearch 组件展示（轮播）

5.5.4 完整实现（组件内聚）
文件位置：components/Header/search/useSearchPlaceholder.ts
设计思路：
采用组件内聚的方式，所有底纹词相关代码集中在一个文件中：
● 文件大小：~350 行代码，适中的复杂度
● 包含内容：类型定义 + 配置策略 + 服务函数 + Hook 逻辑
● 核心优势：功能内聚，易于维护和理解，符合 YAGNI 原则
为什么选择组件内聚而非全局放置？
● 当前只有搜索框一个组件使用底纹词功能
● 将代码放在使用者附近，符合就近原则
● 降低认知负担，无需跨多个目录查找代码
● 未来如需复用，可轻松重构为独立模块
// components/Header/search/useSearchPlaceholder.ts

import { useState, useEffect, useCallback, useRef } from "react";
import { getSearchPlaceholder } from "@/services";

// ============ 类型定义 ============

export type PlaceholderPosition = "discovery_recommend" | "material" | string;

export interface PlaceholderStrategy {
  position?: PlaceholderPosition;
  enableApi?: boolean;
  enableOperation?: boolean;

  fixed?: string | string[ ];

}

export interface UseSearchPlaceholderReturn {

  placeholder: string[ ];

  loading: boolean;
  refresh: () => void;
}

// ============ 配置策略 ============

const PLACEHOLDER_STRATEGIES = {
  userPage: (isSelf: boolean) => ({
    enableApi: false,
    enableOperation: false,
    fixed: `搜索${isSelf ? "我的" : "Ta的"}或全部`,
  }),

  boardDetail: {
    enableApi: false,
    enableOperation: false,
    fixed: "搜索该画板的采集或全部",
  },

  discovery: {
    position: "discovery_recommend",
    enableApi: true,
    enableOperation: true,
  },

  material: {
    position: "material",
    enableApi: true,
    enableOperation: true,
  },

  default: {
    enableApi: false,
    enableOperation: false,
    fixed: "搜索",
  },
};

export function getPlaceholderStrategy(
  pathname: string,
  query: any = {},
  extraParams: Record<string, any> = {}
): PlaceholderStrategy {
  // 用户个人主页
  if (
    pathname.includes("/user/[urlname]") &&
    !pathname.includes("/following")
  ) {
    return PLACEHOLDER_STRATEGIES.userPage(extraParams.isSelf || false);
  }

  // 画板详情页
  if (pathname.includes("/boards/[boardId]")) {
    return PLACEHOLDER_STRATEGIES.boardDetail;
  }

  // 素材页
  if (pathname.startsWith("/materials") || query.type === "material") {
    return PLACEHOLDER_STRATEGIES.material;
  }

  // 发现页、首页、关注页、搜索页
  if (
    ["/", "/follow", "/discovery", "/search", "/materials"].includes(pathname)
  ) {
    const position =
      pathname.startsWith("/materials") || query.type === "material"
        ? "material"
        : "discovery_recommend";

    return {
      position,
      enableApi: true,
      enableOperation: true,
    };
  }

  return PLACEHOLDER_STRATEGIES.default;
}

// ============ 服务函数 ============

async function fetchPlaceholderWords(
  position: string,
  limit: number = 10

): Promise<string[ ]> {

  try {
    const response = await fetch("/hb/search-words/placeholder", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ position, limit }),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();

    return data.map((item: any) => item.recommend_word) || [ ];

  } catch (error) {
    console.error("[fetchPlaceholderWords] error:", error);

    return [ ];

  }
}


function mergeWords(apiWords: string[ ], operationWords: string[ ]): string[ ] {

  // 去重：过滤词推荐中与运营配置重复的词
  const filteredApiWords = apiWords.filter(
    (word) => !operationWords.includes(word)
  );

  // 合并：词推荐在前，运营配置在后
  return [...filteredApiWords, ...operationWords];
}

// ============ Hook ============

export function useSearchPlaceholder(
  options: PlaceholderStrategy = {}
): UseSearchPlaceholderReturn {
  const { position, enableApi = true, enableOperation = true, fixed } = options;


  const [placeholder, setPlaceholder] = useState<string[ ]>([ ]);

  const [loading, setLoading] = useState(false);

  const cacheRef = useRef<Map<string, string[ ]>>(new Map());

  const [refreshFlag, setRefreshFlag] = useState(0);

  const refresh = useCallback(() => {
    setRefreshFlag((prev) => prev + 1);

  }, [ ]);


  useEffect(() => {
    // 如果有固定底纹词，直接使用
    if (fixed !== undefined) {
      setPlaceholder(Array.isArray(fixed) ? fixed : [fixed]);
      return;
    }

    // 如果没有 position，使用默认值
    if (!position) {
      setPlaceholder(["搜索"]);
      return;
    }

    // 检查缓存
    const cacheKey = `${position}_${enableApi}_${enableOperation}`;
    if (cacheRef.current.has(cacheKey) && refreshFlag === 0) {
      setPlaceholder(cacheRef.current.get(cacheKey)!);
      return;
    }

    setLoading(true);

    Promise.all([

      enableApi ? fetchPlaceholderWords(position) : Promise.resolve([ ]),

      enableOperation
        ? getSearchPlaceholder({ position })
        : Promise.resolve(null),
    ])
      .then(([apiWords, qingzhouData]) => {
        const operationWords =
          enableOperation && qingzhouData?.words
            ? qingzhouData.words
                .sort((a, b) => a.priority - b.priority)
                .map((item) => item.recommend_word)

            : [ ];


        const mergedWords = mergeWords(apiWords, operationWords);
        const finalWords = mergedWords.length > 0 ? mergedWords : ["搜索"];

        cacheRef.current.set(cacheKey, finalWords);
        setPlaceholder(finalWords);
      })
      .catch((error) => {
        console.error("[useSearchPlaceholder] error:", error);
        setPlaceholder(["搜索"]);
      })
      .finally(() => {
        setLoading(false);
      });
  }, [position, enableApi, enableOperation, fixed, refreshFlag]);

  return {
    placeholder,
    loading,
    refresh,
  };
}

5.5.5 组件使用示例
使用说明：
搜索框组件的改造非常简洁，主要改动点：
1. 导入 Hook：从同目录导入 useSearchPlaceholder 和 getPlaceholderStrategy
2. 获取策略：根据当前路由获取底纹词配置策略
3. 调用 Hook：传入策略配置，自动获取合并后的底纹词
4. 渲染组件：将底纹词数组传给 HBSearch 组件
改造对比：
● 改造前：~70 行逻辑代码混在组件中
● 改造后：~15 行调用代码，逻辑抽离到 Hook
// components/Header/search/index.tsx

import {
  useSearchPlaceholder,
  getPlaceholderStrategy,
} from "./useSearchPlaceholder";

export default function Search({ ... }) {
  const router = useRouter();
  const { user } = useAppStore();

  // 获取当前页面的底纹词策略
  const strategy = useMemo(() => {
    return getPlaceholderStrategy(
      router.pathname,
      router.query,
      { isSelf: user?.urlname === router.query.urlname }
    );
  }, [router.pathname, router.query, user]);

  // 使用统一的底纹词 Hook
  const { placeholder: placeholderWords } = useSearchPlaceholder(strategy);

  // 获取前缀配置（保持原有逻辑）
  const [placeholderPrefix, setPlaceholderPrefix] = useState('');

  useEffect(() => {
    getGrocery<{ placeholderPrefix: string }>('zhrml1vh1b8').then(conf => {
      if (conf?.placeholderPrefix) {
        setPlaceholderPrefix(conf.placeholderPrefix);
      }
    });

  }, [ ]);


  return (
    <HBSearch
      placeholder={placeholderWords}
      placeholderPrefix={placeholderPrefix}
      // ...其他 props
    />
  );
}

5.5.6 设计亮点
1. 组件内聚的优势
将所有底纹词相关代码集中在一个文件中带来的好处：
● 功能集中：类型、配置、服务、Hook 都在一个文件，易于维护
● 降低复杂度：无需跨多个目录查找代码，降低认知负担
● 符合就近原则：功能和使用者在同一目录，符合 React 组件化思维
● 便于理解：新人只需看一个文件就能理解完整的底纹词逻辑
2. vs 全局放置的对比
维度
组件内聚（当前方案）
全局放置（过度设计）
文件数量
1 个文件
4 个文件
代码行数
~350 行
~400 行
查找难度
⭐ 单文件
⭐⭐⭐⭐ 跨 4 个目录
维护成本
⭐ 集中修改
⭐⭐⭐ 多处修改
扩展性
⭐⭐⭐⭐ 需要时再抽离
⭐⭐⭐⭐⭐ 已全局化
适用场景
单一组件使用 ✅
多组件共享
3. 未来扩展路径
如果未来其他组件也需要底纹词功能，重构路径清晰：
● 步骤 1：将文件移至 hooks/useSearchPlaceholder/ 目录
● 步骤 2：拆分为多个模块文件（types.ts, service.ts, hook.ts 等）
● 步骤 3：调整导入路径（成本低）
● 原则：先保持简单，需要时再抽象

📦 六、文件结构
├── types/
│   └── inspirationWords.ts                        # 新增：类型定义
│       ├── OperationType                          # 操作类型枚举
│       ├── OperationRecord                        # 操作记录接口
│       ├── TriggerConfig                          # 触发配置接口
│       └── TriggerResult                          # 触发结果接口
│
├── services/
│   └── inspirationWords.ts                        # 新增：服务层（Class + 静态方法）
│       └── InspirationWordsService                # 灵感词服务类
│           ├── DEFAULT_CONFIG                     # 默认配置
│           ├── MAX_WORDS                          # 推荐词最大数量
│           ├── MAX_AGE                            # 记录最大保留时间
│           ├── fetchRecommendWords()              # 获取推荐词
│           ├── calculateCooccurrence()            # 计算共现词
│           ├── sortWords()                        # 排序推荐词
│           ├── checkTrigger()                     # 检查触发条件
│           ├── processTriggered()                 # 处理触发逻辑（私有）
│           └── filterExpired()                    # 过滤过期记录
│
├── hooks/
│   └── useInspirationWords.ts                     # 新增：Hook 层
│       ├── UseInspirationWordsOptions             # Hook 配置接口
│       ├── UseInspirationWordsReturn              # Hook 返回值接口
│       └── useInspirationWords()                  # Hook 函数
│           ├── useState: records                  # 状态：操作记录
│           ├── useState: lastTriggerTime          # 状态：上次触发时间
│           ├── useState: displayedModules         # 状态：已展示模块
│           ├── recordOperation()                  # 方法：记录操作
│           ├── clearRecords()                     # 方法：清空记录
│           └── useEffect: 自动清理过期记录         # 副作用：定时清理
│
├── components/
│   ├── InspirationRecommendWords/                 # 新增：推荐词模块组件
│   │   ├── index.tsx                              # 组件实现
│   │   └── index.module.less                      # 样式文件
│   └── PurePinCard/
│       └── index.jsx                              # 修改：添加右键点击事件监听
│
├── pageComponents/DiscoveryPinList/
│   └── feature.jsx                                # 修改：集成灵感词功能
│       ├── useInspirationWords()                  # 使用 Hook
│       ├── handlePinClick()                       # 处理点击
│       ├── handlePinContextMenu()                 # 处理右键
│       ├── handlePinCollect()                     # 处理采集
│       ├── handlePinDownload()                    # 处理下载
│       └── 渲染 InspirationRecommendWords         # 根据 displayedModules 渲染
│
└── components/Header/search/
    └── index.tsx                                   # 修改：整合词推荐和运营配置的底纹词

6.2 搜索底纹词文件结构
components/Header/search/
├── index.tsx                                        # 修改：搜索框主组件
│   └── 使用 useSearchPlaceholder Hook
│
├── useSearchPlaceholder.ts                          # 新增：底纹词功能模块（功能内聚）
│   ├── 类型定义
│   │   ├── PlaceholderPosition                     # 位置标识类型
│   │   ├── PlaceholderStrategy                     # 配置策略接口
│   │   └── UseSearchPlaceholderReturn              # Hook 返回值接口
│   │
│   ├── 配置策略
│   │   ├── PLACEHOLDER_STRATEGIES                  # 策略映射表
│   │   └── getPlaceholderStrategy()                # 根据路由获取策略
│   │
│   ├── 服务函数
│   │   ├── fetchPlaceholderWords()                 # 获取词推荐接口的底纹词
│   │   └── mergeWords()                            # 合并多数据源的底纹词
│   │
│   └── Hook
│       └── useSearchPlaceholder()                  # 统一的底纹词管理 Hook
│           ├── useState: placeholder               # 状态：底纹词列表
│           ├── useState: loading                   # 状态：加载状态
│           ├── useRef: cacheRef                    # 缓存：避免重复请求
│           ├── refresh()                           # 方法：刷新底纹词
│           └── useEffect: 获取底纹词               # 副作用：自动获取和合并
│
├── Associate.tsx                                    # 联想词组件
├── EnhancedSuggest.tsx                             # 增强建议组件
└── ...其他组件


⚠️ 七、风险评估与应对
风险点
影响程度
应对方案
操作记录管理缺失
高
在组件中新增状态管理，使用 useState 存储操作历史
右键点击追踪缺失
中
在 PurePinCard 中添加 onContextMenu 事件监听
数据源动态插入复杂度
中
参考现有推荐搜索词插入方式，注意索引处理
触发条件判断性能
中
使用 useMemo 优化判断逻辑
共现词计算性能
中
使用 Map 数据结构优化查找效率
推荐词接口调用频繁
中
使用防抖机制，避免频繁调用
底纹词获取方式冲突
中
确认轻舟接口是否替换，或明确两套数据源的优先级
运营配置获取方式不明确
中
确认运营配置的获取方式（可能是 getGrocery）
推荐词模块持久化
低
通过数据源标识保持展示状态

📊 八、性能考虑
8.1 性能指标
● 操作响应时间：< 100ms
● 推荐词计算时间：< 50ms
● 接口请求延迟：< 500ms
8.2 优化措施
1. 操作记录清理：定时清理超过触发时间范围的记录，避免内存泄漏
2. 共现词计算优化：使用 Map 数据结构，时间复杂度从 O(n²) 优化到 O(n)
3. 接口请求优化：使用防抖机制，避免频繁调用接口
4. 触发条件判断优化：使用 useMemo 缓存判断结果
5. 推荐词模块渲染：使用 React.memo 优化组件渲染

📈 九、埋点方案
9.1 埋点类型
埋点类型
触发时机
事件 ID/事件名
说明
点击埋点
点击推荐词
button_click
记录推荐词点击行为
曝光埋点
推荐词模块展示
content_expose
记录推荐词模块曝光
点击埋点
右键点击内容
material_click
扩展支持右键点击（需新增逻辑）
9.2 埋点实现方式
9.2.1 推荐词点击埋点
<TrackerDiv
  data-gd-click="button_click"
  data-button-name="灵感推荐词"
  data-content-id={word}
  data-search-word={word}
  data-search-word-type="灵感推荐词"
>
  {word}
</TrackerDiv>

9.2.2 推荐词模块曝光埋点
<TrackerDiv
  data-gd-expose="content_expose"
  data-content-type="inspiration_recommend_words"
  data-content-id={relatedPinId}
  data-module-name="灵感推荐词"
>
  {/* 推荐词模块内容 */}
</TrackerDiv>

9.3 埋点参数说明
参数名
类型
必填
说明
示例
event_name
string
是
事件名称
"button_click"
page_nm
string
是
页面名称
"发现页"
button_name
string
是
按钮名称
"灵感推荐词"
search_word
string
否
搜索词
"红色背景"
search_word_type
string
否
搜索词类型
"灵感推荐词"
content_type
string
否
内容类型
"inspiration"

🧪 十、测试方案
10.1 测试范围
1. 功能测试
    ○ 操作行为记录准确性
    ○ 触发条件判断正确性
    ○ 推荐词展示正确性
    ○ 共现词计算准确性
    ○ 搜索底纹词合并展示
2. 兼容性测试
    ○ 不同浏览器兼容性
    ○ 不同屏幕尺寸适配
3. 性能测试
    ○ 操作响应时间
    ○ 推荐词计算性能
    ○ 接口请求性能
10.2 测试用例
灵感词功能测试用例：
1. 用户在 2 分钟内点击 2 个内容，验证是否展示推荐词模块
2. 用户在 3 分钟内点击 3 个内容，验证是否展示推荐词模块
3. 验证 5 分钟内同一触发条件只触发一次
4. 验证共现词计算和排序正确性
5. 验证推荐词点击跳转功能
搜索底纹词功能测试用例：
1. 验证词推荐和运营配置的合并展示
2. 验证去重逻辑正确性
3. 验证排序规则（词推荐在前，运营配置在后）
4. 验证页面切换时底纹词更新

📅 十一、排期计划
阶段
内容
工期
负责人
开发
灵感词功能开发
3 天

开发
搜索底纹词功能开发
2 天

开发
埋点接入
1 天

测试
功能测试、兼容性测试、性能测试
2 天

上线
灰度发布、全量发布
1 天


📝 十二、后续优化
1. 性能优化：考虑将共现词计算移至后端，减少前端计算压力
2. 体验优化：优化推荐词模块的展示动画和交互效果
3. 数据优化：根据用户反馈调整推荐词算法和触发条件
4. 功能扩展：考虑支持更多操作类型触发推荐词展示

🔗 十三、参考资料
13.1 技术参考
● 发现页实现：pages/discovery/index.jsx
● 瀑布流列表：pageComponents/DiscoveryPinList/feature.jsx
● 推荐搜索词实现：components/PinDetail/FullPinList.jsx
● 搜索框实现：components/Header/search/index.tsx
● 卡片组件：components/PurePinCard/index.jsx
● 列表渲染：components/PinList/index.jsx