# 动态规划（Dynamic Programming，DP）

> 把动态规划当成「有记忆的递归 + 系统化推表」来学，而不是一开始就死背状态转移方程。

---

## 一、核心思想：两个前提 + 一个目标

**动态规划**是一种在有「重叠子问题」和「最优子结构」的场景下，通过**保存子问题结果**来避免重复计算、提升效率的算法思路。

- **最优子结构**：大问题的最优解，可以由若干子问题的最优解组合而成  
  例：`F(n) = F(n-1) + F(n-2)`，只要 `F(n-1)` 和 `F(n-2)` 正确，`F(n)` 就能算出来。
- **重叠子问题**：递归/搜索过程中，同一个子问题会被重复计算多次  
  例：求 `F(5)` 时，`F(2)`、`F(3)` 会在递归树里出现很多次。

动态规划的**目标**：在保证正确性的前提下，把这些「重复子问题」的结果记下来/推出来，从而把指数级的复杂度降到多项式，常见为 O(n)、O(n²)。

---

## 二、解题五步法（通用套路）

做 DP 题时，可以按下面 5 步走：

1. **定义状态**：用一个或多个变量表示「子问题」，例如：  
   - 一维：`dp[i]` 表示「前 i 个中的最优值」或「以 i 结尾的最优值」  
   - 二维：`dp[i][j]` 表示「前 i 个、容量 j 时的最优值」等
2. **写状态转移方程**：找到「由小到大」的递推关系，例如：  
   - `dp[i] = dp[i-1] + dp[i-2]`
3. **确定初始值 / 边界条件**：最小规模子问题的答案，例如：  
   - `dp[0]`、`dp[1]` 是多少
4. **确定计算顺序**：  
   - 若使用**自底向上**：一般从小到大循环 i  
   - 若使用**记忆化搜索**：由大到小递归，但会自动先算小规模子问题
5. **实现代码**：  
   - **自顶向下**：递归 + 记忆化（缓存函数结果）  
   - **自底向上**：迭代表格填表

> 牢记：**先想「子问题定义」和「如何从小推大」**，再去写代码。

---

## 三、教学例子：斐波那契数列，从暴力到 DP

### 3.1 问题定义

斐波那契数列：

- F(0) = 0  
- F(1) = 1  
- F(n) = F(n-1) + F(n-2) （n ≥ 2）

问题：给定 n，求 F(n)。

---

### 3.2 暴力递归：指数级复杂度

最直接的写法就是照着数学公式递归：

```typescript
function fib(n: number): number {
  if (n === 0) return 0;
  if (n === 1) return 1;
  return fib(n - 1) + fib(n - 2);
}
```

以 `F(5)` 为例，递归树大致如下，可以看到 `F(2)`、`F(3)` 被多次重复计算：

```mermaid
graph TD
    F5[F(5)]  
    F4_1[F(4)]
    F3_1[F(3)]
    F2_1[F(2)]
    F1_1[F(1)]
    F0_1[F(0)]
    F2_2[F(2)]
    F1_2[F(1)]
    F0_2[F(0)]
    F3_2[F(3)]
    F2_3[F(2)]
    F1_3[F(1)]
    F0_3[F(0)]
    F1_4[F(1)]

    F5 --> F4_1
    F5 --> F3_2

    F4_1 --> F3_1
    F4_1 --> F2_2

    F3_1 --> F2_1
    F3_1 --> F1_2

    F2_1 --> F1_1
    F2_1 --> F0_1

    F2_2 --> F1_3
    F2_2 --> F0_2

    F3_2 --> F2_3
    F3_2 --> F1_4

    F2_3 --> F1_4
    F2_3 --> F0_3
```

**时间复杂度**：约为 O(2ⁿ)，非常慢，只适合作为「递归树 + 重叠子问题」的示范。

---

### 3.3 解法一：记忆化递归（自顶向下）

**想法**：既然重复算了很多次，就把算过的结果记下来，下一次直接用。

#### 状态设计

- `memo[n]` 表示 `F(n)` 的值

#### 状态转移

- 若 `memo[n]` 已经算过：直接返回  
- 否则：`memo[n] = fib(n-1) + fib(n-2)`

#### 代码实现

```typescript
function fibMemo(n: number, memo: number[] = []): number {
  if (n === 0) return 0;
  if (n === 1) return 1;
  if (memo[n] !== undefined) return memo[n];
  memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);
  return memo[n];
}
```

**复杂度**：

- 时间：O(n)，每个 n 只算一次  
- 空间：O(n)（递归栈 + 记忆数组）

---

### 3.4 解法二：自底向上表格法（迭代 DP）

把刚才的「记忆」变成显式的数组，从小到大推：

#### 状态定义

- `dp[i]` 表示 F(i)

#### 状态转移

- `dp[i] = dp[i-1] + dp[i-2]`

#### 初始值

- `dp[0] = 0`  
- `dp[1] = 1`

#### 代码实现

```typescript
function fibDP(n: number): number {
  if (n === 0) return 0;
  if (n === 1) return 1;
  const dp: number[] = new Array(n + 1).fill(0);
  dp[0] = 0;
  dp[1] = 1;
  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  return dp[n];
}
```

**复杂度**：

- 时间：O(n)  
- 空间：O(n)

---

### 3.5 解法三：空间优化（滚动数组）

观察状态转移：`dp[i]` 只依赖 `dp[i-1]` 和 `dp[i-2]`，因此其实只要两个变量：

```typescript
function fibOptimized(n: number): number {
  if (n === 0) return 0;
  if (n === 1) return 1;
  let prev2 = 0; // F(0)
  let prev1 = 1; // F(1)
  for (let i = 2; i <= n; i++) {
    const cur = prev1 + prev2;
    prev2 = prev1;
    prev1 = cur;
  }
  return prev1;
}
```

**复杂度**：

- 时间：O(n)  
- 空间：O(1)

---

### 3.6 三种写法对比

| 解法 | 思路 | 时间复杂度 | 空间复杂度 | 特点 |
|------|------|------------|------------|------|
| 暴力递归 | 按数学公式直接递归 | O(2ⁿ) | O(n) | 易懂但极慢，只适合作演示 |
| 记忆化递归 | 递归 + 缓存结果 | O(n) | O(n) | 思路接近暴力，改动小 |
| 自底向上 + 空间优化 | 循环推表 + 滚动数组 | O(n) | O(1) | 代码高效、面试常用写法 |

---

## 四、做 DP 题时可以怎么想？

1. **先确认是不是 DP 题**  
   - 是否存在「最优子结构」？  
   - 是否存在「重叠子问题」？  
2. **先用递归把问题“说清楚”**  
   - 写出「当前状态」与「更小状态」的关系（哪怕先不考虑效率）  
3. **把递归改成记忆化**  
   - 加一个缓存数组/哈希表，避免重复计算  
4. **再改成自底向上**  
   - 用数组/表从小到大推，理清计算顺序  
5. **最后再看是否能优化空间**  
   - 只依赖前几个状态时，可以滚动数组降到 O(1)

> 建议练习顺序：先多做一维 DP（如爬楼梯、打家劫舍），再上二维 DP（网格路径、编辑距离），最后再看背包、区间 DP 等进阶类型。

