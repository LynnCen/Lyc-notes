# 强化

## 第一章

**1. 翻译程序、解释程序、汇编程序、编译程序的区别和联系是什么?**

翻译程序有两种:一种是编译程序，它将高级语言源程序一次全部翻译成目标程序，只要源程序不变，就无须重新翻译。
另一种是解释程序，它将源程序的 一条语句翻译成对应的机器目标代码，并立即执行，然后翻译下一条源程序语句并执行，直至所有源程序语句全部被翻译并执行 完。所以解释程序的执行过程是翻译一句执行一句，并且不会生成目标程序。

汇编程序也是 一种语言翻译程序，它把汇编语言源程序翻译为机器语言程序。

编译程序与汇编程序的区别:若源语言是诸如C、C++、Java等“高级语言”，而目标语言是 诸如汇编语言或机器语言之类的 “ 低级语言”，则这样的一 个翻译程序称为编译程序。若源语言 是汇 编语言，而目标语言是机器语言，则这样的一 个翻译程序称为汇编程序。


**2. 字长、机器字长、指令字长、存储字长的区别和联系**

字长是指CPU内部用于整数运算的数据通路的宽度，因此字长等于CPU内部用于整数运算的运算器位数和通用寄存器宽度。

指令字长：一个指令字中包含的二进制代码的位数（半字长指令、双字长指令）

存储字长：一个存储单元存储的二进制代码的位数

**3. 性能指标**

时钟周期：CPU工作的最小时间单元

主频 = 1/时钟周期

CPI：一条指令所需要的时钟周期数

IPS：每秒执行多少条指令 IPS = 主频 / 平均CPI

MIPS：每秒执行多少百万条指令  = 主频/ (CPI x 10^6)

MIPS 百万 10^6 
GIPS 十亿 10^9
TIPS 万亿 10^12 
PIPS 千万亿 10^15  亿亿10^16

执行时间 = 指令条数 x CPI / 主频

## 第二章

1. 二进制、八进制和十六进制相互转换

常见的二进制和十进制数：

- (2^{10} = 1024) ⚠️
- (2^{11} = 2048)
- (2^{12} = 4096)
- (2^{13} = 8192)
- (2^{14} = 16,384)
- (2^{15} = 32,768)
- (2^{16} = 65,536) ⚠️
- (2^{17} = 131,072)
- (2^{18} = 262,144)
- (2^{19} = 524,288)
- (2^{20} = 1,048,576)

注意带小数的计算：整数部分除基取余法，小数部分乘基取整法上左下右

2. 原码、补码、反码、移码

表示范围（对称性）、0表示（是否唯一）、相互转换

原码表示范围：-(2^n -1) ~ (2^n -1)，关于原点对称

0表示有+0和-0之分，不唯一，一般用来表示真值

补码表示范围：-(2^n) ~ (2^n - 1)，不对称，比原码多一个-2^n

0表示唯一

反码表示范围：了解 各位取反

移码：真值+ 偏置值，0表示唯一

原码转补码：正数相同，负数原码按位取反末位+1，或者从右往左数第一个1，后续的1都改为0

3. 无符号整数和有符号整数的转换

采用补码表示

char、short、int、long的位数

char默认是无符号数，其他默认带符号数，相互类型转换

大转小（截断），小转大（补位-> 零拓展和符号拓展）

4. 运算器部件和加法器的组成

ALU、移位器、状态寄存器（PSW）、通用寄存器

5. 逻辑移位和算术移位

各自的移位规则？

带符号数和无符号数分别采用哪种移位？

移位操作的溢出判断和精度丢失问题

6. 加减运算

注意题目中给的是真值还是机器数（可能为补码）

减法变加法

7. 溢出判断

溢出的前提：符号相同相加、符号相异相减、

溢出判断的3种方法：一位符号位、双符号位、

8. OF、SF、ZF、CF所表示的含义 

OF：溢出标志，对无符号数无意义，用于有符号数的溢出判断 OF = Cn 异或 Cn-1 符号位进位和最高数位进位异或

CF：进位标志，对有符号数无意义，用于无符号数的溢出判断 CF = Sub 异或 Cout

ZF：零标志位，均适用。

SF：符号位，对无符号数无意义

9.  无符号数和有符号数加减运算后CF和OF的值

10. 乘除法运算 error❌

乘法实现原理

乘法指令溢出判断

11. 浮点数的表示格式

符号 + 尾数 + 基数^阶数

上溢和下溢判断

12. 浮点数的规格化

左归：尾数左移，阶码-1

右归：尾数右移，阶码+1

13. IEEE754标准

单精度浮点数格式（32位）：1一位符号位，8位阶码，23位尾数（最高位隐含1所以拓展到24位）

双精度浮点数格式（64位）：一位符号位，11位阶码，52位尾数

阶码使用移码e表示（真值+偏置值127） 1～254，真值范围-126 ～ 127

单精度最小值和最大值

1.0 x 2^-126     1.111111... x 2^127 = (2-2^-23) x 2^127 

阶码全0全1的含义（正零、负零、正无穷、负无穷）

0.23个11如何表示？ 2-2^-23

非规格化数的满足条件：阶码全0 尾数不为0 

非规格化正数和负数：尾数 x 2^-126

14. 浮点数的加减运算

对阶 （小阶向大阶看齐）阶码相等

尾数加减（注意隐含位）

尾数规格化（左归右归）

尾数舍入（丢失精度）不影响结果是否溢出

溢出判断

15. 类型转换后数值变化

int转float：float所表示的范围比int大得多，所以float能表示int，但float23位尾数不能表示int32位尾数，存在精度丢失。

int转double或 float转double：double所表示的范围以及尾数精度都要比int和float所表示的大，故能完全表示

double转float：float所表示的范围更小，故可能发生溢出和精度丢失

float或者double转int：大范围转小范围存在溢出截断和精度丢失

16. 数据的大端小端存储

大端方式：先高字节，再低字节

小端方式：先低字节，再高字节

17. 对齐方式

边界对齐：

边界不对齐：

