# 第 2 章 进程与线程

## 进程与线程

### 进程的概念和特征

1. 进程的定义

   进程控制块（PCB）：一种数据结构，用来描述进程的基本情况和活动过程，进而控制和管理进程。

   进程实体-进程（进程映像）：由程序段、相关的数据段和 PCB 组成。

   定义：
   （1）进程是程序的一次执行。
   （2）进程是一个程序及其数据在处理机上顺序执行时所发生的活动。
   （3）进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。
   总结：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位

2. 进程的特征

   （1）动态性。
   （2）并发性。
   （3）独立性。
   （4）异步性。

### 进程的组成

1. 进程控制块

（1）进程描述信息
（2）进程控制和管理信息
（3）资源分配清单
（4）处理机相关信息（CPU 上下文）

2. 程序段

3. 数据段（原始数据）

经过处理和加工后变成程序段

![alt text](./img/PCB内容.png)

**进程管理中的数据结构**

1. 操作系统中用于管理控制的数据结构

   资源信息表（进程信息表）：对每个资源和每个进程都设置了一个数据结构，用于表征其实体，其中包含了资源或进程的标识、描述、状态等信息以及一批指针。

   ![7](./img/操作系统控制表的一般结构.png)

2. 进程控制块 PCB 的作用

（1）作为独立运行基本单位的标志。PCB 是进程存在与系统中的唯一标志。
（2）能实现间断性运行方式。
（3）提供进程管理所需要的信息。
（4）提供进程调度所需要的信息。
（5）实现与其他进程的同步与通信。

3. 进程控制块中的信息

   1）进程标识符

   用于唯一地标识一个进程。
   （1）外部标识
   （2）内部标识

   2）处理机状态

   处理机信息也称为处理的上下文，主要是由处理机的各种寄存器中的内容组成。
   通用寄存器（用户可见寄存器）、指令计数器、程序状态字 PSW、用户栈指针、

   3）进程调度信息

   进程状态、进程优先级、进程调度所需其他信息、事件

   4）进程控制信息

   程序和数据的地址、进程同步和通信机制、资源清单、链接指针

4. 进程控制块的组织方式

   （1）线性方式
   （2）链接方式
   （3）索引方式
   ![8](./img/PCB%E9%93%BE%E6%8E%A5%E6%96%B9%E5%BC%8F.png)

![9](./img//PCB索引链接方式.png)

### 进程的状态与转换

#### 进程的基本状态及转换

1. 进程的三种基本状态

   （1）就绪态。指进程已处于准备好运行的状态，即进程已分配到除 CPU 以外的所有必要资源后，只要再获得 CPU，便可立即执行。

   （2）执行态。已获得 CPU，其程序正在执行的状态。

   （3）阻塞态。指正在执行的进程由于发生某事件（I/O，申请缓冲区失败）等暂时无法继续执行时的状态，亦即进程的执行收到阻塞。

   区别就绪态和阻塞态:就绪态是指进程仅缺少 CPU，只要获得 CPU 就立即运行;而阻塞 态是指进程需要其他资源 (除了 CPU)或等待某一事件

2. 三种基本状态的转换

   ![4](./img/进程的三种基本状态及其转换.png)

3. 创建状态和终止状态

1）创建状态

进程正在被创建，尚未转到就绪态。创建进程需要多个步骤:首先申请一个空白 PCB，并向 PCB 中填写用于控制和管理进程的信息;然后为该进程分配运行时所必须的资源:最后将该进程转入就绪态并插入就绪队列。但是，如果进程所需的资源尚不能得到满足，如内存不足，则创建工作尚未完成，进程此时所处的状态称为创建态。

2）终止状态

等待 OS 进行善后处理，最后将其 PCB 清空，并将 PCB 空间返回给系统。

![5](./img/进程的物种基本状态转换.png)

#### 挂起操作和进程状态的转换

1. 挂起操作的引入
   （1）终端用户的需要。
   （2）父进程请求。
   （3）负荷调节的需要
   （4）操作系统的需要
2. 引入挂起原语操作后三个进程状态的转换
   （1）活动就绪->静止就绪。
   （2）活动阻塞->静止阻塞。
   （3）静止就绪->活动就绪。
   （4）静止阻塞->活动阻塞
   ![6](./img/具有挂起状态的进程状态图.png)
3. 引入挂起操作后五个进程状态的转换

![6](./img/具有创建、终止和挂起状态.png)

### 前驱图和程序执行

#### 前驱图

作用：用于描述程序执行先后顺序
定义：一个有向无循环图（DAG），用于描述进程之间执行的先后顺序。
每个结点可用来表示一个进程或程序段，乃至一条语句，结点之间的有向边表示两个节点之间存在的偏序或前驱关系。
初始结点：没有前驱的结点
终止结点：没有后继的结点。
重量（weight）：每个结点含有一个重量，用于表示该结点所含的程序量或程序的执行时间。

#### 程序顺序执行

1. 程序的顺序执行
2. 程序顺序执行时的特征
   顺序性：
   封闭性：程序在封闭的环境下运行，运行时独占全机资源，资源的状态只有本程序才能改变它，程序一旦开始执行，其执行结果不受外界因素影响
   可再现性：只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它时从头到尾不停顿地执行，还是走走停停，都可获得相同的结果。

#### 程序并发执行

只有在不存在前驱关系的程序之间才可能并发执行，否则无法并发执行。

1. 程序的并发执行
2. 程序并发执行时的特征
   （1）间断性。程序在并发执行时，由于它们共享系统资源，以及完成同一项任务而相互合作，致使在这些并发执行的程序之间形成了相互制约的关系。“执行-暂停-执行”
   （2）失去封闭性。当系统中存在着多个可以并发执行的程序时，系统中的各种资源将为它们所共享，而这些资源的状态也由这些程序来改变，致使其中任一程序在运行时，其环境都必然会收到其他程序的影响。
   （3）不可再现性。程序在并发执行时，由于失去了封闭性，也将导致其又失去了可再现性。

### 进程控制

进程控制一般由 OS 的内核中的原语来实现

#### 操作系统内核

系统态 ： 又称为管态，也称为内核态，它具有较高的特权，能执行一切指令，访问所有寄存器和存储区，传统的 OS 都在系统态运行。
用户态：又称为目态，具有较低特权的执行状态，仅能执行规定的指令，访问特定的寄存器和存储区，一般情况下，应用程序只能在用户态运行，不能取执行 OS 指令及访问 OS 区域，以防止应用程序对 OS 的破坏。

1. 支撑功能
   （1）中断处理。
   （2）时钟管理
   （3）原语操作。由若干条指令组成的，用于完成一定功能的一个过程。它与一般过程的区别在于，它们是“原子操作”，指一个操作中的所有动作要么全不做，要么全做。它是一个不可分割的基本单位，因此原语在执行过程中不允许被中断，原子操作在系统态下执行，常驻内存。
2. 资源管理功能
   （1）进程管理
   （2）存储器管理
   （3）设备管理

#### 进程的创建

1. 进程的层次结构
2. 进程图
   描述进程家族关系的有向树
3. 引起创建进程的事件
   （1）用户登陆
   （2）作业调度
   （3）提供服务
   （4）应用请求
4. 进程的创建
   （1）申请空白的 PCB，为新进程申请获得唯一的数字标识符，并从 PCB 集合中索取一个空白 PCB
   （2）为新进程分配其运行所需的资源，包括各种物理和逻辑资源，如内存、文件、I/O 设备和 CPU 时间等。
   （3）初始化进程控制块（PCB）
   （4）如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。

#### 进程的终止

1. 引起进程终止的事件
   （1）正常结束
   （2）异常结束。
   常见的异常事件：
   越界错：指程序所访问的存储区，已越出该进程的区域
   保护错：指进程试图取访问一个不允许访问的资源或文件，或者以不适当的方式进程访问，例如，去写一个只读文件。
   非法指令：指程序试图去执行一条不存在的指令
   特权指令错：指用户进程试图去执行一条只允许 OS 执行的指令
   运行超时：指进程的执行时间超过了指定的最大值
   等待超时：指进程等待某事件的时间超过了规定的最大值
   算术运算错：指进程试图去执行一个被禁止的运算
   I/O 故障：指 I/O 过程中发生了错误
   （3）外界干预
2. 进程的终止过程

#### 进程的阻塞与唤醒

1. 引起进程阻塞和唤醒的事件
   （1） 向系统请求共享资源失败。
   （2）等待某种操作的完成。
   （3）新数据尚未到达。
   （4）等待新任务的到达
2. 进程阻塞过程
   通过调用阻塞原语 block 将自己阻塞。
3. 进程唤醒过程
   调用 wakeup 原语唤醒：首先将被阻塞的进程从等待该事件的阻塞队列中移出，将其 PCB 中的现行状态由阻塞态改为就绪，然后再将 PCB 插入到就绪队列中。

#### 进程的挂起与激活

1. 进程的挂起
   使用 suspend 挂起原语将指定进程或处于阻塞状态的进程挂起。活动就绪 -> 静止就绪 。
   活动阻塞 -> 静止阻塞
2. 进程的激活过程
   使用 active 原语激活进程。

### 进程同步

#### 进程同步的基本概念

同步机制的主要任务：对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能按照一定的规则（或时序）共享系统资源

1. 两种形式的制约关系
   1）间接相互制约关系
   访问共享系统资源（同一时间只允许一个进程访问），所以形成了间接相互制约关系。
   2）直接相互制约关系
   完成同一项任务的两个进程而相互合作。例如 A 输入进程，B 计算进程，共享一个缓冲区，进程 A 向 B 提供数据，B 从缓冲区中取出数据。
2. 临界资源
   对临界资源（打印机、磁带机）的访问，诸进程之间应采用互斥方式。
   生产者-消费者
3. 临界区
   临界区：把每个进程中访问临界资源的那段代码称为临界区。
4. 同步机制应遵循的规则
   （1）空闲让进：当无进程进入自己的临界区，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。
   （2）忙则等待：当已有进程进入临界区时，表明临界资源正在被访问，因而其它试图进入临界区的进程必须等待，以保证对临界资源的护持访问。
   （3）有限等待：对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态。
   （4）让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态

   ![10](./img/临界区的循环进程.png)

#### 硬件同步机制

1. 关中断
2. 利用 Test-and-Set 指令实现互斥
3. 利用 Swap 指令实现进程互斥
   不符合“让权等待”

#### 信号量机制

1. 整型信号量
   S：表示资源数目的整型量 S
   wait（S）和 signal（S） -> P、V 操作
   ![10](./img/PV.png)
   未遵循让权等待
2. 记录型信号量
   ![11](./img/记录型信号量.png)
3. AND 型信号量
   基本思想：将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放。只要尚有一个资源分配给进程，其它所有可能其它所有可能为之分配的资源也不分配给它。要么把它所请求的资源全部分配到进程，要么一个也不分配
   ![12](./img/AND型信号量.png)
4. 信号量集

#### 信号量的应用

1. 利用信号量实现进程互斥
   设置 mutex 为互斥信号量，初始值为 1，取值范围为（-1，0，1）。当 mutex=1 时，表示两个进程皆未进入需要互斥的临界区；当 mutex=0 时，表示有一个进程进入临界区运行，另一个必须等待，挂入阻塞队列；当 mutex = -1 时，表示有一个进程正在临界区运行，另一个进程因等待而阻塞在信号量队列中，需要被当前已在临界区运行的进程退出时唤醒。
   ![12](./img/临界区互斥.png)
   PV 必须成对的出现。缺失 P 将会导致系统混乱，不能保证对临界区资源的互斥访问；缺少 V 操作将会使临界资源永远不被释放，从而使等待该资源而阻塞的进程不能被唤醒。
2. 利用信号量实现前趋关系
   设置信号量 S，初始值为 0，欲使 P1 进程的 S1 语句要在 P2 进程中的 S2 语句之前执行。
   在进程 P1 中，执行 S1；signal(s)；
   在进程 P2 中，wait(s);执行 S2；
   ![13](./img/利用信号量实现前驱.png)

#### 管程机制

1. 管程的定义
   代表共享资源的数据结构以及由对该共享数据实施操作的一组过程所组成的资源管理程共同构成了一个操作系统的资源管理模块，称为管程
   组成：
   （1）管程的名称
   （2）局部于管程的共享数据结构说明
   （3）对该数据结构进行操作的一组过程
   （4）对局部于管程的共享数据设置初始值
   管程包含了面向对象的思想，它将表征共享资源的数据结构及其数据结构操作的一组过程，包括同步机制，都集中并封装在一个对象内部，隐藏了实现细节
   ![14](./img/管程.png)
2. 条件变量
   conditionx,y
   (1)x.wait:正在调用管程的进程因 x 条件被阻塞或挂起，则调用 x.wait 将自己插入到 x 条件的等待队列上，并释放管程，直到 x 条件变化。
   （2）x.signal:正在调用管程的进程发现 x 条件发生了变化，则调用 x.signal，重新启动一个因 x 条件而阻塞或挂起的进程，如果存在多个这样的进程，则选择其中的一个，如果没有，则继续执行原进程

### 经典进程的同步问题

#### 生产者-消费者

1. 利用记录型信号量解决生产者-消费者问题

假定在生产者和消费者之间的公用缓冲池中具有 n 个缓冲区，这时可利用 mutex 互斥信号量实现进程对缓冲池的互斥使用。利用信号量 empty 和 full 分别表示缓冲池中空缓冲区和满缓冲区的数量。只要缓冲池未满，生产者便可将消息送入缓冲池；只要缓冲池未空，消费者便可从缓冲池中取走一个消息。
**注意：** 每个程序用于实现互斥的 wait 和 signal 必须成对地出现；其次，对资源信号量 empty 和 full 的 PV 操作，同样也需要成对出现，但它们分别处于不同的程序中。

![15](./img/记录型信号量解决生产-消费者问题.png)

2. 利用 AND 信号量解决生产者-消费者问题
   用 Swati(empty,mutex)来代替 wait(empty)和 wait(mutex)

![16](./img/利用AND信号量解决生产者-消费者问题.png)

3. 利用管程解决生产者-消费者问题
   PC 管程描述：
   ![17](./img/PC管程.png)
   管程解决描述：
   ![18](./img/PC管程解决生产者-消费者问题.png)

### 哲学家进餐问题

一个圆桌，五把椅子，五个碗，五只筷子。只有拿到两只筷子才能进餐。

1. 利用记录型信号量解决哲学家进餐问题
   筷子是临界资源，在一段时间内只允许一位哲学家使用。
   ![19](./img/哲学家进餐问题.png)

当哲学家饥饿时，总是先去拿他左边的筷子，再去拿他右边的筷子。
问题：可能发生死锁，如果五位哲学家同时拿起左边的筷子，再去拿右边的筷子时，都会因为无筷子可拿而导致无限期等待。
解决办法：
（1）至多只允许有四位哲学家同时取拿左边的筷子，最终能保证至少有一位哲学家能够进餐，并在用完时，能释放出他用过的两只筷子，从而使更多的哲学家能够进餐。
（2）仅当哲学家的左右两只筷子均可用时，才允许他拿起筷子进餐。
（3）规定奇数号哲学家先拿他左边的筷子，然后再去拿右边的筷子；而偶数号哲学家则相反。那么，1，2 号哲学家竞争 1 号筷子；3，4 号哲学家竞争 3 号筷子。即五位哲学家都先去竞争奇数筷子，获得后再去竞争偶数号筷子，最后总会有一位哲学家能获得两只筷子而进餐。

2. 利用 AND 信号量机制解决哲学家进餐问题
   ![20](./img/利用AND信号量机制解决哲学家进餐问题%20.png)

#### 读者-写者问题

一个数据文件可被多个进程共享，读该文件的进程称为“Reader 进程”，其它进程称为“Writer 进程”。允许多个进程同时读一个共享对象，因为读操作不会使数据文件混乱。但不允许一个 Writer 进程和其它 Reader 进程或 Writer 进程同时访问共享对象。-> Writer 进程必须和其它进程互斥的访问共享对象。

1. 利用记录型信号量解决读者-写者问题
   Wmutex：Reader 进程与 Writer 进程的互斥信号量
   Readcount：正在读的进程数
   Rmutex：Readcount：正在读的进程数是一个可被多个 Reader 进程访问的临界资源，所以为它设置一个互斥信号量 rmutex。

   ![21](./img/利用记录型信号量解决读者-写者问题.png)

2. 利用信号量集解决读者-写者问题

### 进程通信

#### 进程通信的类型

1. 共享存储器系统
   （1）基于共享数据结构的通信方式
   （2）基于共享存储区的通信方式
2. 管道(pipe)通信系统
   所谓”管道“，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又称为 pipe 文件。向管道(共享文件)提供输入的发送进程（即写进程）以字符流形式将大量的数据送入管道；而接受管道输出的接受进程（即读进程）则从管道中接受数据。由于发送进程和接受进程时利用管道进行通信的，故成为了管道通信。
   为了协调双方的通信，管道机制必须提供以下三方面的协调功能：
   （1）互斥
   （2）同步
   （3）确定对方是否存在，只有确定了对方已存在时才能进行通信。
3. 消息传递系统
   在该机制中，进程不必借助任何共享存储区或数据结构，而是以格式化的消息为单位，将通信的数据封装在消息中，并利用操作系统提供的一组通信命令（原语），在进程间进行消息传递，完成进程间的数据交换。
   （1）直接通信方式：指发送进程利用 OS 所提供的发送原语，直接把消息发送给目标进程；
   （2）间接通信方式：指发送和接受进程，都通过共享中间实体（邮箱）的方式进行消息的发送和接受，完成进程间的通信。
4. 客户机-服务器系统

1）套接字
2）远程过程调用和远程方法调用

#### 消息传递通信的实现方式

1. 直接消息传递系统
   1）直接通信原语
   （1）对称寻址方式
   send（receiver，message）
   receive（sender，message）
   （2）非对称寻址方式
   send（P，message）
   seceive（id，message）
   （2）消息的格式
   （3）进程的同步方式
   （4）通信链路
2. 信箱通信
   1）信箱的结构
   （1）信箱头
   （2）信箱体
   2）信箱通信原语
   （1）信箱的创建和撤销
   （2）消息的发送和接受。
   3）信箱的类型
   （1）私用邮箱
   （2）公用邮箱
   （3）共享邮箱

#### 直接消息传递系统实例

1. 消息缓冲队列通信机制中的数据结构
   （1）消息缓冲区
   （2）PCB 中有关通信的数据项
2. 发送原语
3. 接受原语

### 线程的基本概念

#### 线程的引入

1. 进程的两个基本属性

（1）进程是一个可拥有资源的独立单位。
（2）进程是一个可独立调度和分配的基本单位。

2. 程序并发执行所需付出的时空开销
3. 线程--作为调度和分配的基本单位

#### 线程与进程的比较

1. 调度的基本单位
   引入线程的 OS 中，线程作为调度和分配的基本单位，因而线程是能够独立运行的基本单位当线程切换时，仅需保存和设置少量寄存器内容，切换代价远低于进程。在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，必然就会引起进程的切换。
2. 并发性
   在引入线程的 OS 中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，甚至还允许在一个进程中的所有线程都能并发执行。同样，不同进程中的线程也能并发执行。
3. 拥有资源
   进程可以拥有资源，并作为你系统中拥有资源的一个基本单位。然后，线程本身并不拥有系统资源，而是仅有一点必不可少的、能够保证独立运行的资源。允许多个线程共享该进程所拥有的所有的资源：属于同一进程的所有线程都具有相同的地址空间，意味着，线程可以访问该地址空间中的每一个虚拟地址；还可以访问进程所拥有的资源。
4. 独立性
   同一进程的不同线程的之间的独立性要比不同进程之间的独立性低得多。因为线程会共享同一进程的资源，访问所属进程地址空间中的所有地址。
5. 系统开销
   OS 创建或撤销进程所付出的开销要比线程所付出的开销大的多
6. 支持多处理机系统

#### 线程的状态和线程控制块

1. 线程运行的三个状态
   （1）执行状态
   （2）就绪状态
   （3）阻塞状态
2. 线程控制块 TCB
   （1）线程标识符
   （2）一组寄存器，程序计数器 PC、状态寄存器和通用寄存器
   （3）线程运行的状态
   （4）优先级
   （5）线程专有存储区
   （6）信号屏蔽
   （7）堆栈指针
3. 多线程 OS 中的进程属性
   （1）进程是一个可拥有资源的基本单位。
   （2）多个线程可并发执行。
   （3）进程已不是可执行的实体。在多线程中，把线程作为独立运行（或称为调度）的基本单位。

### 线程的实现

#### 线程的实现方式

1. 内核支持线程
   （1）在多处理器系统中，内核能够同时调度同一进程中的多个线程并执行；
   （2）如果在进程中的一个线程被阻塞了，内核可以调度该进程中的其它线程占有处理器运行，也可以运行其它进程中的线程。
   （3）内核支持线程具有很小的数据结构和堆栈，线程的切换比较快，切换开销小；
   （4）内核本身可以采用多线程技术，可以提高系统的执行速度和效率。
   缺点：同一进程中，从一个线程切换到另一个线程，需要从用户态转到核心态，这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的，系统开销较大。
2. 用户级线程 ULT
   用户级线程是在用户空间中实现的。对线程的创建、撤销、同步与通信等功能，都无需内核的支持，即用户及线程是与内核无关的。
   （1）线程的切换不需要轮换到内核空间。
   （2）调度算法可以是进程专用的。
   （3）用户及线程的实现与 OS 平台无关，因为对于线程管理的代码属于用户程序的一部分，所有的应用程序都可以对之共享。
   缺点：
   （1）系统调用的阻塞问题。当一个线程执行系统调用，那么所属进程将被阻塞，该进程下的所有线程也会被阻塞。
   （2）在单纯的用户及线程实现方式中，多线程应用不能利用多处理机进程多重处理的优点，内核每次分配给一个进程的仅有一个 CPU，因此，进程中仅有一个线程能执行，其它线程只能等待。
3. 组合方式
   将用户及线程和内核支持线程两种方式进行组合。
   （1）多对一模型，即将用户及线程映射到一个内核控制线程。
   多个线程同属于一个进程，运行在该进程的空间。仅当用户线程需要访问内核时，才将其映射到一个内核控制线程上，但每次只允许一个线程进程映射。
   优点：线程管理的开销小，效率高。
   缺点：如果一个线程阻塞，那么整个进程都会阻塞，任何时刻，只有线程能够访问内核。
   （2）一对一模，即将每个用户及线程映射到一个内核支持线程。
   优点：每个用户及线程都设置一个内核控制线程与之连接，当一个线程阻塞时，允许调度另一个线程运行，提供更好的并发功能
   缺点：每创建一个用户及线程，响应地需要创建一个内核线程，开销较大，因此需要限制整个系统的线程数。
   （3）多对多模型，即将许多用户线程映射到同样的数量或更少数量的内核线程上。结合了上述两个模型的优点。
   ![22](./img/多线程模型.png)

#### 线程的实现

1. 内核支持线程的实现
2. 用户及线程的实现
   （1）运行时系统
   （2）内核控制线程

#### 线程的创建和终止

1. 线程的创建
2. 线程的终止
