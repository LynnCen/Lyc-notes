# 操作系统强化

## 第一章 计算机系统概述

1. 操作系统的基本特征 

并发、共享、虚拟、异步

2. OS的目标和功能

处理机管理、存储器管理、设备管理、文件管理

高内聚 低耦合

3. 内核态和用户态的转换

用户态使用trap指令转移到内核态

4. 操作系统初始化过程

5. 中断过程和多重中断过程

6. 系统调用处理过程和CPU状态变化

7. 中断和异常

区分中断和异常的区别（外中断和内中断）

问题点：操作系统初始化过程、中断过程

## 第二章 进程和线程

1. 进程和线程的概念

进程是资源分配的基本单位、线程是CPU调度的基本单位

2. 进程和线程的组成

进程控制块（PCB）：进程创建后，常驻内存，包含PID，进程控制管理信息，CPU状态信息，恢复现场的信息，时间片，资源分配信息等

程序段（CPU调度执行的代码）

数据段（加工后称为程序段）

线程控制块TCB

3. 进程的状态与转换

3状态模型和5状态模型

3状态：就绪、运行、阻塞

5状态:创建、就绪、阻塞态、运行态、终止态

就绪只缺少CPU，阻塞缺少其他资源（除CPU之外的）

引起进程状态转换的事件

就绪——〉执行 获得CPU

执行->阻塞 io阻塞

创建->就绪 除CPU外的资源分配完毕

阻塞->就绪 申请到io资源

运行->就绪 时间片使用完毕 被高优先级抢占


4. 进程控制

原语：不可再分的基本单位

父子进程的关系：子进程的虚拟地址空间是父进程的副本（不是子集 相互隔离的），父子进程可共享io设备

进程创建的过程：分配pid pcb 内存 io等资源 初始化pcb的内容 

进程的终止的操作：根据pid 找到pcb 回收io资源 终止该进程以及子孙进程，删除pcb

进程的阻塞和唤醒：

阻塞：申请io资源失败时，使用阻塞原语将该进程从执行态变为阻塞态，将该进程PCB插入对应事件等待队列

唤醒：所需要的io操作已完成或所期待的数据已到达时，使用唤醒原语（wakeup）将该进程从阻塞变成就绪

5. 进程通信

共享存储、消息传递、管道通信

管道通信：管道是一个特殊的文件，理解为buffer，大小固定，采用读者-写者模式管理该buffer，由父进程创建，从而实现子进程与父进程间的通信。

父进程与子进程之间的通信：

管道（Pipe）、命名管道（FIFO）、共享内存（Shared Memory）、消息队列（Message Queue）、信号（Signal）

独立进程之间的通信：

套接字（Socket）、共享内存（Shared Memory）、消息队列（Message Queue）、信号（Signal）、文件（File）、命名管道（FIFO）

6. 线程

线程的基本概念：最基本的CPU执行单元

线程3状态模型和切换

线程控制块TCB

线程和进程的区别：

CPU调度是以进程为基本单位，故同属于一个进程的线程切换 并不会引起CPU调度

进程切换和线程切换哪些会引起CPU调度？

资源分配是以进程为单位

线程的实现方式：

用户级线程： CPU不感知，线程切换不需要转换到内核空间，线程切换在用户控制下 CPU调度以进程为单位，存在线程阻塞，不能发挥多CPU的优势。

内核级线程：线程管理在内核空间中实现，能发挥多CPU的优势，避免线程阻塞，线程切换速度快（线程的调度在内核），但同一进程的线程切换需要从用户态转移到和心态，系统开销大

组合方式：

多线程模型

7. CPU调度调度和切换的时机

创建新进程、进程终止或异常结束、因io阻塞、io唤醒、高优先级、时间片等

不能进行调度：处理中断的过程中、原子操作

8. 性能计算

CPU利用率：有效工作时间 / 有效工作时间 + CPU空闲等待时间

系统吞吐量：

周转时间、平均周转时间、带权周转时间、平均带权周转时间

等待时间

响应时间

9. 进程切换操作和前后CPU模式变化

CPU模式包含用户态和核心态

上下文切换实际上就是PCB信息切换的过程

上下文切换在内核态

用户态和内核态之间的切换称为模式切换

10. 调度算法

先来先服务FCFS

短作业优先SJF：存在饥饿现象

高响应比优先调度：等待时间 + 要求服务时间 / 要求服务时间

优先级调度： 抢占式和非抢占式，静态优先级和动态优先级，优先级的设定：系统>用户，交互>非交互，IO>计算

时间片轮转：

多级反馈队列：队列间采用优先级调度，各队列使用FCFS和时间片轮转

11. 临界区和临界资源的区别

临界区：访问临界资源的那段代码

临界资源：一次仅允许一个进程使用的资源称为临界资源

12. 同步和互斥的关系

同步表示确定前后执行关系，直接制约关系

互斥

13. 临界区互斥必须遵循的规则

空闲让进

忙则等待

有限等待

让权等待 （进程不能进入临界区 应立即释放处理器）

14. 实现互斥的方法

软件实现

单标志法：交替进入临界区 需要由另外一个进程唤醒 若该进程不再进入临界区 则另一个也无法进入 违背空闲让进 

双标志先检查：违背忙则等待 

双标志后检查：违背空闲让进，会出现饥饿现象 违背有限等待

peterson算法：综合1和3的算法思想，使用flag[]解决互斥访问问题，利用turn解决饥饿问题 ，未遵循让权等待

硬件实现：

中断屏蔽方法 使用关中断 临界区 开中断

硬件指令 TestAndSet指令  使用ts给资源上锁 结束后 解锁

硬件指令 Swap

未遵循让权等待，会导致饥饿现象

互斥锁：使用硬件实现，存在忙等现象

信号量：PV操作

整型信号量 未遵循让权等待

记录型信号量 使用链表存储等待资源的进程 解决让权等待

15. 利用信号量实现同步和互斥

确定进程数

分析同步和互斥关系

编写步骤

确定信号量和初始值

对缓冲区一般需要互斥访问

生产者和消费者问题：

生产者和消费者对缓冲区的访问是互斥的

只有生产了数据，消费者才能消费，故存在同步关系

读者写者问题：



哲学家进餐 （一次性将所有资源全部拿走 否则释放资源）

吸烟者问题

16. 管程

实现共享资源同步互斥的操作管理的一组数据结构

x.wait 将该进程插入到因x条件阻塞的队列中

x.sign 唤醒x队列的进程

17. 死锁的定义

多个进程相互等待对方手里的资源而形成的僵局

18. 死锁和饥饿的区别

死锁是成环型等待，饥饿是独自等待

19. 死锁产生的必要条件

互斥条件

不可剥夺

请求并保持 进程至少保持了一个资源 但又请求一个新的资源请求，该资源被其他进程占有

循环等待条件 存在一个资源循环等待链

20. 死锁的处理策略

死锁预防 破坏4个必要条件 （事先预防策略）

避免死锁 资源分配 防止进入不安全状态 银行家算法 （事先预防策略）需要事先知道所有资源请求

死锁的检测 ：

不需要事先知道所有资源请求 

资源分配图 找孤点 化去其请求边和分配边（怎么找孤点？）

死锁定理：s状态的资源分配图是不可完全简化的

死锁的解除：资源剥夺、撤销进程、进程回退

21.  内存管理

内存管理实际上就是os对内存的划分和动态分配

内存空间的分配和回收、地址转换、内容空间扩容（虚拟技术）、存储保护（越界判断）

22. 编译、链接和装入

编译：生成目标模块

链接：将目标模块组合在一起形成一个完整的装入模块

装入：将装入模块装入内存

装入可分为绝对装入（逻辑地址和物理地址一致）、可重定位装入（将逻辑地址在装入时全部修改为物理地址）、动态运行时装入（在运行时才将相对地址转为绝对地址 设置一个重定位寄存器）

链接的方式：

静态链接：运行前，将所有模块链接成一个完整的装入模块，不再拆开，需要修改个模块的相对地址（每个模块都是从0开始的相对地址）

装入时动态链接：在装入内存时，边装入边链接，所有的的库在加载时就被解析好，程序执行时，所有的链接都已完成

运行时动态链接：在程序执行时需要某目标模块时，才对它进行链接，并不是一开始就将所有模块都链接装入内存，所以节省内存空间

23. 逻辑地址和物理地址

编译后的所有模块都是从0地址开始编址，使用相对地址（逻辑地址），用户程序和程序员只知道逻辑地址

地址重定位：逻辑地址转换为物理地址，操作部件MMU

24. 内存的保护

保护各进程内存空间互不影响

在cpu中设置一对上下限寄存器表示该进程的内存空间的上下界（物理地址），在地址转换过程中判断是否越界

使用界地址寄存器（表示进程最大的逻辑地址）判断是否越界，再加上重定位寄存器转换为物理地址

25. 内存共享

实现进程通信的一种方式IPC，多个进程可以同时读写同一块物理区域（读写时，需要使用同步机制解决数据不一致性）

