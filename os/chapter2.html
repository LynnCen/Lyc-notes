<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第 2 章 进程与线程 | 林岑LynnCenʘᴗʘ </title>
    <meta name="description" content="林岑的成长之路，包含前端常用知识、源码阅读笔记、各种奇淫技巧、日常提效工具等">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/Lyc-notes/assets/style.zTotE9en.css" as="style">
    <link rel="preload stylesheet" href="/Lyc-notes/vp-icons.css" as="style">
    
    <script type="module" src="/Lyc-notes/assets/app.DYqgUO6Z.js"></script>
    <link rel="preload" href="/Lyc-notes/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/framework.BlF7juqX.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/theme.2sNx1VVe.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/katex.ChWnQ-fc.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/dagre-OKDRZEBW.Mdd6QYcC.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/c4Diagram-VJAJSXHY.DzQeUDSo.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/flowDiagram-4HSFHLVR.D33mejOo.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/erDiagram-Q7BY3M3F.BFG_gqqn.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/gitGraphDiagram-7IBYFJ6S.BsMKk1fV.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/ganttDiagram-APWFNJXF.BsKmggFX.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/infoDiagram-PH2N3AL5.CKxtW967.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/pieDiagram-IB7DONF6.DrBxHyUP.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/quadrantDiagram-7GDLP6J5.NwBzXuen.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/xychartDiagram-VJFVF3MP.BFnt9D54.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/requirementDiagram-KVF5MWMF.1ztfj_GE.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/sequenceDiagram-X6HHIX6F.DnLfAPcN.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/classDiagram-GIVACNV2.Cj-e75v1.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/classDiagram-v2-COTLJTTW.Cj-e75v1.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/stateDiagram-DGXRK772.ZS2Xr_39.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/stateDiagram-v2-YXO3MK2T.1RRs-_3s.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/journeyDiagram-U35MCT3I.B9Xh16E4.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/timeline-definition-BDJGKUSR.YuJWBYCC.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/mindmap-definition-ALO5MXBD.Dmo2__-0.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/kanban-definition-NDS4AKOZ.DefDOI7R.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/sankeyDiagram-QLVOVGJD.BruFFYky.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/diagram-VNBRO52H.duZEZfBy.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/diagram-SSKATNLV.CvVhQBDx.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/blockDiagram-JOT3LUYC.DAYDESuS.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/architectureDiagram-IEHRJDOE.Dn3zGPRD.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/virtual_mermaid-config.DDnGl6nM.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/os_chapter2.md.BLnWXLeo.lean.js">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/favicon.ico">
    <link rel="mask-icon" href="/favicon.ico" color="#3eaf7c">
    <meta name="msapplication-TileImage" content="/favicon.ico">
    <meta name="msapplication-TileColor" content="#000000">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-f10846f5><!--[--><!--]--><!--[--><span tabindex="-1" data-v-632d5625></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-632d5625>Skip to content</a><!--]--><!----><header class="VPNav" data-v-f10846f5 data-v-8e081fe2><div class="VPNavBar" data-v-8e081fe2 data-v-9e2c1dcb><div class="wrapper" data-v-9e2c1dcb><div class="container" data-v-9e2c1dcb><div class="title" data-v-9e2c1dcb><div class="VPNavBarTitle has-sidebar" data-v-9e2c1dcb data-v-946fc7c5><a class="title" href="/Lyc-notes/" data-v-946fc7c5><!--[--><!--]--><!--[--><img class="VPImage logo" src="/Lyc-notes/LynnCenLogo.png" alt data-v-8a84c329><!--]--><span data-v-946fc7c5>林岑LynnCenʘᴗʘ </span><!--[--><!--[--><!--[--><!--[--><img class="visitor" src="https://visitor-badge.laobi.icu/badge?page_id=LynnCen.Lyc-notes" onerror="this.style.display=&#39;none&#39;" data-v-124f1dab><!--]--><!--]--><!--]--><!--]--></a></div></div><div class="content" data-v-9e2c1dcb><div class="content-body" data-v-9e2c1dcb><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9e2c1dcb><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9e2c1dcb data-v-7c1d5340><span id="main-nav-aria-label" class="visually-hidden" data-v-7c1d5340> Main Navigation </span><!--[--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7c1d5340 data-v-b5647d99><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b5647d99><span class="text" data-v-b5647d99><!----><span data-v-b5647d99>WebFront</span><span class="vpi-chevron-down text-icon" data-v-b5647d99></span></span></button><div class="menu" data-v-b5647d99><div class="VPMenu" data-v-b5647d99 data-v-400cd38b><div class="items" data-v-400cd38b><!--[--><!--[--><div class="VPMenuLink" data-v-400cd38b data-v-147f7b30><a class="VPLink link" href="/Lyc-notes/Javascript/basic/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js" data-v-147f7b30><!--[--><span data-v-147f7b30>Javascript基础</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-400cd38b data-v-147f7b30><a class="VPLink link" href="/Lyc-notes/Javascript/Advance/executionContext" data-v-147f7b30><!--[--><span data-v-147f7b30>Javascript进阶</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-400cd38b data-v-147f7b30><a class="VPLink link" href="/Lyc-notes/typescript/%E8%AE%B0%E5%BD%95" data-v-147f7b30><!--[--><span data-v-147f7b30>Typescript</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-400cd38b data-v-147f7b30><a class="VPLink link" href="/Lyc-notes/browser/Chrome%E6%9E%B6%E6%9E%84" data-v-147f7b30><!--[--><span data-v-147f7b30>浏览器原理</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7c1d5340 data-v-b5647d99><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b5647d99><span class="text" data-v-b5647d99><!----><span data-v-b5647d99>ComputerBasics</span><span class="vpi-chevron-down text-icon" data-v-b5647d99></span></span></button><div class="menu" data-v-b5647d99><div class="VPMenu" data-v-b5647d99 data-v-400cd38b><div class="items" data-v-400cd38b><!--[--><!--[--><div class="VPMenuGroup" data-v-400cd38b data-v-f087fe80><p class="title" data-v-f087fe80>计算机组成原理</p><!--[--><!--[--><div class="VPMenuLink" data-v-f087fe80 data-v-147f7b30><a class="VPLink link" href="/Lyc-notes/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/chapter1" data-v-147f7b30><!--[--><span data-v-147f7b30>计算机组成原理基础</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-400cd38b data-v-f087fe80><p class="title" data-v-f087fe80>数据结构</p><!--[--><!--[--><div class="VPMenuLink" data-v-f087fe80 data-v-147f7b30><a class="VPLink link" href="/Lyc-notes/dataStructure/chapter1" data-v-147f7b30><!--[--><span data-v-147f7b30>数据结构基础</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-f087fe80 data-v-147f7b30><a class="VPLink link" href="/Lyc-notes/dataStructure/chapter1_ex" data-v-147f7b30><!--[--><span data-v-147f7b30>课后习题</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-400cd38b data-v-f087fe80><p class="title" data-v-f087fe80>操作系统OS</p><!--[--><!--[--><div class="VPMenuLink" data-v-f087fe80 data-v-147f7b30><a class="VPLink link" href="/Lyc-notes/os/chapter1" data-v-147f7b30><!--[--><span data-v-147f7b30>操作系统基础</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-400cd38b data-v-f087fe80><p class="title" data-v-f087fe80>计算机网络</p><!--[--><!--[--><div class="VPMenuLink" data-v-f087fe80 data-v-147f7b30><a class="VPLink link" href="/Lyc-notes/%E8%AE%A1%E7%BD%91/chapter1" data-v-147f7b30><!--[--><span data-v-147f7b30>计算机网络基础</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-400cd38b data-v-f087fe80><p class="title" data-v-f087fe80>408</p><!--[--><!--[--><div class="VPMenuLink" data-v-f087fe80 data-v-147f7b30><a class="VPLink link" href="/Lyc-notes/408/2009" data-v-147f7b30><!--[--><span data-v-147f7b30>408真题</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7c1d5340 data-v-b5647d99><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b5647d99><span class="text" data-v-b5647d99><!----><span data-v-b5647d99>Frameworks</span><span class="vpi-chevron-down text-icon" data-v-b5647d99></span></span></button><div class="menu" data-v-b5647d99><div class="VPMenu" data-v-b5647d99 data-v-400cd38b><div class="items" data-v-400cd38b><!--[--><!--[--><div class="VPMenuLink" data-v-400cd38b data-v-147f7b30><a class="VPLink link" href="/Lyc-notes/react/core/intro" data-v-147f7b30><!--[--><span data-v-147f7b30>React</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-400cd38b data-v-147f7b30><a class="VPLink link" href="/Lyc-notes/Vue/basic" data-v-147f7b30><!--[--><span data-v-147f7b30>Vue</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7c1d5340 data-v-b5647d99><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b5647d99><span class="text" data-v-b5647d99><!----><span data-v-b5647d99>Engineering</span><span class="vpi-chevron-down text-icon" data-v-b5647d99></span></span></button><div class="menu" data-v-b5647d99><div class="VPMenu" data-v-b5647d99 data-v-400cd38b><div class="items" data-v-400cd38b><!--[--><!--[--><div class="VPMenuLink" data-v-400cd38b data-v-147f7b30><a class="VPLink link" href="/Lyc-notes/webpack/performance" data-v-147f7b30><!--[--><span data-v-147f7b30>WebPack</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-400cd38b data-v-147f7b30><a class="VPLink link" href="/Lyc-notes/node/packages" data-v-147f7b30><!--[--><span data-v-147f7b30>Node</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-400cd38b data-v-147f7b30><a class="VPLink link" href="/Lyc-notes/vite/basic" data-v-147f7b30><!--[--><span data-v-147f7b30>Vite</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-400cd38b data-v-147f7b30><a class="VPLink link" href="/Lyc-notes/git/basic" data-v-147f7b30><!--[--><span data-v-147f7b30>Git</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Lyc-notes/interview/js" tabindex="0" data-v-7c1d5340 data-v-296ca46a><!--[--><span data-v-296ca46a>Interview</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9e2c1dcb data-v-dab16e3d><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-dab16e3d data-v-0c819a23 data-v-3c1c02f8><span class="check" data-v-3c1c02f8><span class="icon" data-v-3c1c02f8><!--[--><span class="vpi-sun sun" data-v-0c819a23></span><span class="vpi-moon moon" data-v-0c819a23></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9e2c1dcb data-v-bd623931 data-v-fbe1c74b><!--[--><a class="VPSocialLink no-icon" href="https://github.com/LynnCen" aria-label="github" target="_blank" rel="noopener" data-v-fbe1c74b data-v-16abb3a2><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9e2c1dcb data-v-2992d219 data-v-b5647d99><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-b5647d99><span class="vpi-more-horizontal icon" data-v-b5647d99></span></button><div class="menu" data-v-b5647d99><div class="VPMenu" data-v-b5647d99 data-v-400cd38b><!----><!--[--><!--[--><!----><div class="group" data-v-2992d219><div class="item appearance" data-v-2992d219><p class="label" data-v-2992d219>外观</p><div class="appearance-action" data-v-2992d219><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-2992d219 data-v-0c819a23 data-v-3c1c02f8><span class="check" data-v-3c1c02f8><span class="icon" data-v-3c1c02f8><!--[--><span class="vpi-sun sun" data-v-0c819a23></span><span class="vpi-moon moon" data-v-0c819a23></span><!--]--></span></span></button></div></div></div><div class="group" data-v-2992d219><div class="item social-links" data-v-2992d219><div class="VPSocialLinks social-links-list" data-v-2992d219 data-v-fbe1c74b><!--[--><a class="VPSocialLink no-icon" href="https://github.com/LynnCen" aria-label="github" target="_blank" rel="noopener" data-v-fbe1c74b data-v-16abb3a2><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9e2c1dcb data-v-50cd93f9><span class="container" data-v-50cd93f9><span class="top" data-v-50cd93f9></span><span class="middle" data-v-50cd93f9></span><span class="bottom" data-v-50cd93f9></span></span></button></div></div></div></div><div class="divider" data-v-9e2c1dcb><div class="divider-line" data-v-9e2c1dcb></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-f10846f5 data-v-5480154b><div class="container" data-v-5480154b><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-5480154b><span class="vpi-align-left menu-icon" data-v-5480154b></span><span class="menu-text" data-v-5480154b>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-5480154b data-v-0b6d591d><button data-v-0b6d591d>返回顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-f10846f5 data-v-5bc92255><div class="curtain" data-v-5bc92255></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-5bc92255><span class="visually-hidden" id="sidebar-aria-label" data-v-5bc92255> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-99eec3d8><section class="VPSidebarItem level-0 has-active" data-v-99eec3d8 data-v-1d2c2992><div class="item" role="button" tabindex="0" data-v-1d2c2992><div class="indicator" data-v-1d2c2992></div><h2 class="text" data-v-1d2c2992>操作系统基础</h2><!----></div><div class="items" data-v-1d2c2992><!--[--><div class="VPSidebarItem level-1 is-link" data-v-1d2c2992 data-v-1d2c2992><div class="item" data-v-1d2c2992><div class="indicator" data-v-1d2c2992></div><a class="VPLink link link" href="/Lyc-notes/os/chapter1" data-v-1d2c2992><!--[--><p class="text" data-v-1d2c2992>第一章 操作系统引论</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1d2c2992 data-v-1d2c2992><div class="item" data-v-1d2c2992><div class="indicator" data-v-1d2c2992></div><a class="VPLink link link" href="/Lyc-notes/os/chapter2" data-v-1d2c2992><!--[--><p class="text" data-v-1d2c2992>第二章 进程与线程</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1d2c2992 data-v-1d2c2992><div class="item" data-v-1d2c2992><div class="indicator" data-v-1d2c2992></div><a class="VPLink link link" href="/Lyc-notes/os/chapter3" data-v-1d2c2992><!--[--><p class="text" data-v-1d2c2992>第三章 内存管理</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1d2c2992 data-v-1d2c2992><div class="item" data-v-1d2c2992><div class="indicator" data-v-1d2c2992></div><a class="VPLink link link" href="/Lyc-notes/os/chapter4" data-v-1d2c2992><!--[--><p class="text" data-v-1d2c2992>第四章 文件管理</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1d2c2992 data-v-1d2c2992><div class="item" data-v-1d2c2992><div class="indicator" data-v-1d2c2992></div><a class="VPLink link link" href="/Lyc-notes/os/chapter5" data-v-1d2c2992><!--[--><p class="text" data-v-1d2c2992>第五章 磁盘和固态硬盘</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1d2c2992 data-v-1d2c2992><div class="item" data-v-1d2c2992><div class="indicator" data-v-1d2c2992></div><a class="VPLink link link" href="/Lyc-notes/os/%E5%BC%BA%E5%8C%96" data-v-1d2c2992><!--[--><p class="text" data-v-1d2c2992>强化</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-f10846f5 data-v-aafb2a2e><div class="VPDoc has-sidebar has-aside" data-v-aafb2a2e data-v-c8ec17ab><!--[--><!--]--><div class="container" data-v-c8ec17ab><div class="aside" data-v-c8ec17ab><div class="aside-curtain" data-v-c8ec17ab></div><div class="aside-container" data-v-c8ec17ab><div class="aside-content" data-v-c8ec17ab><div class="VPDocAside" data-v-c8ec17ab data-v-7cfcad99><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-7cfcad99 data-v-35f90c72><div class="content" data-v-35f90c72><div class="outline-marker" data-v-35f90c72></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-35f90c72>本页目录</div><ul class="VPDocOutlineItem root" data-v-35f90c72 data-v-dca7e412><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-7cfcad99></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-c8ec17ab><div class="content-container" data-v-c8ec17ab><!--[--><!--]--><main class="main" data-v-c8ec17ab><div style="position:relative;" class="vp-doc _Lyc-notes_os_chapter2" data-v-c8ec17ab><div><h1 id="第-2-章-进程与线程" tabindex="-1">第 2 章 进程与线程 <a class="header-anchor" href="#第-2-章-进程与线程" aria-label="Permalink to &quot;第 2 章 进程与线程&quot;">​</a></h1><h2 id="进程与线程" tabindex="-1">进程与线程 <a class="header-anchor" href="#进程与线程" aria-label="Permalink to &quot;进程与线程&quot;">​</a></h2><h3 id="进程的概念和特征" tabindex="-1">进程的概念和特征 <a class="header-anchor" href="#进程的概念和特征" aria-label="Permalink to &quot;进程的概念和特征&quot;">​</a></h3><ol><li><p>进程的定义</p><p>进程控制块（PCB）：一种数据结构，用来描述进程的基本情况和活动过程，进而控制和管理进程。</p><p>进程实体-进程（进程映像）：由程序段、相关的数据段和 PCB 组成。</p><p>定义：</p><p>（1）进程是程序的一次执行。</p><p>（2）进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</p><p>（3）进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</p><p>总结：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</p></li><li><p>进程的特征</p><p>（1）动态性。 （2）并发性。 （3）独立性。 （4）异步性。</p></li></ol><h3 id="进程的组成" tabindex="-1">进程的组成 <a class="header-anchor" href="#进程的组成" aria-label="Permalink to &quot;进程的组成&quot;">​</a></h3><ol><li>进程控制块</li></ol><p>（1）进程描述信息 （2）进程控制和管理信息 （3）资源分配清单 （4）处理机相关信息（CPU 上下文）</p><ol start="2"><li><p>程序段</p></li><li><p>数据段（原始数据）</p></li></ol><p>经过处理和加工后变成程序段</p><p><img src="/Lyc-notes/assets/PCB%E5%86%85%E5%AE%B9.jCzW9kjk.png" alt="alt text"></p><p><strong>进程管理中的数据结构</strong></p><ol><li><p>操作系统中用于管理控制的数据结构</p><p>资源信息表（进程信息表）：对每个资源和每个进程都设置了一个数据结构，用于表征其实体，其中包含了资源或进程的标识、描述、状态等信息以及一批指针。</p><p><img src="/Lyc-notes/assets/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6%E8%A1%A8%E7%9A%84%E4%B8%80%E8%88%AC%E7%BB%93%E6%9E%84.CukUOIHA.png" alt="7"></p></li><li><p>进程控制块 PCB 的作用</p></li></ol><p>（1）作为独立运行基本单位的标志。PCB 是进程存在与系统中的唯一标志。</p><p>（2）能实现间断性运行方式。</p><p>（3）提供进程管理所需要的信息。</p><p>（4）提供进程调度所需要的信息。</p><p>（5）实现与其他进程的同步与通信。</p><ol start="3"><li><p>进程控制块中的信息</p><p>1）进程标识符</p><p>用于唯一地标识一个进程。 （1）外部标识 （2）内部标识</p><p>2）处理机状态</p><p>处理机信息也称为处理的上下文，主要是由处理机的各种寄存器中的内容组成。 通用寄存器（用户可见寄存器）、指令计数器、程序状态字 PSW、用户栈指针、</p><p>3）进程调度信息</p><p>进程状态、进程优先级、进程调度所需其他信息、事件</p><p>4）进程控制信息</p><p>程序和数据的地址、进程同步和通信机制、资源清单、链接指针</p></li><li><p>进程控制块的组织方式</p><p>（1）线性方式 （2）链接方式 （3）索引方式 <img src="/Lyc-notes/assets/PCB%E9%93%BE%E6%8E%A5%E6%96%B9%E5%BC%8F.dneqpn5Q.png" alt="8"></p></li></ol><p><img src="/Lyc-notes/assets/PCB%E7%B4%A2%E5%BC%95%E9%93%BE%E6%8E%A5%E6%96%B9%E5%BC%8F.BV8Me7MX.png" alt="9"></p><h3 id="前驱图" tabindex="-1">前驱图 <a class="header-anchor" href="#前驱图" aria-label="Permalink to &quot;前驱图&quot;">​</a></h3><p>作用：用于描述程序执行先后顺序</p><p>定义：一个有向无循环图（DAG），用于描述进程之间执行的先后顺序。</p><p>每个结点可用来表示一个进程或程序段，乃至一条语句，结点之间的有向边表示两个节点之间存在的偏序或前驱关系。 初始结点：没有前驱的结点</p><p>终止结点：没有后继的结点。</p><p>重量（weight）：每个结点含有一个重量，用于表示该结点所含的程序量或程序的执行时间。</p><h4 id="程序顺序执行" tabindex="-1">程序顺序执行 <a class="header-anchor" href="#程序顺序执行" aria-label="Permalink to &quot;程序顺序执行&quot;">​</a></h4><ol><li><p>程序的顺序执行</p></li><li><p>程序顺序执行时的特征</p><p>顺序性：</p><p>封闭性：程序在封闭的环境下运行，运行时独占全机资源，资源的状态只有本程序才能改变它，程序一旦开始执行，其执行结果不受外界因素影响</p><p>可再现性：只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它时从头到尾不停顿地执行，还是走走停停，都可获得相同的结果。</p></li></ol><h4 id="程序并发执行" tabindex="-1">程序并发执行 <a class="header-anchor" href="#程序并发执行" aria-label="Permalink to &quot;程序并发执行&quot;">​</a></h4><p>只有在不存在前驱关系的程序之间才可能并发执行，否则无法并发执行。</p><ol><li><p>程序的并发执行</p></li><li><p>程序并发执行时的特征</p><p>（1）间断性。程序在并发执行时，由于它们共享系统资源，以及完成同一项任务而相互合作，致使在这些并发执行的程序之间形成了相互制约的关系。“执行-暂停-执行”</p><p>（2）失去封闭性。当系统中存在着多个可以并发执行的程序时，系统中的各种资源将为它们所共享，而这些资源的状态也由这些程序来改变，致使其中任一程序在运行时，其环境都必然会收到其他程序的影响。</p><p>（3）不可再现性。程序在并发执行时，由于失去了封闭性，也将导致其又失去了可再现性。</p></li></ol><h3 id="进程的状态与转换" tabindex="-1">进程的状态与转换 <a class="header-anchor" href="#进程的状态与转换" aria-label="Permalink to &quot;进程的状态与转换&quot;">​</a></h3><ol><li><p>进程的三种基本状态</p><p>（1）就绪态。指进程已处于准备好运行的状态，即进程已分配到除 CPU 以外的所有必要资源后，只要再获得 CPU，便可立即执行。</p><p>（2）执行态。已获得 CPU，其程序正在执行的状态。</p><p>（3）阻塞态。指正在执行的进程由于发生某事件（I/O，申请缓冲区失败）等暂时无法继续执行时的状态，亦即进程的执行收到阻塞。</p><p>区别就绪态和阻塞态:就绪态是指进程仅缺少 CPU，只要获得 CPU 就立即运行;而阻塞 态是指进程需要其他资源 (除了 CPU)或等待某一事件</p></li><li><p>三种基本状态的转换</p></li></ol><ul><li><p>就绪态一运行态:处于就绪态的进程被调度后，获得 CPU 资源(分派 CPU 的时间片)，于是进程由就绪态转换为运行态。</p></li><li><p>运行态一就绪态:处于运行态的进程在时间片用完后，不得不让出 CPU，从而进程由运行态转换为就绪态。此外，在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程序将正在执行的进程转换为就绪态，让更高优先级的进程执行。</p></li><li><p>运行态一阻塞态:进程请求某一资源(如外设)的使用和分配或等待某一事件的发生(如 1/O 操作的完成)时，它就从运行态转换为阻塞态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。</p></li><li><p>阻塞态一就绪态:进程等待的事件到来时，如 I/O 操作完成或中断结束时，中断处理程序必须将相应进程的状态由阻塞态转换为就绪态。</p></li></ul><p><img src="/Lyc-notes/assets/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2.KRABCbow.png" alt="4"></p><ol start="3"><li>创建状态和终止状态</li></ol><p>(1）创建状态</p><p>进程正在被创建，尚未转到就绪态。创建进程需要多个步骤:首先申请一个空白 PCB，并向 PCB 中填写用于控制和管理进程的信息;然后为该进程分配运行时所必须的资源:最后将该进程转入就绪态并插入就绪队列。但是，如果进程所需的资源尚不能得到满足，如内存不足，则创建工作尚未完成，进程此时所处的状态称为创建态。</p><p>(2）终止状态</p><p>等待 OS 进行善后处理，最后将其 PCB 清空，并将 PCB 空间返回给系统。</p><p><img src="/Lyc-notes/assets/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%A9%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.BBrk5nZX.png" alt="5"></p><ol start="4"><li>挂起操作和进程状态的转换</li></ol><p>挂起操作的引入:</p><p>（1）终端用户的需要。 （2）父进程请求。 （3）负荷调节的需要 （4）操作系统的需要</p><p>引入挂起原语操作后三个进程状态的转换</p><p>（1）活动就绪-&gt;静止就绪。 （2）活动阻塞-&gt;静止阻塞。 （3）静止就绪-&gt;活动就绪。 （4）静止阻塞-&gt;活动阻塞 <img src="/Lyc-notes/assets/%E5%85%B7%E6%9C%89%E6%8C%82%E8%B5%B7%E7%8A%B6%E6%80%81%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE.KksGE6dy.png" alt="6"></p><ol start="5"><li>引入挂起操作后五个进程状态的转换</li></ol><p><img src="/Lyc-notes/assets/%E5%85%B7%E6%9C%89%E5%88%9B%E5%BB%BA%E3%80%81%E7%BB%88%E6%AD%A2%E5%92%8C%E6%8C%82%E8%B5%B7%E7%8A%B6%E6%80%81.DiA6WWc4.png" alt="6"></p><h3 id="进程控制" tabindex="-1">进程控制 <a class="header-anchor" href="#进程控制" aria-label="Permalink to &quot;进程控制&quot;">​</a></h3><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。在操作系统中，一般将进程控制用的程序段称原语，原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。</p><h4 id="操作系统内核" tabindex="-1">操作系统内核 <a class="header-anchor" href="#操作系统内核" aria-label="Permalink to &quot;操作系统内核&quot;">​</a></h4><p>系统态 ： 又称为<strong>管态</strong>，也称为内核态，它具有较高的特权，能执行一切指令，访问所有寄存器和存储区，传统的 OS 都在系统态运行。</p><p>用户态：又称为目态，具有较低特权的执行状态，仅能执行规定的指令，访问特定的寄存器和存储区，一般情况下，应用程序只能在用户态运行，不能取执行 OS 指令及访问 OS 区域，以防止应用程序对 OS 的破坏。</p><ol><li><p>支撑功能</p><p>（1）中断处理。</p><p>（2）时钟管理</p><p>（3）原语操作。由若干条指令组成的，用于完成一定功能的一个过程。它与一般过程的区别在于，它们是“原子操作”，指一个操作中的所有动作要么全不做，要么全做。它是一个不可分割的基本单位，因此原语在执行过程中不允许被中断，原子操作在系统态下执行，常驻内存。</p></li><li><p>资源管理功能</p><p>（1）进程管理</p><p>（2）存储器管理</p><p>（3）设备管理</p></li></ol><h4 id="进程的创建" tabindex="-1">进程的创建 <a class="header-anchor" href="#进程的创建" aria-label="Permalink to &quot;进程的创建&quot;">​</a></h4><blockquote><p>父进程与子进程的关系和特点(2020)</p></blockquote><p>允许一个进程创建另一个进程，此时创建者称为父进程，被创建的进程称为子进程。子进程 可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源还给父进程。 此外，在撤销父进程时，通常也会同时撤销其所有的 子进程。</p><ol><li><p>进程的层次结构</p></li><li><p>进程图 描述进程家族关系的有向树</p><blockquote><p>导致创建进程的操作 (2010)</p></blockquote></li><li><p>引起创建进程的事件</p><p>（1）用户登陆</p><p>（2）作业调度</p><p>（3）提供服务</p><p>（4）应用请求</p></li><li><p>进程的创建</p><p>（1）申请空白的 PCB，为新进程申请获得唯一的数字标识符，并从 PCB 集合中索取一个空白 PCB</p><p>（2）为新进程分配其运行所需的资源，包括各种物理和逻辑资源，如内存、文件、I/O 设备和 CPU 时间等。</p><p>（3）初始化进程控制块（PCB）</p><p>（4）如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。</p></li></ol><h4 id="进程的终止" tabindex="-1">进程的终止 <a class="header-anchor" href="#进程的终止" aria-label="Permalink to &quot;进程的终止&quot;">​</a></h4><ol><li><p>引起进程终止的事件</p><p>（1）正常结束</p><p>（2）异常结束。</p><p>常见的异常事件：</p><p>越界错：指程序所访问的存储区，已越出该进程的区域</p><p>保护错：指进程试图取访问一个不允许访问的资源或文件，或者以不适当的方式进程访问，例如，去写一个只读文件。</p><p>非法指令：指程序试图去执行一条不存在的指令</p><p>特权指令错：指用户进程试图去执行一条只允许 OS 执行的指令</p><p>运行超时：指进程的执行时间超过了指定的最大值</p><p>等待超时：指进程等待某事件的时间超过了规定的最大值</p><p>算术运算错：指进程试图去执行一个被禁止的运算</p><p>I/O 故障：指 I/O 过程中发生了错误</p><p>（3）外界干预</p><p>指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。</p></li><li><p>进程的终止过程</p></li></ol><p>操作系统终止进程的过程如下(终止原语):</p><p>1)根据被终止进程的标识符，检索出该进程的 PCB，从中读出该进程的状态。</p><p>2)若被终止进程处于运行状态，立即终止该进程的执行，将 CPU 资源分配给其他进程。</p><p>3)若该进程还有子孙进程，则通常需将其所有子孙进程终止 (有些系统无此要求)。</p><p>4)将该进程所拥有的全部资源，或归还给其父进程，或归还给操作系统。</p><p>5)将该 PCB 从所在队列(链表)中删除。</p><h4 id="进程的阻塞与唤醒" tabindex="-1">进程的阻塞与唤醒 <a class="header-anchor" href="#进程的阻塞与唤醒" aria-label="Permalink to &quot;进程的阻塞与唤醒&quot;">​</a></h4><ol><li><p>引起进程阻塞和唤醒的事件</p><p>（1）向系统请求共享资源失败。</p><p>（2）等待某种操作的完成。</p><p>（3）新数据尚未到达。</p><p>（4）等待新任务的到达</p></li><li><p>进程阻塞过程</p><p>通过调用阻塞原语 block 将自己阻塞。</p></li><li><p>进程唤醒过程</p><p>调用 wakeup 原语唤醒：首先将被阻塞的进程从等待该事件的阻塞队列中移出，将其 PCB 中的现行状态由阻塞态改为就绪，然后再将 PCB 插入到就绪队列中。</p></li></ol><h4 id="进程的挂起与激活" tabindex="-1">进程的挂起与激活 <a class="header-anchor" href="#进程的挂起与激活" aria-label="Permalink to &quot;进程的挂起与激活&quot;">​</a></h4><ol><li><p>进程的挂起</p><p>使用 suspend 挂起原语将指定进程或处于阻塞状态的进程挂起。活动就绪 -&gt; 静止就绪 。</p><p>活动阻塞 -&gt; 静止阻塞</p></li><li><p>进程的激活过程</p><p>使用 active 原语激活进程。</p></li></ol><h3 id="进程通信" tabindex="-1">进程通信 <a class="header-anchor" href="#进程通信" aria-label="Permalink to &quot;进程通信&quot;">​</a></h3><br><h4 id="进程通信的类型" tabindex="-1">进程通信的类型 <a class="header-anchor" href="#进程通信的类型" aria-label="Permalink to &quot;进程通信的类型&quot;">​</a></h4><ol><li><p>共享存储器系统</p><p>（1）基于共享数据结构的通信方式</p><p>（2）基于共享存储区的通信方式</p></li><li><p>管道(pipe)通信系统</p><p>所谓”管道“，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又称为 <strong><em>pipe 文件</em></strong>。向管道(共享文件)提供输入的发送进程（即写进程）以字符流形式将大量的数据送入管道；而接受管道输出的接受进程（即读进程）则从管道中接受数据。由于发送进程和接受进程时利用管道进行通信的，故成为了管道通信。</p><p>为了协调双方的通信，管道机制必须提供以下三方面的协调功能：</p><p>（1）互斥</p><p>（2）同步</p><p>（3）确定对方是否存在，只有确定了对方已存在时才能进行通信。</p></li><li><p>消息传递系统</p><p>在该机制中，进程不必借助任何共享存储区或数据结构，而是以格式化的消息为单位，将通信的数据封装在消息中，并利用操作系统提供的一组通信命令（原语），在进程间进行消息传递，完成进程间的数据交换。</p><p>（1）直接通信方式：指发送进程利用 OS 所提供的发送原语，直接把消息发送给目标进程；</p><p>（2）间接通信方式：指发送和接受进程，都通过共享中间实体（邮箱）的方式进行消息的发送和接受，完成进程间的通信。</p></li><li><p>客户机-服务器系统</p></li></ol><p>1）套接字</p><p>2）远程过程调用和远程方法调用</p><h4 id="消息传递通信的实现方式" tabindex="-1">消息传递通信的实现方式 <a class="header-anchor" href="#消息传递通信的实现方式" aria-label="Permalink to &quot;消息传递通信的实现方式&quot;">​</a></h4><ol><li><p>直接消息传递系统</p><p>1）直接通信原语</p><p>（1）对称寻址方式</p><p>send（receiver，message） receive（sender，message）</p><p>（2）非对称寻址方式</p><p>send（P，message） seceive（id，message）</p><p>（2）消息的格式</p><p>（3）进程的同步方式</p><p>（4）通信链路</p></li><li><p>信箱通信</p><p>1）信箱的结构</p><p>（1）信箱头 （2）信箱体</p><p>2）信箱通信原语</p><p>（1）信箱的创建和撤销 （2）消息的发送和接受。</p><p>3）信箱的类型</p><p>（1）私用邮箱 （2）公用邮箱 （3）共享邮箱</p></li></ol><h4 id="直接消息传递系统实例" tabindex="-1">直接消息传递系统实例 <a class="header-anchor" href="#直接消息传递系统实例" aria-label="Permalink to &quot;直接消息传递系统实例&quot;">​</a></h4><ol><li><p>消息缓冲队列通信机制中的数据结构</p><p>（1）消息缓冲区 （2）PCB 中有关通信的数据项</p></li><li><p>发送原语</p></li><li><p>接受原语</p></li></ol><h3 id="线程的基本概念" tabindex="-1">线程的基本概念 <a class="header-anchor" href="#线程的基本概念" aria-label="Permalink to &quot;线程的基本概念&quot;">​</a></h3><br><h4 id="线程的引入" tabindex="-1">线程的引入 <a class="header-anchor" href="#线程的引入" aria-label="Permalink to &quot;线程的引入&quot;">​</a></h4><ol><li>进程的两个基本属性</li></ol><p>（1）进程是一个可拥有资源的独立单位。</p><p>（2）进程是一个可独立调度和分配的基本单位。</p><ol start="2"><li><p>程序并发执行所需付出的时空开销</p></li><li><p>线程--作为调度和分配的基本单位</p></li></ol><h4 id="线程与进程的比较" tabindex="-1">线程与进程的比较 <a class="header-anchor" href="#线程与进程的比较" aria-label="Permalink to &quot;线程与进程的比较&quot;">​</a></h4><ol><li><p>调度的基本单位</p><p>引入线程的 OS 中，线程作为调度和分配的基本单位，因而线程是能够独立运行的基本单位当线程切换时，仅需保存和设置少量寄存器内容，切换代价远低于进程。在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，必然就会引起进程的切换。</p></li><li><p>并发性</p><p>在引入线程的 OS 中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，甚至还允许在一个进程中的所有线程都能并发执行。同样，不同进程中的线程也能并发执行。</p></li><li><p>拥有资源</p><p>进程可以拥有资源，并作为你系统中拥有资源的一个基本单位。然后，线程本身并不拥有系统资源，而是仅有一点必不可少的、能够保证独立运行的资源。允许多个线程共享该进程所拥有的所有的资源：属于同一进程的所有线程都具有相同的地址空间，意味着，线程可以访问该地址空间中的每一个虚拟地址；还可以访问进程所拥有的资源。</p></li><li><p>独立性</p><p>同一进程的不同线程的之间的独立性要比不同进程之间的独立性低得多。因为线程会共享同一进程的资源，访问所属进程地址空间中的所有地址。</p></li><li><p>系统开销</p><p>OS 创建或撤销进程所付出的开销要比线程所付出的开销大的多</p></li><li><p>支持多处理机系统</p></li></ol><h4 id="线程的状态和线程控制块" tabindex="-1">线程的状态和线程控制块 <a class="header-anchor" href="#线程的状态和线程控制块" aria-label="Permalink to &quot;线程的状态和线程控制块&quot;">​</a></h4><ol><li><p>线程运行的三个状态</p><p>（1）执行状态 （2）就绪状态 （3）阻塞状态</p></li><li><p>线程控制块 TCB</p><p>（1）线程标识符</p><p>（2）一组寄存器，程序计数器 PC、状态寄存器和通用寄存器</p><p>（3）线程运行的状态</p><p>（4）优先级</p><p>（5）线程专有存储区</p><p>（6）信号屏蔽</p><p>（7）堆栈指针</p></li><li><p>多线程 OS 中的进程属性</p><p>（1）进程是一个可拥有资源的基本单位。</p><p>（2）多个线程可并发执行。</p><p>（3）进程已不是可执行的实体。在多线程中，把线程作为独立运行（或称为调度）的基本单位。</p></li></ol><h4 id="线程的实现方式" tabindex="-1">线程的实现方式 <a class="header-anchor" href="#线程的实现方式" aria-label="Permalink to &quot;线程的实现方式&quot;">​</a></h4><ol><li><p>内核支持线程</p><p>（1）在多处理器系统中，内核能够同时调度同一进程中的多个线程并执行；</p><p>（2）如果在进程中的一个线程被阻塞了，内核可以调度该进程中的其它线程占有处理器运行，也可以运行其它进程中的线程。</p><p>（3）内核支持线程具有很小的数据结构和堆栈，线程的切换比较快，切换开销小；</p><p>（4）内核本身可以采用多线程技术，可以提高系统的执行速度和效率。</p><p>缺点：同一进程中，从一个线程切换到另一个线程，需要从用户态转到核心态，这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的，系统开销较大。</p></li><li><p>用户级线程 ULT</p><p>用户级线程是在用户空间中实现的。对线程的创建、撤销、同步与通信等功能，都无需内核的支持，即用户及线程是与内核无关的。</p><p>（1）线程的切换不需要轮换到内核空间。</p><p>（2）调度算法可以是进程专用的。</p><p>（3）用户及线程的实现与 OS 平台无关，因为对于线程管理的代码属于用户程序的一部分，所有的应用程序都可以对之共享。</p><p>缺点：</p><p>（1）系统调用的阻塞问题。当一个线程执行系统调用，那么所属进程将被阻塞，该进程下的所有线程也会被阻塞。</p><p>（2）在单纯的用户及线程实现方式中，多线程应用不能利用多处理机进程多重处理的优点，内核每次分配给一个进程的仅有一个 CPU，因此，进程中仅有一个线程能执行，其它线程只能等待。</p></li><li><p>组合方式</p><p>将用户及线程和内核支持线程两种方式进行组合。</p><p>（1）多对一模型，即将用户及线程映射到一个内核控制线程。</p><p>多个线程同属于一个进程，运行在该进程的空间。仅当用户线程需要访问内核时，才将其映射到一个内核控制线程上，但每次只允许一个线程进程映射。</p><p>优点：线程管理的开销小，效率高。</p><p>缺点：如果一个线程阻塞，那么整个进程都会阻塞，任何时刻，只有线程能够访问内核。</p><p>（2）一对一模，即将每个用户及线程映射到一个内核支持线程。</p><p>优点：每个用户及线程都设置一个内核控制线程与之连接，当一个线程阻塞时，允许调度另一个线程运行，提供更好的并发功能</p><p>缺点：每创建一个用户及线程，响应地需要创建一个内核线程，开销较大，因此需要限制整个系统的线程数。</p><p>（3）多对多模型，即将许多用户线程映射到同样的数量或更少数量的内核线程上。结合了上述两个模型的优点。</p><p><img src="/Lyc-notes/assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.Dq1VcJt8.png" alt="22"></p></li></ol><h2 id="cpu-调度" tabindex="-1">CPU 调度 <a class="header-anchor" href="#cpu-调度" aria-label="Permalink to &quot;CPU 调度&quot;">​</a></h2><h3 id="调度的概念" tabindex="-1">调度的概念 <a class="header-anchor" href="#调度的概念" aria-label="Permalink to &quot;调度的概念&quot;">​</a></h3><br><h4 id="调度的基本概念" tabindex="-1">调度的基本概念 <a class="header-anchor" href="#调度的基本概念" aria-label="Permalink to &quot;调度的基本概念&quot;">​</a></h4><p>在多道程序系统中，进程的数量往往多于 CPU 的个数，因此进程争用 CPU 的情况在所难免。 CPU 调度是对 CPU 进行分配，即从就绪队列中按照 一定的算法 (公平、高效的原则)选择 一个 进程并将 CP U 分配给它运行，以实现进程并发地执行。</p><p>CPU 调度是多道程序操作系统的基础，是操作系统设计的核心问题。</p><h4 id="处理机调度的层次" tabindex="-1">处理机调度的层次 <a class="header-anchor" href="#处理机调度的层次" aria-label="Permalink to &quot;处理机调度的层次&quot;">​</a></h4><ol><li><p>高级调度(作业调度)</p><p>高级调度又称为长程调度或作业调度，其所调度的对象是作业。其重要功能是根据某种算法，决定将外存上的处于后备队列中的哪几个作业调入内存，为它们创建进程、分配必要的资源，并将它们放入就绪队列。</p><p>作业调度就是内存与辅存之间的调度。每个作业只调入一次、调出一次。</p></li><li><p>低级调度（进程调度）</p><p>又称为进程调度或短程调度，其调度的对象是进程（或内核级线程）。</p><p>功能：根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机分配给被酸中的进程</p></li><li><p>中级调度</p><p>又称为内存调度，为了提高内存利用率和系统吞吐量。把那些暂时不用运行的进程，调至外存等待，此时进程状态为挂起态。把具备运行条件且内存又稍有空闲时，由中级调度来决定，把外存上那些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪态。</p><p>中级调度实际上就是存储器管理中的对换功能</p></li></ol><h3 id="调度的实现" tabindex="-1">调度的实现 <a class="header-anchor" href="#调度的实现" aria-label="Permalink to &quot;调度的实现&quot;">​</a></h3><ol><li>调度程序</li></ol><p>1)排队器。将系统中的所有就绪进程按照一定的策略排成一个或多个队列，以便于调度程 序选择。每当有一个进程转变为就绪态时，排队器便将它插入相应的就绪队列。</p><p>2)分派器。依据调度程序所选的进程，将其从就绪队列中取出，将 CPU 分配给新进程。</p><p>3)上下文切换器。在对 CPU 进行切换时，会发生两对上下文的切换操作:第一对，将当前进程的上下文保存到其 PCB 中，再装入分派程序的上下文，以便分派程序运行;第二对，移出分派程序的上下文，将新选进程的 CPU 现场信息装入 CPU 的各个相应寄存器。</p><p>为了减少开销，上下文切换时，只需改变指针，让其指向当前寄存器组。</p><ol start="2"><li>调度的时机、切换与过程</li></ol><p>1)创建新进程后，由于父进程和子进程都处于就绪态，因此需要决定是运行父进程还是运行子进程，调度程序可以合法地决定其中一个进程先运行。</p><p>2)进程正常结束后或者异常终止后，必须从就绪队列中选择某个进程运行。若没有就绪进程，则通常运行一个系统提供的闲逛进程。</p><p>3)当进程因 1/O 请求、信号量操作或其他原因而被阻塞时，必须调度其他进程运行。</p><p>4)当 1/0 设备完成后，发出 1/0 中断，原先等待 1/O 的进程从阻塞态变为就绪态，此时需要决定是让新的就绪进程投入运行，还是让中断发生时运行的进程继续执行。</p><p>不能进行进程调度和切换的情况：</p><p>1)在处理中断的过程中。中断处理过程复杂，在实现上很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺 CPU 资源。</p><p>2)需要完全屏蔽中断的原子操作过程中。如加锁、解锁、中断现场保护、恢复等原子操作。在原子过程中，连中断都要屏蔽，更不应该进行进程调度与切换。</p><ol start="3"><li>进程调度的方式</li></ol><p>1)非抢占调度方式，又称非剥夺方式。</p><p>2)抢占调度方式，又称剥夺方式</p><ol start="4"><li>闲逛进程</li></ol><p>在进程切换时，如果系统中没有就绪进程，就会调度闲逛进程(IdleProcess)运行，它的 PID 为 0。如果没有其他进程就绪，该进程就一直运行，并在指令周期后测试中断。闲逛进程的优先级最低，没有就绪进程时才会运行闲逛进程，只要有进程就绪，就会立即让出 CPU。</p><ol start="5"><li>两种线程的调度</li></ol><p>1)用户级线程调度。由于内核并不知道线程的存在，所以内核还是和以前一样，选择一个进程，并给予时间控制。由进程中的调度程序决定哪个线程运行。</p><p>2)内核级线程调度。内核选择一个特定线程运行，通常不用考虑该线程属于哪个进程。对被选择的线程赋予一个时间片，如果超过了时间片，就会强制挂起该线程。</p><h3 id="处理机调度算法的目标" tabindex="-1">处理机调度算法的目标 <a class="header-anchor" href="#处理机调度算法的目标" aria-label="Permalink to &quot;处理机调度算法的目标&quot;">​</a></h3><ol><li><p>处理机调度算法的共同目标</p><p>（1）资源利用率</p><p>CPU 利用率 = CPU 有效工作时间 / CPU 有效工作时间 + CPU 空闲等待时间</p><p>（2）公平性</p><p>应使所有进程都获得合理的 CPU 时间，不会发生进程饥饿现象。</p><p>（3）平衡性</p><p>保持系统资源使用的平衡性</p><p>（4）策略强制执行。</p></li><li><p>批处理系统的目标</p><p>（1）平均周转时间短</p><p>周转时间：指从作业被提交给系统开始，到作业完成为之的这段时间间隔称为作业周转时间。</p><p>包括四个时间：作业在外存后备队列上等待调度的时间，进程在就绪队列上等待进程调度的时间，进程在 CPU 上执行的时间，以及进程等待 I/O 操作完成的时间。</p><p>带权周转时间：作业的周转时间 T 与系统为它提供服务的时间 Ts 之比。</p><p>（2）系统吞吐量高。</p><p>吞吐量：指单位时间内系统所完成的作业数</p><p>（3）处理机利用率高</p></li><li><p>分时系统的目标</p><p>（1）响应时间快</p><p>响应时间：从用户通过键盘提交一个请求开始，知道屏幕上显示处理结果为之的一段时间间隔。分为三部分时间：一是请求信息从键盘输入开始，直至将其传送到处理机的时间；二是处理机对请求信息进行处理的时间；三是将所形成的响应信息回送到终端显示器的时间。</p><p>（2）均衡性</p><p>指系统响应时间的快慢应与用户所请求服务的复杂性相适应。</p></li><li><p>实时系统的目标</p><p>（1）截止时间的保证</p><p>截止时间：指某任务必须开始执行的最迟时间，或必须完成的最迟时间</p><p>（2）可预测性</p></li></ol><h3 id="作业与作业调度" tabindex="-1">作业与作业调度 <a class="header-anchor" href="#作业与作业调度" aria-label="Permalink to &quot;作业与作业调度&quot;">​</a></h3><br><h4 id="批处理系统中的作业" tabindex="-1">批处理系统中的作业 <a class="header-anchor" href="#批处理系统中的作业" aria-label="Permalink to &quot;批处理系统中的作业&quot;">​</a></h4><ol><li><p>作业与作业步</p><p>（1）作业：在批处理系统中，以作业为基本单位从外存调入内存的</p><p>（2）作业步：</p></li><li><p>作业控制块（JCB）</p><p>它是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。</p></li><li><p>作业运行的三个阶段和三种状态</p><p>（1）收容阶段</p><p>操作人员把用户提交的作业通过某种输入方式或 SPOOling 系统输入到硬盘上，再为该作业建立 JCB 并把它放入作业后备队列中。</p><p>（2）运行阶段</p><p>为它分配必要的资源和建立进程，并将它放入就绪队列。</p><p>（3）完成阶段</p></li></ol><h4 id="作业调度的主要任务" tabindex="-1">作业调度的主要任务 <a class="header-anchor" href="#作业调度的主要任务" aria-label="Permalink to &quot;作业调度的主要任务&quot;">​</a></h4><ol><li><p>接纳多少个作业</p></li><li><p>接纳哪些作业</p></li></ol><h4 id="先来先服务-fcfs-和短作业优先-sjf-调度算法" tabindex="-1">先来先服务（FCFS）和短作业优先（SJF）调度算法 <a class="header-anchor" href="#先来先服务-fcfs-和短作业优先-sjf-调度算法" aria-label="Permalink to &quot;先来先服务（FCFS）和短作业优先（SJF）调度算法&quot;">​</a></h4><ol><li><p>先来先服务调度算法（FCFS）</p><p>每次调度就是从就绪的进程队列中选择一个最先进入该队列的作业，将它们调入内存，为它们分配资源和创建进程。然后把它放入就绪队列</p></li><li><p>短作业优先的调度算法（SJF）</p><p>以作业的长短（以所要求运行时间来衡量）来计算优先级，作业越短，优先级越高，</p><p>缺点： （1）必须预知作业的运行时间。很难估计 （2）对长作业非常不利。会出现饥饿现象 （3）无法实现人机交互 （4）不能保证紧迫作业的得到及时处理</p></li></ol><h4 id="优先级调度算法和高响应比优先调度算法" tabindex="-1">优先级调度算法和高响应比优先调度算法 <a class="header-anchor" href="#优先级调度算法和高响应比优先调度算法" aria-label="Permalink to &quot;优先级调度算法和高响应比优先调度算法&quot;">​</a></h4><ol><li><p>优先级调度算法（PSA）</p><p>对于先来先服务算法，作业的等待时间就是作业的优先级，等待时间越长，其优先级越高</p><p>对于短作业优先调度算法，作业的长短就是作业的优先级，所需运行时间越短，优先级越高。</p><p>优先级调度算法中，基于作业的<strong>紧迫程度</strong>，由外部赋予作业相应的优先级</p></li><li><p>高响应比优先调度算法</p><p>既考虑作业的等待时间，又考虑作业的运行时间</p><p>优先权 = （等待时间 + 要求服务时间） / 要求服务时间</p><p>Rp = 响应时间 / 要求服务时间</p></li></ol><p>如果作业的等待时间相同，则要求服务的时间越短，其优先权越高，类似于短作业优先，有利于短作业。要求服务时间相等，等待时间越长，优先级越高-&gt; 先来先服务 。对于长作业的优先级，等待时间越长，即可获得处理机。</p><h4 id="时间片轮转调度算法" tabindex="-1">时间片轮转调度算法 <a class="header-anchor" href="#时间片轮转调度算法" aria-label="Permalink to &quot;时间片轮转调度算法&quot;">​</a></h4><p>分时操作系统</p><h4 id="多级队列调度算法" tabindex="-1">多级队列调度算法 <a class="header-anchor" href="#多级队列调度算法" aria-label="Permalink to &quot;多级队列调度算法&quot;">​</a></h4><p>根据进程的性质分成不同的队列 各个队列采用不同的调度算法</p><h4 id="多级反馈队列调度算法" tabindex="-1">多级反馈队列调度算法 <a class="header-anchor" href="#多级反馈队列调度算法" aria-label="Permalink to &quot;多级反馈队列调度算法&quot;">​</a></h4><h3 id="进程调度" tabindex="-1">进程调度 <a class="header-anchor" href="#进程调度" aria-label="Permalink to &quot;进程调度&quot;">​</a></h3><br><h4 id="进程调度的任务、机制和方式" tabindex="-1">进程调度的任务、机制和方式 <a class="header-anchor" href="#进程调度的任务、机制和方式" aria-label="Permalink to &quot;进程调度的任务、机制和方式&quot;">​</a></h4><ol><li><p>进程调度的任务</p><p>（1）保存处理机的现场信息</p><p>（2）按某种算法选取进程。</p><p>（3）把处理机分配给进程</p></li><li><p>进程调度机制</p><p>（1）排队器。</p><p>将系统中的所有就绪进程按一定的策略排成一个或多个队列。</p><p>（2）分派器</p><p>分派器依据调度程序所选定的进程，将其从就绪队列中取出，然后进行从分派器到新选出进程间的上下文切换，将处理机分配给新选的进程。</p><p>（3）上下文切换器</p><p>第一对上下文切换时，OS 将保存当前进程的上下文，把处理机寄存器内容保存到该进程的进程控制块内的相应单元再转入分派程序的上下文，以便分派程序运行。</p><p>第二对上下文切换是移出分派程序的上下文，而是把新选进程的 CPU 现场信息装入到处理机的各个相应寄存器中，以便新选取进程运行。</p><p>需要执行大量的 load 和 store 等操作指令，以保存寄存器的内容 <img src="/Lyc-notes/assets/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6.CAYnQ8eW.png" alt="23"></p></li><li><p>进程调度方式</p><p>（1）非抢占方式</p><p>一旦把处理机分配给某进程后，就一直让它运行下去，绝不会因为时钟中断或任何其它原因去抢占当前正在运行进程的处理机，直至该进程完成，或发生某事件而被阻塞时，才把处理机分配给其它进程。</p><p>（2）抢占式</p><p>允许调度程序根据某种原则，去暂停某个正在运行的进程，将已分配给该进程的处理机重新分配给另一个进程。 “抢占”不是一种任意性行为，必须遵循一定的原则，主要原则有： 优先权原则 短进程优先原则 时间片原则</p></li></ol><h4 id="轮转调度算法" tabindex="-1">轮转调度算法 <a class="header-anchor" href="#轮转调度算法" aria-label="Permalink to &quot;轮转调度算法&quot;">​</a></h4><ol><li><p>轮转法的基本原理</p><p>所有就绪进程按 FCFS 策略排成一个就绪队列。</p></li><li><p>进程切换时机</p><p>一个时间片尚未用完，正在运行的进程便已经完成，就立即激活调度程序，将它从就绪队列中删除，再调度就绪队列中队首的进程运行，并启动一个新的时间片。</p><p>一个时间片用完时，计时器中断处理程序被激活，如果进程尚未运行完毕，调度程序将它送往就绪队列的末尾。</p></li><li><p>时间片大小的确定</p><p>时间片很小，有利于短作业，进行进程调度和上下文切换增加系统的开销。</p><p>时间片太长，且每个进程能在一个时间片内完成，RR 算法便退化 FCFS。</p><p><img src="/Lyc-notes/assets/%E6%97%B6%E9%97%B4%E7%89%87%E5%A4%A7%E5%B0%8F.OiI_5rVf.png" alt="24"></p></li></ol><h4 id="优先级调度算法" tabindex="-1">优先级调度算法 <a class="header-anchor" href="#优先级调度算法" aria-label="Permalink to &quot;优先级调度算法&quot;">​</a></h4><ol><li><p>优先级调度算法的类型</p><p>（1）非抢占式优先级调度算法</p><p>（2）抢占式优先级调度算法</p></li><li><p>优先级的类型</p><p>1）静态优先级</p><p>再创建进程时确定的，在进程的整个运行期间保持不变 （1）进程类型。 （2）进程对资源的需求。 （3）用户要求</p><p>2）动态优先级</p><p>创建进程之初，先赋予其一个优先级，然后其值进程的推进或等待时间的增长，使其优先级相应提高。</p></li></ol><h4 id="多队列调度算法" tabindex="-1">多队列调度算法 <a class="header-anchor" href="#多队列调度算法" aria-label="Permalink to &quot;多队列调度算法&quot;">​</a></h4><p>将系统中的进程就绪队列从一个拆分为若干个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法。</p><h4 id="多级反馈队列调度算法-1" tabindex="-1">多级反馈队列调度算法 <a class="header-anchor" href="#多级反馈队列调度算法-1" aria-label="Permalink to &quot;多级反馈队列调度算法&quot;">​</a></h4><ol><li><p>调度机制</p><p>（1）设置多个就绪队列 。</p><p>第一队列优先级最高，其余依次降低 （2）每个队列都采用 FCFS 算法</p><p>（3）按队列优先级调度</p><p>仅当第一队列空闲时才调度第二队列中的进程运行</p><p><img src="/Lyc-notes/assets/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.DPu9aOXH.png" alt="25"></p></li><li><p>调度算法的性能</p></li></ol><h4 id="基于公平原则的调度算法" tabindex="-1">基于公平原则的调度算法 <a class="header-anchor" href="#基于公平原则的调度算法" aria-label="Permalink to &quot;基于公平原则的调度算法&quot;">​</a></h4><ol><li><p>保证调度算法</p></li><li><p>公平分享调度算法</p></li></ol><h3 id="实时调度" tabindex="-1">实时调度 <a class="header-anchor" href="#实时调度" aria-label="Permalink to &quot;实时调度&quot;">​</a></h3><br><h4 id="实现实时调度的基本条件" tabindex="-1">实现实时调度的基本条件 <a class="header-anchor" href="#实现实时调度的基本条件" aria-label="Permalink to &quot;实现实时调度的基本条件&quot;">​</a></h4><ol><li><p>提供必要的信息</p><p>（1）就绪时间 （2）开始截止时间和完成截止时间 （3）处理时间 （4）资源要求 （5）优先级</p></li><li><p>系统处理能力强</p><p>（处理时间 / 周期时间 ）&lt;= 1</p><p>进程处理时间 要小于或等于 周时期时间</p></li><li><p>采用抢占式调度机制</p></li><li><p>具有快速切换机制</p><p>（1）对中断的快速响应能力 （2）快速的任务分派能力</p></li></ol><h4 id="实时调度算法的分类" tabindex="-1">实时调度算法的分类 <a class="header-anchor" href="#实时调度算法的分类" aria-label="Permalink to &quot;实时调度算法的分类&quot;">​</a></h4><br><h4 id="资源问题" tabindex="-1">资源问题 <a class="header-anchor" href="#资源问题" aria-label="Permalink to &quot;资源问题&quot;">​</a></h4><p>根据实时任务性质分类，硬实时调度算法和软实时调度算法 按调度方式分类：非抢占式调度算法和抢占式调度算法</p><ol><li><p>非抢占式调度算法</p><p>（1）非抢占式<strong>轮转</strong>调度算法。轮转队列（循环队列） （2）非抢占式<strong>优先</strong>调度算法。将优先级高的任务放在队首。</p></li><li><p>抢占式调度算法</p><p>（1）基于时钟中断的抢占式优先级调度算法。</p><p>如果它的优先级高于当前任务的优先级，这时并不立即抢占当前任务的处理机，而是等到<strong>时钟中断</strong>发生时，调度程序才剥夺当前任务的执行，将处理机分配给新的高优先级任务。</p><p>（2）立即抢占的优先级调度算法</p><p>一旦出现外部中断，只要当前任务未处于临界区，便能立即剥夺的当前任务的执行，把处理机分配给请求中断的紧迫任务。 <img src="/Lyc-notes/assets/%E5%AE%9E%E6%97%B6%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6.CrkkJ82r.png" alt="26"></p></li></ol><h4 id="最早截止时间优先-edf-算法" tabindex="-1">最早截止时间优先 EDF 算法 <a class="header-anchor" href="#最早截止时间优先-edf-算法" aria-label="Permalink to &quot;最早截止时间优先 EDF 算法&quot;">​</a></h4><p>根据任务的截止时间确定任务的优先级，任务的截止时间越早，其优先级越高，</p><ol><li><p>非抢占式调度方式用于非周期实时任务</p><p><img src="/Lyc-notes/assets/EDF%E7%AE%97%E6%B3%95%E7%94%A8%E4%BA%8E%E9%9D%9E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F.Cn9aFvRH.png" alt="27"></p></li><li><p>抢占式调度方式用于周期实时任务</p></li></ol><h4 id="最低松弛度-紧急-有限-llf-算法" tabindex="-1">最低松弛度（紧急）有限 LLF 算法 <a class="header-anchor" href="#最低松弛度-紧急-有限-llf-算法" aria-label="Permalink to &quot;最低松弛度（紧急）有限 LLF 算法&quot;">​</a></h4><p>根据任务的紧急（松弛）程度。任务紧急度越高，优先级就越高。</p><h4 id="优先级倒置" tabindex="-1">优先级倒置 <a class="header-anchor" href="#优先级倒置" aria-label="Permalink to &quot;优先级倒置&quot;">​</a></h4><ol><li><p>优先级倒置的形成</p><p>存在是三个进程 P1、P2、P3,优先级依次升高，P1 和 P3 共享临界区</p><p><img src="/Lyc-notes/assets/%E4%BC%98%E5%85%88%E7%BA%A7%E5%80%92%E7%BD%AE.CqOzzwu2.png" alt="28"></p></li><li><p>优先级倒置的解决方法</p><p><img src="/Lyc-notes/assets/%E5%8A%A8%E6%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E7%BB%A7%E6%89%BF.CueBJJOC.png" alt="29"></p></li></ol><h2 id="进程同步与互斥" tabindex="-1">进程同步与互斥 <a class="header-anchor" href="#进程同步与互斥" aria-label="Permalink to &quot;进程同步与互斥&quot;">​</a></h2><h3 id="同步与互斥的基本概念" tabindex="-1">同步与互斥的基本概念 <a class="header-anchor" href="#同步与互斥的基本概念" aria-label="Permalink to &quot;同步与互斥的基本概念&quot;">​</a></h3><p>同步机制的主要任务：对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能按照一定的规则（或时序）共享系统资源</p><ol><li><p>两种形式的制约关系</p><p>1）间接相互制约关系(互斥)</p><p>访问共享系统资源（同一时间只允许一个进程访问），所以形成了间接相互制约关系。</p><p>2）直接相互制约关系（同步）</p><p>完成同一项任务的两个进程而相互合作。例如 A 输入进程，B 计算进程，共享一个缓冲区，进程 A 向 B 提供数据，B 从缓冲区中取出数据。</p></li><li><p>临界资源</p><p>对临界资源（打印机、磁带机）的访问，诸进程之间应采用互斥方式。</p><p>生产者-消费者</p></li><li><p>临界区</p><p>临界区：把每个进程中访问临界资源的那段代码称为临界区。</p></li><li><p>同步机制应遵循的规则</p><p>（1）空闲让进：当无进程进入自己的临界区，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。</p><p>（2）忙则等待：当已有进程进入临界区时，表明临界资源正在被访问，因而其它试图进入临界区的进程必须等待，以保证对临界资源的护持访问。</p><p>（3）有限等待：对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态。</p><p>（4）让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态</p><p><img src="/Lyc-notes/assets/%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E5%BE%AA%E7%8E%AF%E8%BF%9B%E7%A8%8B.Bt_v9vu3.png" alt="10"></p></li></ol><h3 id="实现临界区互斥的基本方法" tabindex="-1">实现临界区互斥的基本方法 <a class="header-anchor" href="#实现临界区互斥的基本方法" aria-label="Permalink to &quot;实现临界区互斥的基本方法&quot;">​</a></h3><br><h4 id="软件实现方法" tabindex="-1">软件实现方法 <a class="header-anchor" href="#软件实现方法" aria-label="Permalink to &quot;软件实现方法&quot;">​</a></h4><ol><li><strong>单标志法</strong></li></ol><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 进程P0:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                   // 进程P1:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(turn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);           </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(turn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 进入区</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">critical section;           critical section ;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 临界区</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">turn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;                   turn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">              // 退出区</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">remainder section ;         remainder section ;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 剩余区</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>该算法设置 一个公用整型变量 turn，指示允许进入临界区的进程编号，当 turn = 0 时，表示 允许 P0 进入临界区;当 turn = 1 时，表示允许 P1，进入临界区。</p><p>缺点：违反<strong>空闲让进</strong>（若某个进程不再进入临界区，则另一个进程也无法进入临界区）</p><ol start="2"><li><strong>双标志先检查法</strong></li></ol><p>该算法设置 一个布尔型数组 flag[2]，用来标记各个进程想进入临界区的意愿，<code>flag[i] =true</code>表示 Pi，想要进入临界区(i=0 或 1)。P0 进入临界区前，先检查对方是否想进入临界区，若想，则等待;否则，将 flag 回置为 true 后，再进入临界区;当 Pi 退出临界区时，将 flagli 置为 false</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 进程P0:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                   // 进程P1:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">flag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);          </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">flag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           // 进入区</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">flag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;          </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">flag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           // 进入区</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">critical section;        critical section;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 临界区</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">flag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;         </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">flag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 退出区</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">remainder section ;      remainder section ;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 剩余区</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>优点：不用交替进入，可连续使用</p><p>缺点：P0 和 P1 可能同时进入临界区，违反<strong>忙则等待</strong></p><ol start="3"><li><strong>双标志后检查</strong></li></ol><p>先设置自己的标志，再检查对方的标志，若对方的标志为 true，则等待;否则，进入临界区</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 进程P0:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // 进程P1:</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">flag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;          </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">flag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 进入区</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">flag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);          </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">flag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 进入区</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">critical section;        critical section;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 临界区</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">flag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;         </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">flag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 退出区</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">remainder section ;      remainder section ;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 剩余区</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>缺点：违背<strong>空闲让进</strong>，存在饥饿现象，违背有限等待</p><ol start="4"><li><strong>Peterson</strong></li></ol><p>Peterson 算法结合了算法一和算法三的思想，利用 flag 解决互斥访问问题，而利用 turn 解决“饥饿”问题。</p><p>若双方试图同时进入，则 turn 几乎同时被置为 i 和 j，但只有一个赋值语句的结果会保持，另一个也会执行，但会被立即重写。变量 turn 的最终值决定了哪个进程被允许先进入临界区</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 进程P0:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // 进程P1:</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">flag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;          </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">flag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 进入区</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">turn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;                turn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">               // 进入区</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">flag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">turn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">flag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">turn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 进入区</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">critical section;        critical section;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 临界区</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">flag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;         </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">flag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 退出区</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">remainder section ;      remainder section ;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 剩余区</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>优点：遵循“空闲让进”“忙则等待”“有限等待”三个准则 缺点：未遵循<strong>让权等待</strong></p><h4 id="硬件同步机制" tabindex="-1">硬件同步机制 <a class="header-anchor" href="#硬件同步机制" aria-label="Permalink to &quot;硬件同步机制&quot;">​</a></h4><ol><li><strong>中断屏蔽方法</strong></li></ol><p>当一个进程正在执行它的临界区代码时，防止其他进程进入其临界区的最简单方法是关中断。因为 CPU 只在发生中断时引起进程切换，因此屏蔽中断能够保证当前运行的进程让临界区代码顺利地执行完，进而保证互斥的正确实现，然后执行开中断。</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>   .</span></span>
<span class="line"><span>   .</span></span>
<span class="line"><span>   .</span></span>
<span class="line"><span>   关中断</span></span>
<span class="line"><span>   临界区</span></span>
<span class="line"><span>   开中断</span></span>
<span class="line"><span>   .</span></span>
<span class="line"><span>   .</span></span>
<span class="line"><span>   .</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>缺点：</p><p>1️⃣ 限制了 CPU 交替执行程序的能力，因此系统效率会明显降低（关中断后 CPU 不能响应其他请求） 。</p><p>2️⃣ 对内核来说，在它执行更新变量的几条指令期间，关中断是很方便的，但将关中断的权限交给用户则很不明智，若一个进程关中断后不再开中断，则系统可能会因此终止。</p><p>3️⃣ 不适用于多处理器系统，因为在一个 CPU 上关中断并不能防止进程在其他 CPU 上执行相同的临界区代码。</p><ol start="2"><li><strong>利用 Test-and-Set 指令实现互斥</strong></li></ol><p>借助一条硬件指令 -TestAndSet 指令(简称 TS 指令)实现互斥，这条指令是<strong>原子操作</strong>。 其功能是读出指定标志后将该标志设置为真。</p><p>当用 TS 指令管理临界区时，为每个临界资源设置一个共享布尔变量 lock，表示该资源的两种状态:true 表示正被占用(已加锁);false 表示空闲(未加锁)，初值为 false，所以可将 lock 视为一把锁。</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">boolean </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TestAndSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(boolean </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   boolean old;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   old </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lock;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // old用来存放lock的旧值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lock </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 无论之前是否已加锁，都将lock置为true</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> old;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 返回lock的旧值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TestAndSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 加锁并检查</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">进程临界区代码段;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lock </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">              // 解锁</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>相比于软件实现方法，TS 指令将“ 加锁” 和“ 检查” 操作用硬件的方式变成了一气呵成的原子操作。相比于关中断方法，由于“锁” 是共享的，这种方法适用于多处理器系统。</p><p>缺点：暂时无法进入临界区的进程会占用 CPU 循环执行 TS 指令，因此不能实现 “让权等待”。</p><ol start="3"><li><strong>利用 Swap 指令实现进程互斥</strong></li></ol><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Swap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(boolean </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, boolean </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   boolean temp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> temp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">boolean key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   Swap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">进程临界区代码段</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lock</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">进程其他代码</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>优点：</p><p>1️⃣ 简单、容易验证其正确性:</p><p>2️⃣ 适用于任意数目的进程，支持多处理器系统:</p><p>3️⃣ 支持系统中有多个临界区，只需为每个临界区设立一个布尔变量。</p><p>缺点:</p><p>1️⃣ 等待进入临界区的进程会占用 CPU 执行 while 循环，不能实现“让权等待”;</p><p>2️⃣ 从等待进程中随机选择一个进程进入临界区，有的进程可能一直选不上，从而导致“饥饿”现象</p><h4 id="互斥锁" tabindex="-1">互斥锁 <a class="header-anchor" href="#互斥锁" aria-label="Permalink to &quot;互斥锁&quot;">​</a></h4><p>解决临界区最简单的工具就是互斥锁(mutex lock)。一个进程在进入临界区时调用<code>acquire()</code>函数，以获得锁;在退出临界区时调用<code>release()</code>函数，以释放锁。每个互斥锁有一个布尔变量 available，表示锁是否可用。</p><p><code>acquire()</code>或<code>release()</code>的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  acquire</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">available);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 忙等待</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   available </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 获得锁</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  release</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   available </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 释放锁</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="信号量机制" tabindex="-1">信号量机制 <a class="header-anchor" href="#信号量机制" aria-label="Permalink to &quot;信号量机制&quot;">​</a></h4><p>信号量机制是一种功能较强的机制，可用来解决互斥与同步问题，它只能被两个标准的原语 <code>wait()</code>和<code>signal()</code>访问，也可简写为 P()和 V()，或者简称 P 操作和 V 操作。</p><ol><li><p><strong>整型信号量</strong></p><p>S：表示资源数目的整型量 S</p><p>wait（S）和 signal（S） -&gt; P、V 操作</p><p><img src="/Lyc-notes/assets/PV.CQpK-kb9.png" alt="10"> 缺点：未遵循让权等待</p></li><li><p><strong>记录型信号量</strong></p></li></ol><p>记录型信号量机制是一种不存在“忙等”现象的进程同步机制。除了需要一个用于代表资源数目的整型变量 value 外，再增加一个进程链表 L，用于链接所有等待该资源的进程。</p><p><img src="/Lyc-notes/assets/%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F.DmkhllZN.png" alt="11"></p><p><strong>该机制遵循了“让权等待” 准则</strong></p><ol start="3"><li><p><strong>AND 型信号量</strong></p><p>基本思想：将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放。只要尚有一个资源分配给进程，其它所有可能其它所有可能为之分配的资源也不分配给它。要么把它所请求的资源全部分配到进程，要么一个也不分配 <img src="/Lyc-notes/assets/AND%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F.B8k18j0q.png" alt="12"></p></li><li><p><strong>信号量集</strong></p></li></ol><h4 id="信号量的应用" tabindex="-1">信号量的应用 <a class="header-anchor" href="#信号量的应用" aria-label="Permalink to &quot;信号量的应用&quot;">​</a></h4><ol><li><p><strong>利用信号量实现进程互斥</strong></p><p>设置 mutex 为互斥信号量，初始值为 1，取值范围为（-1，0，1）。当 mutex=1 时，表示两个进程皆未进入需要互斥的临界区；当 mutex=0 时，表示有一个进程进入临界区运行，另一个必须等待，挂入阻塞队列；当 mutex = -1 时，表示有一个进程正在临界区运行，另一个进程因等待而阻塞在信号量队列中，需要被当前已在临界区运行的进程退出时唤醒。</p><p><img src="/Lyc-notes/assets/%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BA%92%E6%96%A5.DYCp_M34.png" alt="12"></p><p>PV 必须成对的出现。缺失 P 将会导致系统混乱，不能保证对临界区资源的互斥访问；缺少 V 操作将会使临界资源永远不被释放，从而使等待该资源而阻塞的进程不能被唤醒。</p></li><li><p><strong>利用信号量实现前趋关系(同步)</strong></p><p>设置信号量 S，初始值为 0，欲使 P1 进程的 S1 语句要在 P2 进程中的 S2 语句之前执行。</p><p>在进程 P1 中，执行 S1；signal(s)；</p><p>在进程 P2 中，wait(s);执行 S2； <img src="/Lyc-notes/assets/%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%89%8D%E9%A9%B1.aBg2ku2w.png" alt="13"></p></li></ol><h4 id="管程机制" tabindex="-1">管程机制 <a class="header-anchor" href="#管程机制" aria-label="Permalink to &quot;管程机制&quot;">​</a></h4><ol><li><p>管程的定义</p><p>代表共享资源的数据结构以及由对该共享数据实施操作的一组过程所组成的资源管理程共同构成了一个操作系统的资源管理模块，称为管程 组成：</p><p>（1）管程的名称</p><p>（2）局部于管程的共享数据结构说明</p><p>（3）对该数据结构进行操作的一组过程</p><p>（4）对局部于管程的共享数据设置初始值</p><p>管程包含了面向对象的思想，它将表征共享资源的数据结构及其数据结构操作的一组过程，包括同步机制，都集中并封装在一个对象内部，隐藏了实现细节 <img src="/Lyc-notes/assets/%E7%AE%A1%E7%A8%8B.BKhWfdQn.png" alt="14"></p></li><li><p>条件变量</p><p>conditionx,y</p><p>(1)x.wait:正在调用管程的进程因 x 条件被阻塞或挂起，则调用 x.wait 将自己插入到 x 条件的等待队列上，并释放管程，直到 x 条件变化。</p><p>（2）x.signal:正在调用管程的进程发现 x 条件发生了变化，则调用 x.signal，重新启动一个因 x 条件而阻塞或挂起的进程，如果存在多个这样的进程，则选择其中的一个，如果没有，则继续执行原进程</p></li></ol><p>条件变量和信号量的比较:</p><p>相似点:条件变量的 wait signal 操作类似于信号量的 P/V 操作，可以实现进程的阻塞/唤醒。</p><p>不同点:条件变量是“没有值” 的，仅实现了“排队等待” 功能:而信号量是“ 有值” 的， 信号量的值反映 了剩余资源数，而在管程中，剩余资源数用共享数据结构记录</p><h3 id="经典进程的同步问题" tabindex="-1">经典进程的同步问题 <a class="header-anchor" href="#经典进程的同步问题" aria-label="Permalink to &quot;经典进程的同步问题&quot;">​</a></h3><br><h4 id="生产者-消费者" tabindex="-1">生产者-消费者 <a class="header-anchor" href="#生产者-消费者" aria-label="Permalink to &quot;生产者-消费者&quot;">​</a></h4><ol><li><strong>利用记录型信号量解决生产者-消费者问题</strong></li></ol><p>假定在生产者和消费者之间的公用缓冲池中具有 n 个缓冲区，这时可利用 mutex 互斥信号量实现进程对缓冲池的互斥使用。利用信号量 empty 和 full 分别表示缓冲池中空缓冲区和满缓冲区的数量。只要缓冲池未满，生产者便可将消息送入缓冲池；只要缓冲池未空，消费者便可从缓冲池中取走一个消息。</p><p><strong>注意：</strong> 每个程序用于实现互斥的 wait 和 signal 必须成对地出现；其次，对资源信号量 empty 和 full 的 PV 操作，同样也需要成对出现，但它们分别处于不同的程序中。</p><p><img src="/Lyc-notes/assets/%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98.TEetLZtt.png" alt="15"></p><ol start="2"><li><p><strong>利用 AND 信号量解决生产者-消费者问题</strong></p><p>用 Swati(empty,mutex)来代替 wait(empty)和 wait(mutex)</p></li></ol><p><img src="/Lyc-notes/assets/%E5%88%A9%E7%94%A8AND%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98.BKAnsoxH.png" alt="16"></p><ol start="3"><li><p><strong>利用管程解决生产者-消费者问题</strong></p><p>PC 管程描述：</p><p><img src="/Lyc-notes/assets/PC%E7%AE%A1%E7%A8%8B.C1bzd2Wg.png" alt="17"></p><p>管程解决描述：</p><p><img src="/Lyc-notes/assets/PC%E7%AE%A1%E7%A8%8B%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98.D9nVYgXt.png" alt="18"></p></li></ol><h4 id="哲学家进餐问题" tabindex="-1">哲学家进餐问题 <a class="header-anchor" href="#哲学家进餐问题" aria-label="Permalink to &quot;哲学家进餐问题&quot;">​</a></h4><p>一个圆桌，五把椅子，五个碗，五只筷子。只有拿到两只筷子才能进餐。</p><ol><li><p><strong>利用记录型信号量解决哲学家进餐问题</strong></p><p>筷子是临界资源，在一段时间内只允许一位哲学家使用。 <img src="/Lyc-notes/assets/%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98.DbXYYzq2.png" alt="19"></p></li></ol><p>当哲学家饥饿时，总是先去拿他左边的筷子，再去拿他右边的筷子。</p><p>问题：可能发生死锁，如果五位哲学家同时拿起左边的筷子，再去拿右边的筷子时，都会因为无筷子可拿而导致无限期等待。</p><p>解决办法：</p><p>（1）至多只允许有四位哲学家同时取拿左边的筷子，最终能保证至少有一位哲学家能够进餐，并在用完时，能释放出他用过的两只筷子，从而使更多的哲学家能够进餐。</p><p>（2）仅当哲学家的左右两只筷子均可用时，才允许他拿起筷子进餐（推荐）。</p><p>（3）规定奇数号哲学家先拿他左边的筷子，然后再去拿右边的筷子；而偶数号哲学家则相反。那么，1，2 号哲学家竞争 1 号筷子；3，4 号哲学家竞争 3 号筷子。即五位哲学家都先去竞争奇数筷子，获得后再去竞争偶数号筷子，最后总会有一位哲学家能获得两只筷子而进餐。</p><ol start="2"><li><p><strong>利用 AND 信号量机制解决哲学家进餐问题</strong></p><p><img src="/Lyc-notes/assets/%E5%88%A9%E7%94%A8AND%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E8%A7%A3%E5%86%B3%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98%20.Btbz3EU5.png" alt="20"></p></li></ol><h4 id="读者-写者问题" tabindex="-1">读者-写者问题 <a class="header-anchor" href="#读者-写者问题" aria-label="Permalink to &quot;读者-写者问题&quot;">​</a></h4><p>一个数据文件可被多个进程共享，读该文件的进程称为“Reader 进程”，其它进程称为“Writer 进程”。允许多个进程同时读一个共享对象，因为读操作不会使数据文件混乱。但不允许一个 Writer 进程和其它 Reader 进程或 Writer 进程同时访问共享对象。-&gt; Writer 进程必须和其它进程互斥的访问共享对象。</p><ol><li><p><strong>利用记录型信号量解决读者-写者问题</strong></p><p>Wmutex：Reader 进程与 Writer 进程的互斥信号量</p><p>Readcount：正在读的进程数</p><p>Rmutex：Readcount：正在读的进程数是一个可被多个 Reader 进程访问的临界资源，所以为它设置一个互斥信号量 rmutex。</p><p><img src="/Lyc-notes/assets/%E5%88%A9%E7%94%A8%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98.BSp5Bk1z.png" alt="21"></p></li></ol><p>读者-写者问题有一个关键的特征，即有<strong>一个互斥访问的计数器 count</strong>，因此遇到一个不太好 解决的同步互斥问题时，要想一想用互斥访问的计数器 count 能否解决问题。</p><ol start="2"><li><strong>利用信号量集解决读者-写者问题</strong></li></ol><h4 id="吸烟者问题" tabindex="-1">吸烟者问题 <a class="header-anchor" href="#吸烟者问题" aria-label="Permalink to &quot;吸烟者问题&quot;">​</a></h4><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但要卷起并抽掉一支烟，抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放到桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者一个信号告诉已完成，此时供应者就将另外两种材料放到桌上，如此重复(让三个抽烟者轮流地抽烟)。</p><p><img src="/Lyc-notes/assets/%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98.DXTnX50z.png" alt="alt text"></p><h2 id="死锁" tabindex="-1">死锁 <a class="header-anchor" href="#死锁" aria-label="Permalink to &quot;死锁&quot;">​</a></h2><h3 id="死锁概述" tabindex="-1">死锁概述 <a class="header-anchor" href="#死锁概述" aria-label="Permalink to &quot;死锁概述&quot;">​</a></h3><p>引起死锁的主要是，需要采用互斥访问方式的，不可以被抢占的资源，比如打印机、数据文件、队列、信号量</p><ol><li><p>可重用性资源的消耗性资源</p><p>1）可重用性资源</p><p>是一种可供用户重复使用多次的资源，对资源的请求和释放都是利用系统调用来实现的</p><p>2）可消耗性资源</p><p>又称为临时资源，在进程运行期间，又进程动态地创建和消耗的</p></li><li><p>可抢占式资源和不可抢占性资源</p></li></ol><p>1）可抢占性资源</p><p>指某进程获得该资源后，该资源可以再被其它进程或系统抢占。CPU 和主存均属于可抢占性资源，不会发生死锁。</p><p>2）不可抢占性资源</p><p>一旦系统把某资源分配给该进程后，就不能将它强行收回，只能在进程用完之后自行释放。例如磁带机、打印机、刻光盘</p><h4 id="计算机系统中的死锁" tabindex="-1">计算机系统中的死锁 <a class="header-anchor" href="#计算机系统中的死锁" aria-label="Permalink to &quot;计算机系统中的死锁&quot;">​</a></h4><p>死锁的起因，通常是源于多个进程对资源的争夺，不仅对不可抢占式资源进行争夺时会引起死锁，而且对可消耗资源进行争夺时，也会引起死锁。</p><ol><li><p>竞争不可抢占性资源引起死锁</p><p>资源分配图：用方块代表可重用的资源，用圆圈代表进程。箭头从进程指向文件，表示进程请求资源（打开文件）；当箭头从资源指向进程时，表示该资源已被分配给该进程（已被进程打开）。如果形成一个环路，说明已进入死锁状态。 <img src="/Lyc-notes/assets/%E6%AD%BB%E9%94%81%E6%83%85%E5%86%B5.6unOlTM7.png" alt="30"></p></li><li><p>竞争可消耗资源引起死锁</p><p>如图 3-13</p></li><li><p>进程推进顺序不当引起死锁</p></li></ol><h4 id="死锁的定义、必要条件和处理方法" tabindex="-1">死锁的定义、必要条件和处理方法 <a class="header-anchor" href="#死锁的定义、必要条件和处理方法" aria-label="Permalink to &quot;死锁的定义、必要条件和处理方法&quot;">​</a></h4><ol><li><p><strong>死锁的定义</strong></p><p>如果一组进程中的每个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁。这组死锁进程中的每个进程都在等待另一个死锁进程所占用的资源。</p></li><li><p><strong>产生死锁的必要条件</strong></p><p>必须同时具备以下条件：</p><p>（1）互斥条件。</p><p>进程对所分配的资源进行排他使用，即在一段时间内，某资源只能被一个进程占用。</p><p>（2）请求和保持条件</p><p>进程已经保持了一个资源，但又提出了新的资源请求，而该资源已被其它进程占用，此时请求进程被阻塞，但对自己已获得的资源保持不放</p><p>（3）不可抢占条件</p><p>进程已获得的资源在未使用完之前不能被抢占，只能在进程使用完时由自己释放。</p><p>（4）循环等待条件</p><p>在发生死锁时，必然存在一个进程-资源的循环链，即进程集合，p1 等待 p2...</p></li><li><p><strong>处理死锁的方式</strong></p><p>（1）预防死锁</p><p>事先预防策略，破坏产生死锁四个必要条件中的一个或几个来预防死锁</p><p>（2）避免死锁</p><p>事先预防策略，在进行资源分配时，使用某种方法防止系统进入不安全状态，从而避免死锁。</p><p>（3）检测死锁</p><p>允许在运行过程中发生死锁，但可通过检测机构及时地检测出死锁的发生，然后采用适当的措施，把进程从死锁中解脱出来。</p><p>（4）解除死锁</p><p>当检测到系统中已发生死锁时，就采用相应措施，将进程从死锁中解脱出来，例如撤销一些进程、回收它们的资源。</p></li></ol><h3 id="预防死锁" tabindex="-1">预防死锁 <a class="header-anchor" href="#预防死锁" aria-label="Permalink to &quot;预防死锁&quot;">​</a></h3><br><h4 id="破坏-请求和保持-条件" tabindex="-1">破坏“请求和保持”条件 <a class="header-anchor" href="#破坏-请求和保持-条件" aria-label="Permalink to &quot;破坏“请求和保持”条件&quot;">​</a></h4><ol><li><p><strong>第一种协议</strong></p><p>该协议规定，所有进程在开始运行之前，<strong>必须一次性地申请其在整个运行过程中所需的全部资源</strong>。此时若系统有足够的资源分配给某进程，便可把其需要的所有资源分配给它。该进程在整个运行期间，便不会再提出资源要求，从而破坏了“请求”条件。在分配资源时，只要有一种资源不满足进程的要求，即使其它所需的各个资源都空闲也不分配给该进程，而让进程等待。由于该进程在等待期间未占用任何资源，于是破坏了“保持”条件。</p><p>优点：简单，易行且安全。</p><p>缺点：</p><p>（1）资源被严重浪费，严重恶化了资源的利用率。</p><p>（2）使进程经常会发生饥饿现象。</p></li><li><p><strong>第二种协议</strong></p><p>对第一种协议的改进，它允许一个进程只获得运行期间所需的资源后，便开始运行。运行过程中再逐步释放已分配给自己、且已用毕的资源，再请求新的资源。</p></li></ol><h4 id="破坏-不可抢占-条件" tabindex="-1">破坏“不可抢占”条件 <a class="header-anchor" href="#破坏-不可抢占-条件" aria-label="Permalink to &quot;破坏“不可抢占”条件&quot;">​</a></h4><p>协议中规定，当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待需要时再重新申请。这就意味着进程已占用的资源被暂时释放，或是被抢占了，从而破坏了“不可抢占”条件。</p><h4 id="破坏-循环等待-条件" tabindex="-1">破坏“循环等待”条件 <a class="header-anchor" href="#破坏-循环等待-条件" aria-label="Permalink to &quot;破坏“循环等待”条件&quot;">​</a></h4><p>对系统的资源进行编号，规定每个进程必须按序号递增的顺序请求资源。</p><h3 id="死锁避免" tabindex="-1">死锁避免 <a class="header-anchor" href="#死锁避免" aria-label="Permalink to &quot;死锁避免&quot;">​</a></h3><p>事先预防策略，在进行资源分配时，使用某种方法防止系统进入不安全状态，从而避免死锁。</p><h4 id="系统安全状态" tabindex="-1">系统安全状态 <a class="header-anchor" href="#系统安全状态" aria-label="Permalink to &quot;系统安全状态&quot;">​</a></h4><ol><li><p><strong>安全状态</strong></p><p>在该方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。</p><p>无法找到安全序列，则称为系统处于不安全状态，<strong>有可能</strong>会进入死锁状态，只要系统处于安全状态，系统便不会进入死锁状态。避免死锁的实质在于，系统在进行资源分配时，应使系统不进入不安全状态。</p></li><li><p><strong>安全状态之例</strong></p><p><img src="/Lyc-notes/assets/%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81.CLjsfOPY.png" alt="31"></p></li><li><p><strong>由安全状态向不安全状态的转换</strong></p></li></ol><h4 id="利用银行家算法避免死锁" tabindex="-1">利用银行家算法避免死锁 <a class="header-anchor" href="#利用银行家算法避免死锁" aria-label="Permalink to &quot;利用银行家算法避免死锁&quot;">​</a></h4><ol><li><p><strong>银行家算法中的数据结构</strong></p><p>（1）可利用资源向量 Available。这是一个含有 m 个元素的数组，其中每一元素代表一类可利用的资源数目，其初始值时系统中所配置的该类资源全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。如果 Available[j] = K，则表示系统中现有 Rj 类资源 K 个。</p><p>（2）最大需求矩阵 Max。这是一个 n✖️m 的矩阵，它定义了系统中 n 个进程中的每个进程对 m 类资源的最大需求。如果 Max[i,j] = K,则表示系统中现有 Rj 类资源 K 个。</p><p>（3）分配矩阵 Allocation。这也是一个 n✖️m 的矩阵，它定义了系统中每一类资源当前已分配给一个进程的资源数。如果 Allocation【i，j】 = K，则表示进程当前已分得 Rj 类资源的数目为 K。</p><p>（4）需求矩阵 Need。这也是一个 n✖️m 的矩阵，用以表示每个进程尚需要的各类资源数目。如果 Need[i,j]= k ,则表示进程 i 还需要 Rj 类资源 K 个方能完成其任务。</p><p>Need[i,j] = Max[i,j] - Allocation[i,j]</p></li><li><p><strong>银行家算法</strong></p></li></ol><p><img src="/Lyc-notes/assets/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95.Ch1XfcpJ.png" alt="32"></p><ol start="3"><li><p><strong>安全行算法</strong></p></li><li><p><strong>银行家算法之例</strong></p></li></ol><p><img src="/Lyc-notes/assets/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E6%A1%88%E4%BE%8B.B1hEMqwo.png" alt="33"></p><h3 id="死锁的检测与解除" tabindex="-1">死锁的检测与解除 <a class="header-anchor" href="#死锁的检测与解除" aria-label="Permalink to &quot;死锁的检测与解除&quot;">​</a></h3><br><h4 id="死锁的检测" tabindex="-1">死锁的检测 <a class="header-anchor" href="#死锁的检测" aria-label="Permalink to &quot;死锁的检测&quot;">​</a></h4><ol><li><p>资源分配图</p><p>进程 Pi 指向资源 Rj，它表示进程 Pi 请求一个单位的 Rj 资源，也就是请求边</p><p>资源 Rj 指向进程 Pi，它表示把一个单位的资源 Rj 分配给进程 Pi，也就是分配边</p></li><li><p><strong>死锁定理</strong></p><p>将资源分配图进行简化，去除一个进程的请求边和分配边，剩余进程得到资源执行之后同样去掉请求边和分配边，再经过一系列的简化后，若能消去图中所有的边，使所有进程都称为孤立结点，则称为该图时可完全简化的，否则不完全简化</p><p>S 为死锁状态的充分条件时：当且仅当 S 状态的资源分配图是不可完全简化的。该充分条件称为死锁定理。</p></li></ol><h4 id="死锁的解除" tabindex="-1">死锁的解除 <a class="header-anchor" href="#死锁的解除" aria-label="Permalink to &quot;死锁的解除&quot;">​</a></h4><p>常见的解除死锁的方法：</p><p>（1）抢占资源：从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态。</p><p>（2）终止（或撤销）进程。终止（或撤销）系统中的一个或多个死锁进程，直至打破循环环路，使系统从死锁状态中解脱出来</p><ol><li><p>终止进程的方法</p><p>1）终止所有死锁进程 2）逐个终止进程</p></li><li><p>付出代价最小的死锁解除算法</p></li><li><p>进程回退法</p></li></ol></div></div></main><footer class="VPDocFooter" data-v-c8ec17ab data-v-4ec03e8a><!--[--><!--[--><!--[--><!--[--><div class="doc-comments"><!----></div><!--]--><!--]--><!--]--><!--]--><div class="edit-info" data-v-4ec03e8a><!----><div class="last-updated" data-v-4ec03e8a><p class="VPLastUpdated" data-v-4ec03e8a data-v-b8268776>上次更新: <time datetime="2024-08-15T02:00:21.000Z" data-v-b8268776></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-4ec03e8a><span class="visually-hidden" id="doc-footer-aria-label" data-v-4ec03e8a>Pager</span><div class="pager" data-v-4ec03e8a><a class="VPLink link pager-link prev" href="/Lyc-notes/os/chapter1" data-v-4ec03e8a><!--[--><span class="desc" data-v-4ec03e8a>上一篇</span><span class="title" data-v-4ec03e8a>第一章 操作系统引论</span><!--]--></a></div><div class="pager" data-v-4ec03e8a><a class="VPLink link pager-link next" href="/Lyc-notes/os/chapter3" data-v-4ec03e8a><!--[--><span class="desc" data-v-4ec03e8a>下一篇</span><span class="title" data-v-4ec03e8a>第三章 内存管理</span><!--]--></a></div></nav></footer><!--[--><!--[--><!--[--><div style="" class="m-doc-footer" data-v-694eb995><div class="m-doc-footer-message" data-v-694eb995><img class="visitor" src="https://visitor-badge.laobi.icu/badge?page_id=LynnCen.Lyc-notes./os/chapter2" title="当前页面累计访问数" onerror="this.style.display=&#39;none&#39;" data-v-694eb995><p data-v-694eb995>如有转载或 CV 的请标注本站原文地址</p></div><p class="m-doc-footer-copyright" data-v-694eb995>Copyright © 2024-present LynnCen</p></div><!--]--><!--]--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-f10846f5 data-v-419f6452><div class="container" data-v-419f6452><p class="message" data-v-419f6452>如有转载或 CV 的请标注本站原文地址</p><p class="copyright" data-v-419f6452>Copyright © 2024-present LynnCen</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"408_2009.md\":\"CZjCBAyE\",\"408_2010.md\":\"Bu-K6AZq\",\"408_2011.md\":\"BHT7d9Po\",\"408_2012.md\":\"D1WAOOzC\",\"408_2013.md\":\"xkLc3Qyq\",\"408_2014.md\":\"BbljTLxe\",\"408_2015.md\":\"BYeJLKiD\",\"408_2016.md\":\"C0yZAyeI\",\"408_2017.md\":\"D_iCr4FM\",\"408_2018.md\":\"BH_Rldaq\",\"408_2019.md\":\"C5f1HZOZ\",\"algorithm_dp.md\":\"8_buJ3ib\",\"algorithm_lru.md\":\"CjKnNA2n\",\"algorithm_退避算法.md\":\"CdV2uWeP\",\"architecture_base.md\":\"CfSAKHwm\",\"architecture_iconfont.md\":\"Dp9YCtJV\",\"architecture_jp架构.md\":\"Bqts7y3X\",\"architecture_modern-frontend-architecture.md\":\"BZS-YjAz\",\"browser_ introduce.md\":\"0uRV8RKx\",\"browser_async_await.md\":\"EsGYCGNn\",\"browser_chrome开发者工具.md\":\"C_07WH0D\",\"browser_chrome架构.md\":\"B0gYAc--\",\"browser_csrf攻击.md\":\"FG6TmMRp\",\"browser_dom树.md\":\"BRIcRnuK\",\"browser_http.md\":\"DG1d6M4-\",\"browser_http1.md\":\"DXEP9Tha\",\"browser_http2.md\":\"DKW0e-Er\",\"browser_http3.md\":\"CTXo1mdT\",\"browser_https.md\":\"B9Ag17AW\",\"browser_performance.md\":\"ttKHMez8\",\"browser_performance中的main指标.md\":\"CnrgTlSB\",\"browser_promise.md\":\"BkJpI7jL\",\"browser_renderfirst.md\":\"DCZuJBOa\",\"browser_rendersec.md\":\"C25LxxNs\",\"browser_settimeout如何实现.md\":\"B9W5fV6U\",\"browser_tcp协议.md\":\"Fj_Pvoa3\",\"browser_this.md\":\"BMhvGJy-\",\"browser_xmlhttprequest.md\":\"D-iMAUw_\",\"browser_任务调度.md\":\"DLCQBvz2\",\"browser_作用域链和闭包.md\":\"DKi6ekh7\",\"browser_分层和合成.md\":\"DOXNcmeL\",\"browser_加载阶段性能.md\":\"QCd21Gyd\",\"browser_变量提升.md\":\"CSFs2bqd\",\"browser_同源策略.md\":\"BdRxIv4S\",\"browser_块级作用域.md\":\"DrMzApqW\",\"browser_垃圾回收.md\":\"DROIF1gh\",\"browser_安全沙箱.md\":\"BtalHxvP\",\"browser_宏任务和微任务.md\":\"BdyWPwW0\",\"browser_导航流程.md\":\"DvrDtcdI\",\"browser_栈和堆.md\":\"DebrUKgw\",\"browser_浏览上下文组.md\":\"Blv0e1yX\",\"browser_消息队列和事件循环.md\":\"DuKrPQVc\",\"browser_渐进式网页应用pwa.md\":\"BfQVWlkI\",\"browser_渲染流水线.md\":\"Bj9s0Ws8\",\"browser_编译器和解释器.md\":\"CjIc0yVE\",\"browser_虚拟dom.md\":\"BePvI6h6\",\"browser_调用栈.md\":\"DYJX8ZGx\",\"browser_跨站脚本攻击xss.md\":\"DmkBIL6E\",\"browser_页面性能.md\":\"CJRxAsL7\",\"computerbasics_index.md\":\"73HFuQUv\",\"datastructure_chapter1.md\":\"GfiJiO2F\",\"datastructure_chapter1_ex.md\":\"gMMAgDDM\",\"datastructure_chapter2.md\":\"BAKiUSga\",\"datastructure_chapter2_ex.md\":\"Cm2_Suo2\",\"datastructure_chapter3.md\":\"C8QP5BbJ\",\"datastructure_chapter4.md\":\"YdsrBRB0\",\"datastructure_chapter5.md\":\"CXDwRHpw\",\"datastructure_chapter6.md\":\"BPAcOP_W\",\"datastructure_chapter7.md\":\"C8w9vKws\",\"datastructure_chapter8.md\":\"BQ8srvOt\",\"datastructure_强化.md\":\"BcR0BWbH\",\"docs_hello.md\":\"Tv1jE8Ax\",\"git_basic.md\":\"K8jAsQkM\",\"index.md\":\"B8T51nog\",\"interview_2025.md\":\"IPyvLbEq\",\"interview_browser.md\":\"D6agxzG0\",\"interview_coding.md\":\"BJGMMTX0\",\"interview_css.md\":\"D0iWgbcT\",\"interview_html.md\":\"DI3vF6np\",\"interview_js.md\":\"DiS1nsjT\",\"interview_network.md\":\"Bu2Jeu49\",\"interview_project.md\":\"bw5Obvx9\",\"interview_react.md\":\"DJQlztZk\",\"interview_typescript.md\":\"CBsCiSGy\",\"interview_webpack.md\":\"Ct_xHcSe\",\"java_schedu.md\":\"COVECLm2\",\"javascript_advance_browser.md\":\"BglNjOKm\",\"javascript_advance_execution.md\":\"DaVkORwK\",\"javascript_advance_executioncontext.md\":\"Dik99NOT\",\"javascript_advance_executionstack.md\":\"CJxFdDxK\",\"javascript_basic_你不知道的js.md\":\"Dk7tQOaL\",\"mine_about.md\":\"CkQOvSij\",\"mine_resume.md\":\"3JfejslW\",\"mine_resume_fudan.md\":\"BnnX22Y1\",\"mobile_pha.md\":\"ChAe1Jbg\",\"nav_index.md\":\"CSi60c5p\",\"node_packages.md\":\"CgFb076N\",\"os_chapter1.md\":\"CSRKzgvy\",\"os_chapter2.md\":\"BLnWXLeo\",\"os_chapter3.md\":\"DNPsF1nY\",\"os_chapter4.md\":\"BXXWNlGu\",\"os_chapter5.md\":\"3JNVShxf\",\"os_强化.md\":\"Db0M4zfK\",\"postgraduate_school.md\":\"DJ4P8fqw\",\"posts_communicationmechanisms.md\":\"DVu74c7E\",\"posts_compareviteandwebpack.md\":\"BCOQHUD_\",\"posts_dataprefetch.md\":\"DT1Nfgbs\",\"posts_im多端一致性.md\":\"BiGF7iAS\",\"posts_index.md\":\"DBpai7tx\",\"posts_rendermode.md\":\"BzZjAtvD\",\"posts_rpxtovw.md\":\"DGp-tC5K\",\"posts_skelon.md\":\"BoGSsTYC\",\"posts_uno-css-jp.md\":\"Byq-_517\",\"posts_埋点.md\":\"z_CwnbG5\",\"posts_性能优化.md\":\"DVX2M-x7\",\"project_aem.md\":\"2eeRWdnY\",\"project_component_ssr.md\":\"BpMu0y3o\",\"project_cross_border.md\":\"DklNBdBE\",\"project_generate_icon.md\":\"vdb07jKq\",\"project_index.md\":\"CWR_QkaL\",\"project_lerna_monorepo.md\":\"Dxo62p71\",\"project_linyang.md\":\"BkWsqRJl\",\"project_local_return.md\":\"BdgAFohZ\",\"project_odin_document.md\":\"DuJYS6dk\",\"project_platform_ai-service.md\":\"C9lAyEV1\",\"project_platform_video-architecture.md\":\"DMwgHwye\",\"project_react-intl.md\":\"CMAPCyBs\",\"project_ssr_operate.md\":\"DpZuO1dY\",\"project_taojp.md\":\"BJnd95GC\",\"project_tmm_architecture.md\":\"D9KzvnSh\",\"project_tmm_index.md\":\"3FMpVoYY\",\"project_tmm_local_search.md\":\"zaHTSSf_\",\"project_tmm_mention.md\":\"DEb_MC7A\",\"project_tmm_partfileupload.md\":\"Div2exjL\",\"project_tmm_performance_optimization.md\":\"DVhUqAYF\",\"project_tmm_rbac.md\":\"cxa9KCFS\",\"project_tmm_resources_manner.md\":\"Cg5qiRur\",\"react_core_createelement.md\":\"DcX39IcB\",\"react_core_intro.md\":\"BZ9KcFDV\",\"react_core_stream.md\":\"BpOwymyq\",\"react_customhook_hooks.md\":\"BRERtG7v\",\"react_customhook_usesetstate.md\":\"BxBVeFz1\",\"react_record_thinking.md\":\"D-ewg24c\",\"react_utils_type.md\":\"ZTciyPmZ\",\"record_amap.md\":\"B9eHQ6ml\",\"record_nvm.md\":\"waVxgrPp\",\"record_tallking.md\":\"ov5KY5Xy\",\"softexame_2016上半年上午.md\":\"oh3DImgZ\",\"softexame_2020下半年下午.md\":\"kV0WEUII\",\"softexame_database.md\":\"BlvuVxWp\",\"softexame_index.md\":\"DyNel4_k\",\"softexame_schedule.md\":\"CQ7ijubH\",\"softexame_软件工程.md\":\"DycWOxK5\",\"softexame_软件工程必备知识点.md\":\"jgBs4PcC\",\"softexame_面向对象.md\":\"Cn92yjFE\",\"test.md\":\"DAmQ0jRK\",\"todo_2025.md\":\"CIbp0zn-\",\"todo_index.md\":\"D8UwG8gM\",\"typescript_class.md\":\"B7iblW37\",\"typescript_costums.md\":\"_H2o7DAL\",\"typescript_记录.md\":\"CbxWa3XN\",\"utils_throttle.md\":\"gU7FHuUr\",\"utils_utils.md\":\"DZtOgXzq\",\"vite_basic.md\":\"D-Y-0YCq\",\"vue_basic.md\":\"DbUHwY6x\",\"vue_index.md\":\"Cso_204F\",\"webpack_basic.md\":\"D4p2xi-d\",\"webpack_index.md\":\"D7rAaSa8\",\"webpack_optimization.md\":\"D_nUAjfI\",\"webpack_performance.md\":\"DEbNUFjb\",\"webpack_practice.md\":\"BvCC-He6\",\"webpack_principle.md\":\"CJXAB4PL\",\"webpack_unocss.md\":\"CtcoRP_Y\",\"webpack_埋点.md\":\"D2A8jVEf\",\"welcome.md\":\"CX5Ev3cW\",\"组成原理_chapter1.md\":\"Bzt_bm80\",\"组成原理_chapter2.md\":\"DuSCc78X\",\"组成原理_chapter3.md\":\"BbkKqCS8\",\"组成原理_chapter4.md\":\"BZnwBUfv\",\"组成原理_chapter5.md\":\"BJMKGSeC\",\"组成原理_chapter6.md\":\"Don2DnxU\",\"组成原理_chapter7.md\":\"CO2hmS8C\",\"组成原理_强化.md\":\"bc-B-Vv9\",\"计网_chapter1.md\":\"DtTkqp8x\",\"计网_chapter2.md\":\"Af5pJ6sM\",\"计网_chapter3.md\":\"D64CsRZt\",\"计网_http.md\":\"DwkrjDFw\",\"计网_https.md\":\"Bb1nygkf\",\"计网_websocket.md\":\"BOJg_JjW\",\"计网_强化.md\":\"DlkJcKJh\",\"设计模式_index.md\":\"BFD8tZYd\",\"设计模式_模版方法.md\":\"hLWshShX\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"zh-CN\",\"dir\":\"ltr\",\"title\":\"林岑LynnCenʘᴗʘ \",\"description\":\"林岑的成长之路，包含前端常用知识、源码阅读笔记、各种奇淫技巧、日常提效工具等\",\"base\":\"/Lyc-notes/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"i18nRouting\":false,\"logo\":\"/LynnCenLogo.png\",\"nav\":[{\"text\":\"WebFront\",\"items\":[{\"text\":\"Javascript基础\",\"activeMatch\":\"Javascript/basic/\",\"link\":\"Javascript/basic/你不知道的js\"},{\"text\":\"Javascript进阶\",\"activeMatch\":\"Javascript/Advance/\",\"link\":\"Javascript/Advance/executionContext\"},{\"text\":\"Typescript\",\"activeMatch\":\"/typescript/\",\"link\":\"/typescript/记录\"},{\"text\":\"浏览器原理\",\"activeMatch\":\"/browser/\",\"link\":\"/browser/Chrome架构\"}]},{\"text\":\"ComputerBasics\",\"items\":[{\"text\":\"计算机组成原理\",\"items\":[{\"text\":\"计算机组成原理基础\",\"link\":\"/组成原理/chapter1\"}]},{\"text\":\"数据结构\",\"items\":[{\"text\":\"数据结构基础\",\"link\":\"/dataStructure/chapter1\"},{\"text\":\"课后习题\",\"link\":\"/dataStructure/chapter1_ex\"}]},{\"text\":\"操作系统OS\",\"items\":[{\"text\":\"操作系统基础\",\"link\":\"/os/chapter1\"}]},{\"text\":\"计算机网络\",\"items\":[{\"text\":\"计算机网络基础\",\"link\":\"/计网/chapter1\"}]},{\"text\":\"408\",\"items\":[{\"text\":\"408真题\",\"link\":\"/408/2009\"}]}]},{\"text\":\"Frameworks\",\"items\":[{\"text\":\"React\",\"activeMatch\":\"/react/\",\"link\":\"react/core/intro\"},{\"text\":\"Vue\",\"link\":\"Vue/basic\"}]},{\"text\":\"Engineering\",\"items\":[{\"text\":\"WebPack\",\"activeMatch\":\"/webpack/\",\"link\":\"webpack/performance\"},{\"text\":\"Node\",\"activeMatch\":\"/node/\",\"link\":\"node/packages\"},{\"text\":\"Vite\",\"activeMatch\":\"/vite/\",\"link\":\"vite/basic\"},{\"text\":\"Git\",\"activeMatch\":\"/git/\",\"link\":\"git/basic\"}]},{\"text\":\"Interview\",\"activeMatch\":\"/interview/\",\"link\":\"/interview/js\"}],\"sidebar\":{\"/Javascript/\":[{\"text\":\"JS引擎\",\"link\":\"Javascript/Advance/execution\"},{\"text\":\"调用堆栈\",\"items\":[{\"text\":\"执行上下文和执行栈\",\"link\":\"Javascript/Advance/executionContext\"},{\"text\":\"执行上下文栈和变量对象\",\"link\":\"Javascript/Advance/executionStack\"}]}],\"/react/\":[{\"text\":\"React源码详解\",\"items\":[{\"text\":\"第一篇 React运行全流程\",\"link\":\"/react/core/intro\"},{\"text\":\"第二篇 JSX 是如何转换为 React.createElement\",\"link\":\"/react/core/createElement\"}]},{\"text\":\"React实践\",\"items\":[{\"text\":\"思考\",\"link\":\"/react/record/thinking\"},{\"text\":\"自定义Hooks\",\"link\":\"/react/customHook/hooks\"},{\"text\":\"React with TS\",\"link\":\"/react/utils/type\"}]}],\"/interview/\":[{\"text\":\"HTML\",\"link\":\"/interview/html\"},{\"text\":\"CSS\",\"link\":\"/interview/css\"},{\"text\":\"Javascript\",\"link\":\"/interview/js\"},{\"text\":\"React\",\"link\":\"/interview/react\"},{\"text\":\"Typescript\",\"link\":\"/interview/typescript\"},{\"text\":\"WebPack\",\"link\":\"/interview/webpack\"},{\"text\":\"浏览器\",\"link\":\"/interview/browser\"},{\"text\":\"网络\",\"link\":\"/interview/network\"},{\"text\":\"项目总结\",\"link\":\"/project/index\"},{\"text\":\"笔试题\",\"link\":\"/interview/coding\"}],\"/os/\":[{\"text\":\"操作系统基础\",\"items\":[{\"text\":\"第一章 操作系统引论\",\"link\":\"/os/chapter1\"},{\"text\":\"第二章 进程与线程\",\"link\":\"/os/chapter2\"},{\"text\":\"第三章 内存管理\",\"link\":\"/os/chapter3\"},{\"text\":\"第四章 文件管理\",\"link\":\"/os/chapter4\"},{\"text\":\"第五章 磁盘和固态硬盘\",\"link\":\"/os/chapter5\"},{\"text\":\"强化\",\"link\":\"/os/强化\"}]}],\"/408/\":[{\"text\":\"2009真题\",\"link\":\"/408/2009\"},{\"text\":\"2010真题\",\"link\":\"/408/2010\"},{\"text\":\"2011真题\",\"link\":\"/408/2011\"},{\"text\":\"2012真题\",\"link\":\"/408/2012\"},{\"text\":\"2013真题\",\"link\":\"/408/2013\"},{\"text\":\"2014真题\",\"link\":\"/408/2014\"},{\"text\":\"2015真题\",\"link\":\"/408/2015\"},{\"text\":\"2016真题\",\"link\":\"/408/2016\"},{\"text\":\"2017真题\",\"link\":\"/408/2017\"},{\"text\":\"2018真题\",\"link\":\"/408/2018\"},{\"text\":\"2019真题\",\"link\":\"/408/2019\"}],\"计网\":[{\"text\":\"强化\",\"link\":\"/计网/强化\"}],\"/dataStructure/\":[{\"text\":\"数据结构\",\"items\":[{\"text\":\"第一章 绪论\",\"link\":\"/dataStructure/chapter1\"},{\"text\":\"第二章 线性表\",\"link\":\"/dataStructure/chapter2\"},{\"text\":\"第三章 栈、队列和数组\",\"link\":\"/dataStructure/chapter3\"},{\"text\":\"第四章 串\",\"link\":\"/dataStructure/chapter4\"},{\"text\":\"第五章 树与二叉树\",\"link\":\"/dataStructure/chapter5\"},{\"text\":\"第六章 图\",\"link\":\"/dataStructure/chapter6\"},{\"text\":\"第七章 查找\",\"link\":\"/dataStructure/chapter7\"},{\"text\":\"第八章 排序\",\"link\":\"/dataStructure/chapter8\"}]},{\"text\":\"课后习题\",\"items\":[{\"text\":\"第一章 绪论\",\"link\":\"/dataStructure/chapter1_ex\"},{\"text\":\"第二章 线性表\",\"link\":\"/dataStructure/chapter2_ex\"},{\"text\":\"强化\",\"link\":\"/dataStructure/强化\"}]}],\"/组成原理/\":[{\"text\":\"计算机组成原理\",\"items\":[{\"text\":\"第一章 计算机系统概述\",\"link\":\"/组成原理/chapter1\"},{\"text\":\"第二章 数据的表示和运算\",\"link\":\"/组成原理/chapter2\"},{\"text\":\"第三章 存储系统\",\"link\":\"/组成原理/chapter3\"},{\"text\":\"第四章 指令系统\",\"link\":\"/组成原理/chapter4\"},{\"text\":\"第五章 中央处理器\",\"link\":\"/组成原理/chapter5\"},{\"text\":\"第六章 总线\",\"link\":\"/组成原理/chapter6\"},{\"text\":\"第七章 输入/输出系统\",\"link\":\"/组成原理/chapter7\"},{\"text\":\"强化\",\"link\":\"/组成原理/强化\"}]}],\"/webpack/\":[{\"text\":\"WebPack\",\"items\":[{\"text\":\"基础篇\",\"link\":\"/webpack/basic\"},{\"text\":\"实战篇\",\"link\":\"/webpack/practice\"},{\"text\":\"优化篇\",\"link\":\"/webpack/optimization\"},{\"text\":\"原理篇\",\"link\":\"/webpack/principle\"},{\"text\":\"性能优化\",\"link\":\"/webpack/performance\"}]}],\"/browser/\":[{\"text\":\"宏观视角下的浏览器\",\"items\":[{\"text\":\"Chorme架构\",\"link\":\"/browser/Chrome架构\"},{\"text\":\"TCP协议\",\"link\":\"/browser/TCP协议\"},{\"text\":\"HTTP协议\",\"link\":\"/browser/HTTP\"},{\"text\":\"导航流程\",\"link\":\"/browser/导航流程\"},{\"text\":\"渲染流程（上）\",\"link\":\"/browser/renderfirst\"},{\"text\":\"渲染流程（下）\",\"link\":\"/browser/rendersec\"}]},{\"text\":\"Javascript中的执行机制\",\"items\":[{\"text\":\"变量提升\",\"link\":\"/browser/变量提升\"},{\"text\":\"调用栈\",\"link\":\"/browser/调用栈\"},{\"text\":\"块级作用域\",\"link\":\"/browser/块级作用域\"},{\"text\":\"作用域链和闭包\",\"link\":\"/browser/作用域链和闭包\"},{\"text\":\"This\",\"link\":\"/browser/this\"}]},{\"text\":\"V8工作原理\",\"items\":[{\"text\":\"栈空间和堆空间\",\"link\":\"/browser/栈和堆\"},{\"text\":\"垃圾回收\",\"link\":\"/browser/垃圾回收\"},{\"text\":\"编译器和解释器\",\"link\":\"/browser/编译器和解释器\"}]},{\"text\":\"浏览器中的页面循环系统\",\"items\":[{\"text\":\"消息队列和事件循环\",\"link\":\"/browser/消息队列和事件循环\"},{\"text\":\"setTimeout 是如何实现的？\",\"link\":\"/browser/setTimeout如何实现\"},{\"text\":\"XMLHttpRequest 是怎么实现的？\",\"link\":\"/browser/XMLHttpRequest\"},{\"text\":\"宏任务和微任务\",\"link\":\"/browser/宏任务和微任务\"},{\"text\":\"Promise\",\"link\":\"/browser/Promise\"},{\"text\":\"async/await\",\"link\":\"/browser/async&await\"}]},{\"text\":\"浏览器中的页面\",\"items\":[{\"text\":\"Chrome开发者工具\",\"link\":\"/browser/Chrome开发者工具\"},{\"text\":\"DOM树\",\"link\":\"/browser/DOM树\"},{\"text\":\"渲染流水线\",\"link\":\"/browser/渲染流水线\"},{\"text\":\"分层和合成机制\",\"link\":\"/browser/分层和合成\"},{\"text\":\"页面性能\",\"link\":\"/browser/页面性能\"},{\"text\":\"虚拟DOM\",\"link\":\"/browser/虚拟DOM\"},{\"text\":\"渐进式网页应用PWA\",\"link\":\"/browser/渐进式网页应用PWA\"}]},{\"text\":\"浏览器中的网络\",\"items\":[{\"text\":\"HTTP1\",\"link\":\"/browser/HTTP1\"},{\"text\":\"HTTP2\",\"link\":\"/browser/HTTP2\"},{\"text\":\"HTTP3\",\"link\":\"/browser/HTTP3\"}]},{\"text\":\"浏览器安全\",\"items\":[{\"text\":\"同源策略\",\"link\":\"/browser/同源策略\"},{\"text\":\"跨站脚本攻击XSS\",\"link\":\"/browser/跨站脚本攻击XSS\"},{\"text\":\"CSRF攻击\",\"link\":\"/browser/CSRF攻击\"},{\"text\":\"安全沙箱\",\"link\":\"/browser/安全沙箱\"},{\"text\":\"HTTPS\",\"link\":\"/browser/HTTPS\"}]},{\"text\":\"浏览上下文组\",\"link\":\"/browser/浏览上下文组\"},{\"text\":\"任务调度\",\"link\":\"/browser/任务调度\"},{\"text\":\"加载阶段性能\",\"link\":\"/browser/加载阶段性能\"},{\"text\":\"Performance\",\"link\":\"/browser/Performance\"},{\"text\":\"Performance中的Main指标\",\"link\":\"/browser/Performance中的Main指标\"}],\"/计网/\":[{\"text\":\"计算机网络基础\",\"items\":[{\"text\":\"第一章 计算机网络体系结构\",\"link\":\"/计网/chapter1\"},{\"text\":\"第二章 物理层\",\"link\":\"/计网/chapter2\"},{\"text\":\"第三章 数据链路层\",\"link\":\"/计网/chapter3\"}]},{\"text\":\"HTTPS\",\"link\":\"/计网/https\"},{\"text\":\"WebSocket\",\"link\":\"/计网/webSocket\"}],\"/project/\":[{\"text\":\"项目总结\",\"link\":\"/project/index\"},{\"text\":\"TMM\",\"link\":\"/project/tmm\",\"items\":[{\"text\":\"TMM模块重构与架构设计\",\"link\":\"/project/tmm/architecture\"},{\"text\":\"本地化搜索引擎实现\",\"link\":\"/project/tmm/local_search\"},{\"text\":\"@功能的高效实现\",\"link\":\"/project/tmm/mention\"},{\"text\":\"ELectron大文件分片上传、断点续传、并行上传\",\"link\":\"/project/tmm/partFileUpload\"},{\"text\":\"TMM性能优化\",\"link\":\"/project/tmm/performance_optimization\"},{\"text\":\"基于RBAC模型的群组权限体系设计与实现\",\"link\":\"/project/tmm/RBAC\"},{\"text\":\"基于AWS和Node流式大文件下载\",\"link\":\"/project/tmm/resources_manner\"}]}],\"/algorithm/\":[{\"text\":\"退避算法\",\"link\":\"/algorithm/退避算法\"},{\"text\":\"LRU算法\",\"link\":\"/algorithm/LRU\"}]},\"search\":{\"provider\":\"local\"},\"outline\":{\"level\":\"deep\",\"label\":\"本页目录\"},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/LynnCen\"}],\"footer\":{\"message\":\"如有转载或 CV 的请标注本站原文地址\",\"copyright\":\"Copyright © 2024-present LynnCen\"},\"darkModeSwitchLabel\":\"外观\",\"returnToTopLabel\":\"返回顶部\",\"lastUpdatedText\":\"上次更新\",\"docFooter\":{\"prev\":\"上一篇\",\"next\":\"下一篇\"},\"visitor\":{\"badgeId\":\"LynnCen.Lyc-notes\"},\"comment\":{\"repo\":\"LynnCen/Lyc-notes\",\"repoId\":\"R_kgDOLsOwUg\",\"category\":\"Announcements\",\"categoryId\":\"DIC_kwDOLsOwUs4CenzY\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":true}");</script>
    
  </body>
</html>