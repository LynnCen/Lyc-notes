<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>软考软件设计师（中级）- 软件工程核心知识点与备考指南 | 林岑LynnCenʘᴗʘ </title>
    <meta name="description" content="林岑的成长之路，包含前端常用知识、源码阅读笔记、各种奇淫技巧、日常提效工具等">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/Lyc-notes/assets/style.BDbbue0r.css" as="style">
    <link rel="preload stylesheet" href="/Lyc-notes/vp-icons.css" as="style">
    
    <script type="module" src="/Lyc-notes/assets/app.CmRzVTS-.js"></script>
    <link rel="preload" href="/Lyc-notes/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/framework.DfyYcdQv.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/theme.F_SiF7xB.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/katex.ChWnQ-fc.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/dagre-JOIXM2OF.B03CsX6C.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/c4Diagram-6F6E4RAY.ScDu3hYK.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/flowDiagram-KYDEHFYC.BNv98JZN.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/erDiagram-3M52JZNH.tbvqSP0t.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/gitGraphDiagram-GW3U2K7C.BkCQOQIJ.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/ganttDiagram-EK5VF46D.ssO69Ul5.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/infoDiagram-LHK5PUON.DGokGWwv.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/pieDiagram-NIOCPIFQ.DVgc2EFS.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/quadrantDiagram-2OG54O6I.C-fXEsGM.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/xychartDiagram-H2YORKM3.DkrfXHMq.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/requirementDiagram-QOLK2EJ7.FZUvqLiD.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/sequenceDiagram-SKLFT4DO.vICH8bXH.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/classDiagram-M3E45YP4.BNgCOnwY.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/classDiagram-v2-YAWTLIQI.BNgCOnwY.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/stateDiagram-MI5ZYTHO.Bd_rNI48.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/stateDiagram-v2-5AN5P6BG.BDsLQMMD.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/journeyDiagram-EWQZEKCU.aryWC8bh.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/timeline-definition-MYPXXCX6.BkWO8IQL.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/mindmap-definition-6CBA2TL7.qQBlpo0B.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/kanban-definition-ZSS6B67P.w1uBMOe4.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/sankeyDiagram-4UZDY2LN.CNenaLEt.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/diagram-5UYTHUR4.Tg-aH-n2.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/diagram-ZTM2IBQH.CCCMroqK.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/blockDiagram-6J76NXCF.C0ozT9T_.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/architectureDiagram-SUXI7LT5.CKyrwYRZ.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/diagram-VMROVX33.kzuCSHuI.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/chunks/virtual_mermaid-config.DDnGl6nM.js">
    <link rel="modulepreload" href="/Lyc-notes/assets/softExame_软件工程必备知识点.md.DDrchgB8.lean.js">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/favicon.ico">
    <link rel="mask-icon" href="/favicon.ico" color="#3eaf7c">
    <meta name="msapplication-TileImage" content="/favicon.ico">
    <meta name="msapplication-TileColor" content="#000000">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-ae963f28><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0d803733></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0d803733>Skip to content</a><!--]--><!----><header class="VPNav" data-v-ae963f28 data-v-dd46fddc><div class="VPNavBar" data-v-dd46fddc data-v-75e0aaf6><div class="wrapper" data-v-75e0aaf6><div class="container" data-v-75e0aaf6><div class="title" data-v-75e0aaf6><div class="VPNavBarTitle has-sidebar" data-v-75e0aaf6 data-v-7625b644><a class="title" href="/Lyc-notes/" data-v-7625b644><!--[--><!--]--><!--[--><img class="VPImage logo" src="/Lyc-notes/LynnCenLogo.png" alt data-v-b3e11f27><!--]--><span data-v-7625b644>林岑LynnCenʘᴗʘ </span><!--[--><!--[--><!--[--><!--[--><img class="visitor" src="https://visitor-badge.laobi.icu/badge?page_id=LynnCen.Lyc-notes" onerror="this.style.display=&#39;none&#39;" data-v-124f1dab><!--]--><!--]--><!--]--><!--]--></a></div></div><div class="content" data-v-75e0aaf6><div class="content-body" data-v-75e0aaf6><!--[--><!--]--><div class="VPNavBarSearch search" data-v-75e0aaf6><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-75e0aaf6 data-v-64d30c34><span id="main-nav-aria-label" class="visually-hidden" data-v-64d30c34> Main Navigation </span><!--[--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-64d30c34 data-v-5265d8b1><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-5265d8b1><span class="text" data-v-5265d8b1><!----><span data-v-5265d8b1>WebFront</span><span class="vpi-chevron-down text-icon" data-v-5265d8b1></span></span></button><div class="menu" data-v-5265d8b1><div class="VPMenu" data-v-5265d8b1 data-v-48acf8b1><div class="items" data-v-48acf8b1><!--[--><!--[--><div class="VPMenuGroup" data-v-48acf8b1 data-v-fa175673><p class="title" data-v-fa175673>前端基础</p><!--[--><!--[--><div class="VPMenuLink" data-v-fa175673 data-v-df7d52ad><a class="VPLink link" href="/Lyc-notes/Javascript/basic/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js" data-v-df7d52ad><!--[--><span data-v-df7d52ad>Javascript基础</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-fa175673 data-v-df7d52ad><a class="VPLink link" href="/Lyc-notes/Javascript/Advance/executionContext" data-v-df7d52ad><!--[--><span data-v-df7d52ad>Javascript进阶</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-fa175673 data-v-df7d52ad><a class="VPLink link" href="/Lyc-notes/typescript/%E8%AE%B0%E5%BD%95" data-v-df7d52ad><!--[--><span data-v-df7d52ad>Typescript</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-48acf8b1 data-v-fa175673><p class="title" data-v-fa175673>Framework</p><!--[--><!--[--><div class="VPMenuLink" data-v-fa175673 data-v-df7d52ad><a class="VPLink link" href="/Lyc-notes/react/core/intro" data-v-df7d52ad><!--[--><span data-v-df7d52ad>React</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-fa175673 data-v-df7d52ad><a class="VPLink link" href="/Lyc-notes/Vue/basic" data-v-df7d52ad><!--[--><span data-v-df7d52ad>Vue</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-48acf8b1 data-v-fa175673><p class="title" data-v-fa175673>Engineering</p><!--[--><!--[--><div class="VPMenuLink" data-v-fa175673 data-v-df7d52ad><a class="VPLink link" href="/Lyc-notes/webpack/performance" data-v-df7d52ad><!--[--><span data-v-df7d52ad>WebPack</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-fa175673 data-v-df7d52ad><a class="VPLink link" href="/Lyc-notes/node/packages" data-v-df7d52ad><!--[--><span data-v-df7d52ad>Node</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-fa175673 data-v-df7d52ad><a class="VPLink link" href="/Lyc-notes/vite/basic" data-v-df7d52ad><!--[--><span data-v-df7d52ad>Vite</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-fa175673 data-v-df7d52ad><a class="VPLink link" href="/Lyc-notes/git/basic" data-v-df7d52ad><!--[--><span data-v-df7d52ad>Git</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-48acf8b1 data-v-fa175673><p class="title" data-v-fa175673>浏览器</p><!--[--><!--[--><div class="VPMenuLink" data-v-fa175673 data-v-df7d52ad><a class="VPLink link" href="/Lyc-notes/browser/Chrome%E6%9E%B6%E6%9E%84" data-v-df7d52ad><!--[--><span data-v-df7d52ad>浏览器原理</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-64d30c34 data-v-5265d8b1><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-5265d8b1><span class="text" data-v-5265d8b1><!----><span data-v-5265d8b1>ComputerBasics</span><span class="vpi-chevron-down text-icon" data-v-5265d8b1></span></span></button><div class="menu" data-v-5265d8b1><div class="VPMenu" data-v-5265d8b1 data-v-48acf8b1><div class="items" data-v-48acf8b1><!--[--><!--[--><div class="VPMenuGroup" data-v-48acf8b1 data-v-fa175673><p class="title" data-v-fa175673>计算机组成原理</p><!--[--><!--[--><div class="VPMenuLink" data-v-fa175673 data-v-df7d52ad><a class="VPLink link" href="/Lyc-notes/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/chapter1" data-v-df7d52ad><!--[--><span data-v-df7d52ad>计算机组成原理基础</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-48acf8b1 data-v-fa175673><p class="title" data-v-fa175673>数据结构</p><!--[--><!--[--><div class="VPMenuLink" data-v-fa175673 data-v-df7d52ad><a class="VPLink link" href="/Lyc-notes/dataStructure/chapter1" data-v-df7d52ad><!--[--><span data-v-df7d52ad>数据结构基础</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-fa175673 data-v-df7d52ad><a class="VPLink link" href="/Lyc-notes/dataStructure/chapter1_ex" data-v-df7d52ad><!--[--><span data-v-df7d52ad>课后习题</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-48acf8b1 data-v-fa175673><p class="title" data-v-fa175673>操作系统OS</p><!--[--><!--[--><div class="VPMenuLink" data-v-fa175673 data-v-df7d52ad><a class="VPLink link" href="/Lyc-notes/os/chapter1" data-v-df7d52ad><!--[--><span data-v-df7d52ad>操作系统基础</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-48acf8b1 data-v-fa175673><p class="title" data-v-fa175673>计算机网络</p><!--[--><!--[--><div class="VPMenuLink" data-v-fa175673 data-v-df7d52ad><a class="VPLink link" href="/Lyc-notes/%E8%AE%A1%E7%BD%91/chapter1" data-v-df7d52ad><!--[--><span data-v-df7d52ad>计算机网络基础</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-48acf8b1 data-v-fa175673><p class="title" data-v-fa175673>408</p><!--[--><!--[--><div class="VPMenuLink" data-v-fa175673 data-v-df7d52ad><a class="VPLink link" href="/Lyc-notes/408/2009" data-v-df7d52ad><!--[--><span data-v-df7d52ad>408真题</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuLink" data-v-48acf8b1 data-v-df7d52ad><a class="VPLink link" href="/Lyc-notes/designPatterns/index" data-v-df7d52ad><!--[--><span data-v-df7d52ad>设计模式</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-64d30c34 data-v-5265d8b1><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-5265d8b1><span class="text" data-v-5265d8b1><!----><span data-v-5265d8b1>AI</span><span class="vpi-chevron-down text-icon" data-v-5265d8b1></span></span></button><div class="menu" data-v-5265d8b1><div class="VPMenu" data-v-5265d8b1 data-v-48acf8b1><div class="items" data-v-48acf8b1><!--[--><!--[--><div class="VPMenuGroup" data-v-48acf8b1 data-v-fa175673><p class="title" data-v-fa175673>MCP</p><!--[--><!--[--><div class="VPMenuLink" data-v-fa175673 data-v-df7d52ad><a class="VPLink link" href="/Lyc-notes/AI/mcp/browserTools" data-v-df7d52ad><!--[--><span data-v-df7d52ad>BrowserTools MCP</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-fa175673 data-v-df7d52ad><a class="VPLink link" href="/Lyc-notes/AI/mcp/figma" data-v-df7d52ad><!--[--><span data-v-df7d52ad>Figma Dev Mode MCP</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-48acf8b1 data-v-fa175673><p class="title" data-v-fa175673>Dify</p><!--[--><!--[--><div class="VPMenuLink" data-v-fa175673 data-v-df7d52ad><a class="VPLink link" href="/Lyc-notes/AI/Dify/index" data-v-df7d52ad><!--[--><span data-v-df7d52ad>Dify</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-64d30c34 data-v-5265d8b1><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-5265d8b1><span class="text" data-v-5265d8b1><!----><span data-v-5265d8b1>SoftExame</span><span class="vpi-chevron-down text-icon" data-v-5265d8b1></span></span></button><div class="menu" data-v-5265d8b1><div class="VPMenu" data-v-5265d8b1 data-v-48acf8b1><div class="items" data-v-48acf8b1><!--[--><!--[--><div class="VPMenuLink" data-v-48acf8b1 data-v-df7d52ad><a class="VPLink link" href="/Lyc-notes/softExame/index" data-v-df7d52ad><!--[--><span data-v-df7d52ad>软考-软件设计师</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Lyc-notes/interview/js" tabindex="0" data-v-64d30c34 data-v-2f18d88a><!--[--><span data-v-2f18d88a>Interview</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-75e0aaf6 data-v-5935c4bf><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-5935c4bf data-v-0ad617a5 data-v-fa4fbb5e><span class="check" data-v-fa4fbb5e><span class="icon" data-v-fa4fbb5e><!--[--><span class="vpi-sun sun" data-v-0ad617a5></span><span class="vpi-moon moon" data-v-0ad617a5></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-75e0aaf6 data-v-4de160cd data-v-0b2298c5><!--[--><a class="VPSocialLink no-icon" href="https://github.com/LynnCen" aria-label="github" target="_blank" rel="noopener" data-v-0b2298c5 data-v-20dc374c><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-75e0aaf6 data-v-e7b0f3b8 data-v-5265d8b1><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-5265d8b1><span class="vpi-more-horizontal icon" data-v-5265d8b1></span></button><div class="menu" data-v-5265d8b1><div class="VPMenu" data-v-5265d8b1 data-v-48acf8b1><!----><!--[--><!--[--><!----><div class="group" data-v-e7b0f3b8><div class="item appearance" data-v-e7b0f3b8><p class="label" data-v-e7b0f3b8>外观</p><div class="appearance-action" data-v-e7b0f3b8><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-e7b0f3b8 data-v-0ad617a5 data-v-fa4fbb5e><span class="check" data-v-fa4fbb5e><span class="icon" data-v-fa4fbb5e><!--[--><span class="vpi-sun sun" data-v-0ad617a5></span><span class="vpi-moon moon" data-v-0ad617a5></span><!--]--></span></span></button></div></div></div><div class="group" data-v-e7b0f3b8><div class="item social-links" data-v-e7b0f3b8><div class="VPSocialLinks social-links-list" data-v-e7b0f3b8 data-v-0b2298c5><!--[--><a class="VPSocialLink no-icon" href="https://github.com/LynnCen" aria-label="github" target="_blank" rel="noopener" data-v-0b2298c5 data-v-20dc374c><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-75e0aaf6 data-v-f6cabffb><span class="container" data-v-f6cabffb><span class="top" data-v-f6cabffb></span><span class="middle" data-v-f6cabffb></span><span class="bottom" data-v-f6cabffb></span></span></button></div></div></div></div><div class="divider" data-v-75e0aaf6><div class="divider-line" data-v-75e0aaf6></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-ae963f28 data-v-5e311b6f><div class="container" data-v-5e311b6f><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-5e311b6f><span class="vpi-align-left menu-icon" data-v-5e311b6f></span><span class="menu-text" data-v-5e311b6f>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-5e311b6f data-v-f312e4be><button data-v-f312e4be>返回顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-ae963f28 data-v-1eac674d><div class="curtain" data-v-1eac674d></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-1eac674d><span class="visually-hidden" id="sidebar-aria-label" data-v-1eac674d> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-e7cd70f7><section class="VPSidebarItem level-0" data-v-e7cd70f7 data-v-e052628c><!----><div class="items" data-v-e052628c><!--[--><div class="VPSidebarItem level-1 is-link" data-v-e052628c data-v-e052628c><div class="item" data-v-e052628c><div class="indicator" data-v-e052628c></div><a class="VPLink link link" href="/Lyc-notes/softExame/index" data-v-e052628c><!--[--><p class="text" data-v-e052628c>软考-软件设计师</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e052628c data-v-e052628c><div class="item" data-v-e052628c><div class="indicator" data-v-e052628c></div><a class="VPLink link link" href="/Lyc-notes/softExame/schedule" data-v-e052628c><!--[--><p class="text" data-v-e052628c>时间规划</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e052628c data-v-e052628c><div class="item" data-v-e052628c><div class="indicator" data-v-e052628c></div><a class="VPLink link link" href="/Lyc-notes/softExame/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B" data-v-e052628c><!--[--><p class="text" data-v-e052628c>软件工程</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e052628c data-v-e052628c><div class="item" data-v-e052628c><div class="indicator" data-v-e052628c></div><a class="VPLink link link" href="/Lyc-notes/softExame/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1" data-v-e052628c><!--[--><p class="text" data-v-e052628c>面向对象</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e052628c data-v-e052628c><div class="item" data-v-e052628c><div class="indicator" data-v-e052628c></div><a class="VPLink link link" href="/Lyc-notes/softExame/database" data-v-e052628c><!--[--><p class="text" data-v-e052628c>数据库</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1" data-v-e052628c data-v-e052628c><!----><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-ae963f28 data-v-e459648d><div class="VPDoc has-sidebar has-aside" data-v-e459648d data-v-e29a6008><!--[--><!--]--><div class="container" data-v-e29a6008><div class="aside" data-v-e29a6008><div class="aside-curtain" data-v-e29a6008></div><div class="aside-container" data-v-e29a6008><div class="aside-content" data-v-e29a6008><div class="VPDocAside" data-v-e29a6008 data-v-b4affbcc><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-b4affbcc data-v-28de8ae3><div class="content" data-v-28de8ae3><div class="outline-marker" data-v-28de8ae3></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-28de8ae3>本页目录</div><ul class="VPDocOutlineItem root" data-v-28de8ae3 data-v-879c6a56><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-b4affbcc></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e29a6008><div class="content-container" data-v-e29a6008><!--[--><!--]--><main class="main" data-v-e29a6008><div style="position:relative;" class="vp-doc _Lyc-notes_softExame_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%82%B9" data-v-e29a6008><div><h1 id="软考软件设计师-中级-软件工程核心知识点与备考指南" tabindex="-1">软考软件设计师（中级）- 软件工程核心知识点与备考指南 <a class="header-anchor" href="#软考软件设计师-中级-软件工程核心知识点与备考指南" aria-label="Permalink to &quot;软考软件设计师（中级）- 软件工程核心知识点与备考指南&quot;">​</a></h1><blockquote><p>引言：软件工程在软件设计师考试中的重要性与备考策略软件工程作为一门旨在通过工程化方法解决软件开发和维护问题的学科，在现代软件产业中占据着核心地位。</p></blockquote><hr><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>它不仅仅是一套理论和方法的集合，更是确保软件项目能够按时、按预算、高质量完成的关键。对于有志于通过全国计算机技术与软件专业技术资格（水平）考试（简称“软考”）中级软件设计师认证的专业人士而言，深入理解和掌握软件工程的知识体系至关重要。这不仅因为软件工程是考试大纲中的重要组成部分，更因为它直接反映了作为一名合格软件设计师所应具备的分析、设计、实施和管理软件项目的综合能力。</p><p>根据最新的考试大纲分析，软件工程部分的考察内容广泛而深入，主要涵盖软件需求分析、软件设计、软件测试与维护、软件质量保证、软件过程改进以及软件开发项目管理等核心领域 1。这些知识点构成了软件开发生命周期的主要环节，从最初的用户需求捕获，到系统设计与实现，再到最终的测试交付和后期维护，无一不体现软件工程的思想和方法 1。考试不仅要求考生掌握这些基础知识，还强调对整个软件开发生命周期的理解和应用能力 。</p><p>从考试形式来看，软件工程的知识点渗透在上午的选择题和下午的案例分析题中。上午的选择题部分，根据对历年真题的分析，软件过程管理、软件质量管理、文档与软件维护、软件测试，以及面向对象技术、UML建模和设计模式等软件工程相关内容占据了显著的比例，大约有近20道题目集中在这些领域 。这部分题目更侧重于对基本概念、原理的理解和知识面的广度。例如，在数据结构方面，上午题可能考察栈的基本操作和特性，而较少涉及具体的实现问题；对于面向对象基础，则更多考察类、对象、封装、继承等基本概念 。</p><p>下午的案例分析与设计题则更侧重于知识的综合运用和实践能力。其中，结构化分析与设计（通常以数据流图DFD为核心）和面向对象分析与设计（可能涉及UML建模和设计模式的应用）往往作为必答题出现 。这要求考生不仅要理解理论，更要能够结合具体案例进行分析、建模和设计，展现解决实际问题的能力。因此，上下午考试的侧重点有所不同，上午考察知识的广度与基本概念的掌握，下午则深入考察分析与设计能力。考生在复习时，应针对不同题型调整策略，上午注重基础知识的全面覆盖，下午则加强案例分析和设计能力的训练。</p><p>备考策略方面，建议考生首先要紧扣最新的考试大纲，系统学习官方推荐教材，因为教材基本涵盖了所有上午试题的内容 1。在此基础上，理论联系实际至关重要，尤其是针对下午的案例分析题，需要通过大量的练习来提升。同时，面向对象技术、UML和设计模式不仅是上午选择题的重头戏，占据了最多的题目数量，也是下午进行面向对象分析与设计的基础，其核心地位不言而喻，考生应给予充分的重视 3。此外，尽管考试大纲版本可能存在微调（例如，提及过2009年版大纲和2013版新大纲 4），但软件工程的核心原理和实践，如需求分析、软件设计、软件测试和项目管理等，是相对稳定且共通的，这些基础知识的重要性不会轻易改变 1。历年真题是宝贵的复习资料，通过分析真题可以了解考点分布、出题风格和难度，从而更有针对性地进行复习 5。</p><h2 id="一、-软件过程模型-software-process-models" tabindex="-1">一、 软件过程模型（Software Process Models） <a class="header-anchor" href="#一、-软件过程模型-software-process-models" aria-label="Permalink to &quot;一、 软件过程模型（Software Process Models）&quot;">​</a></h2><p>软件过程模型是软件开发活动的框架，它规定了软件开发各个阶段的顺序和任务。理解不同的软件过程模型及其特点、适用场景和优缺点，对于在实际项目中选择合适的开发方法，以及应对考试中的相关题目至关重要。</p><h3 id="_1-1-瀑布模型-waterfall-model" tabindex="-1">1.1 瀑布模型 (Waterfall Model) <a class="header-anchor" href="#_1-1-瀑布模型-waterfall-model" aria-label="Permalink to &quot;1.1 瀑布模型 (Waterfall Model)&quot;">​</a></h3><ul><li><p>定义与核心思想：瀑布模型由Winston W. Royce在1970年首次提出，它将软件开发过程严格划分为一系列定义明确、顺序固定的阶段，包括需求分析、系统设计、程序编码、软件测试和运行维护 。每个阶段的完成都以文档作为输出，并作为下一阶段的输入，整个过程如同瀑布般依次跌落，不可逆转。</p></li><li><p>特点：该模型具有阶段划分固定、线性顺序执行的特点，前一阶段工作完成后才能开始下一阶段 7。它严格定义了各开发阶段的输入和输出，并高度重视过程文档的规范性，有时文档的重要性甚至超过了代码本身 7。在项目的早期阶段，用户通常无法看到实际的软件原型，只能通过文档来了解系统形态，这使得风险往往后置到项目后期才暴露 7。</p></li><li><p>优点：瀑布模型的主要优点在于其管理简单，阶段划分清晰，为项目提供了按阶段划分的检查点 7。每个阶段都有明确的目标和交付物，便于项目经理进行控制和跟踪。</p></li><li><p>缺点：瀑布模型最显著的缺点是缺乏灵活性，难以适应用户需求的变化 7。一旦进入后续阶段，对前期需求的修改将导致巨大的成本和工作量。用户介入较晚，直到项目末期才能见到开发成果，这增加了开发风险 7。此外，大量的文档工作也增加了开发人员的负担。</p></li><li><p>适用场景：瀑布模型适用于那些需求在项目初期就能被完整、准确地定义下来，并且在整个开发周期内需求变化极少或能够被严格控制的项目 7。例如，一些需求稳定的低风险项目，或者目标和环境非常熟悉的小型项目，以及采用合同式合作方式，客户需求明确且不直接参与软件实现过程的项目 7。</p></li></ul><h3 id="_1-2-迭代模型-iterative-model" tabindex="-1">1.2 迭代模型 (Iterative Model) <a class="header-anchor" href="#_1-2-迭代模型-iterative-model" aria-label="Permalink to &quot;1.2 迭代模型 (Iterative Model)&quot;">​</a></h3><p>定义与核心思想：迭代模型采用逐步求精的策略，将整个软件应用划分为多个可管理的部分或版本进行构建，每个部分都经过设计、实现和测试，然后逐步集成到系统中，最终形成完整的产品 8。 特点：该模型的核心特点是分块构建和逐步集成。在每次迭代中，都会构建一部分模块并将其集成到更大的系统中，并对结果进行测试，从而能够尽早发现和修正错误 8。它允许在迭代过程中根据反馈对设计和功能进行调整和优化。 优点：迭代模型相较于瀑布模型具有更高的灵活性，能够更好地适应需求的部分变化 8。它允许在项目早期交付部分可用功能，使得用户可以尽早体验并提供反馈，这有助于降低项目风险。同时，风险被分散到每次迭代中，而不是集中在项目后期 8。 缺点：迭代模型对项目管理的要求较高，需要合理的规划和控制迭代过程，确保每次迭代的目标和交付物清晰明确 8。如果初始的系统架构设计不当，后续的迭代可能会遇到集成困难或需要大规模重构的风险。 适用场景：迭代模型适用于需求在初始阶段能够被较好定义，但可能存在部分不确定性或需要逐步完善的项目 8。它也适合那些需要快速向市场交付核心功能以获取早期用户反馈的项目，以及可以将大型复杂系统分解为多个相对独立的迭代周期进行开发的项目。</p><p>1.3 V模型 (V-Model)</p><p>定义与核心思想：V模型可以视为瀑布模型的一种演变和扩展，它强调了软件开发过程中测试活动与开发活动的对应关系 8。V模型的左侧代表开发阶段，从需求分析、概要设计、详细设计到编码；右侧代表测试阶段，与左侧的每个开发阶段一一对应，例如单元测试对应详细设计和编码，集成测试对应概要设计，系统测试对应需求分析，而验收测试则对应更早期的用户需求或业务需求。 特点：V模型最显著的特点是其开发活动和测试活动的并行性和对应性。它强调在每个开发阶段开始之前就应该规划好相应的测试活动，例如，在进行需求分析时就应开始制定系统测试计划和验收测试计划。 优点：通过明确每个开发阶段的验证和确认活动，V模型有助于提高软件质量，确保每个阶段的输出都得到充分测试 8。其结构严谨，阶段清晰，易于管理和理解，与瀑布模型类似。 缺点：V模型本质上仍然是一种线性顺序模型，因此其灵活性相对较差，难以适应需求在开发过程中的频繁变更 8。测试活动主要在相应的开发阶段完成之后才大规模展开，如果早期阶段的需求或设计存在缺陷，可能要到较晚的测试阶段才能被发现，导致修复成本较高。 适用场景：V模型适用于那些需求定义相对明确且稳定，对软件质量、可靠性和安全性有较高要求的项目，特别是那些需要严格验证和确认过程的系统，如一些中小型项目 8。</p><p>1.4 敏捷模型 (Agile Model)</p><p>定义与核心思想：敏捷模型并非单一的特定模型，而是一系列基于敏捷宣言价值观和原则的软件开发方法的总称。它强调通过短周期的迭代（称为“冲刺”或Sprint）来快速、持续地交付有价值的软件，并积极响应变化 8。核心价值观包括个体和交互高于流程和工具，可工作的软件高于详尽的文档，客户合作高于合同谈判，响应变化高于遵循计划。 特点：敏捷模型采用迭代和增量的方式进行开发，每个迭代周期通常较短（如1-4周），旨在尽快发布软件的有效版本 8。它高度强调跨职能团队的紧密协作（包括开发人员、测试人员、产品负责人等）以及与客户的持续沟通和反馈。敏捷方法认为每个项目都是独特的，并鼓励团队根据实际情况调整实践 8。 优点：敏捷模型具有高度的灵活性，能够快速适应和响应需求的变化，这使其非常适合需求不确定或快速演进的项目 8。通过早期和持续地交付可工作的软件，用户可以及时获得产品并提供反馈，从而降低了项目风险，提高了客户满意度。同时，它通常能提高团队的开发效率和成员的积极性。 缺点：敏捷模型对团队成员的技能、经验和自律性要求较高，需要团队成员具备良好的沟通、协作和自我管理能力 8。由于强调快速交付和轻量级文档，可能会导致详细文档的缺乏，这可能给项目的后期维护和知识传递带来一定的挑战。如果需求变化过于频繁且缺乏有效管理，也可能导致项目范围的蔓延和进度的不可控。 适用场景：敏捷模型非常适用于那些需求不确定性较高、需要快速迭代和响应变化的项目，例如许多互联网产品和创新型项目 8。当项目需要快速向市场推出最小可行产品（MVP）并根据用户反馈进行持续改进时，敏捷方法也是一个理想的选择。对于用户需求不清晰且经常发生变化，但系统规模不太大且不太复杂的项目，原型化方法（其思想与敏捷有共通之处）也是适宜的 9。</p><p>1.5 螺旋模型 (Spiral Model)</p><p>定义与核心思想：螺旋模型是一种风险驱动的迭代式软件开发过程模型，它有机地结合了瀑布模型的系统化、规范化特点和原型模型的灵活性与迭代性 8。该模型将开发过程组织成一系列螺旋式的周期，每个周期都包含四个主要活动阶段：目标制定（确定本周期的目标、约束和替代方案）、风险分析与评估（识别和分析风险，选择解决方案）、开发与验证（基于所选方案进行开发和测试）、评审与计划（评审本周期成果，规划下一周期活动）。 特点：螺旋模型最核心的特点是其对风险的高度关注和管理。在每个螺旋周期开始时，都会进行详细的风险分析，并根据风险评估结果来决定后续的开发策略 8。它采用迭代的方式逐步求精，每个周期都会产生一个更完善的软件版本或原型。 优点：螺旋模型特别适合于大型、复杂且具有高不确定性和高风险的软件项目 8。通过在每个阶段都进行风险分析和原型验证，可以有效地控制和降低项目风险。它允许在开发过程中灵活地应对需求的变化和新出现的风险。 缺点：螺旋模型的管理相对复杂，对项目经理的风险管理能力和经验要求较高 8。需要有经验丰富的风险评估专家参与，否则如果风险分析不准确或不充分，可能会导致错误的决策，甚至项目失败。对于风险较低的小型项目而言，采用螺旋模型可能会显得过于繁琐和昂贵。 适用场景：螺旋模型主要适用于那些规模庞大、复杂度高、风险较大的软件项目，尤其是当需求在项目初期难以完全确定，或者项目面临较多技术不确定性时 8。例如，一些大型系统工程或需要采用新技术、新方法的探索性项目。对于超大规模的软件项目，瀑布模型通常是不适宜的，而螺旋模型则是一个更优的选择 9。</p><p>1.6 喷泉模型 (Fountain Model)</p><p>定义与核心思想：喷泉模型是一种典型的面向对象的软件过程模型，它体现了迭代和无间隙开发的思想 9。该模型认为软件开发过程中的各个阶段（如分析、设计、编码）之间并没有严格的线性顺序和明确的界限，而是可以相互重叠、多次反复，如同喷泉的水柱一样，水可以喷涌而上，也可以下落回流。 特点：喷泉模型的主要特点是其迭代性和活动的重叠性。开发活动（如需求分析、设计、编码、测试）可以在不同程度上并行进行，并且允许在后续阶段返回到早期阶段进行修改和完善。它以用户需求为驱动力，以对象作为系统构造的基本单位。 适用场景：喷泉模型特别适合于采用面向对象技术进行开发的软件项目 9。由于面向对象方法本身强调封装、继承和多态，使得系统的各个部分相对独立且易于修改和扩展，这与喷泉模型的迭代和无间隙特性相契合。</p><p>在选择软件过程模型时，项目团队必须认识到没有一种模型是普适的。瀑布模型因其简单性和严格的阶段控制，在需求极为稳定的传统项目中仍有其用武之地。然而，随着软件系统复杂性的增加和市场需求的快速变化，迭代和增量交付的思想越来越成为主流。迭代模型、敏捷模型和螺旋模型都体现了这种趋势，它们通过分阶段交付、早期用户反馈和持续风险管理来提高项目的成功率。即使是像V模型这样的阶段性模型，也可以在迭代的框架内应用，以增强其适应性。考试中经常会出现特定的项目场景，要求考生分析并选择最合适的过程模型，这不仅要求考生记忆模型的定义，更需要深刻理解各种模型背后的原理、优缺点及其适用的具体条件和制约因素 9。表1：软件过程模型对比表 模型名称核心思想主要特点优点缺点典型适用场景瀑布模型阶段化、顺序化、文档驱动线性顺序，阶段间依赖严格，文档详尽，早期无原型管理简单，阶段清晰，有检查点缺乏灵活性，难适应需求变更，风险后置，用户介入晚需求非常明确且稳定的小型项目或部分子系统 7迭代模型分块构建，逐步求精增量开发，每次迭代包含完整开发活动并进行测试，允许反馈调整灵活性较高，早期交付功能，风险分散对项目管理要求高，初始架构重要性凸显需求基本明确但可能存在不确定性，需快速交付核心功能的项目 8V模型开发与测试阶段对应测试活动与开发阶段并行规划和执行，强调验证和确认提高软件质量，结构严谨易管理仍为线性模型，灵活性差，早期错误发现晚需求明确，对质量要求高的中小型项目 8敏捷模型快速迭代，持续交付，拥抱变化，以人为本短周期冲刺，强调团队协作和客户参与，适应需求变化高度灵活，快速响应变更，持续交付价值，用户反馈及时对团队成员要求高，可能文档不足，需求频繁变更易致范围蔓延需求不确定或快速变化，需快速迭代和用户反馈的创新型项目 8螺旋模型风险驱动，迭代开发结合瀑布和原型，每个周期进行风险分析、开发验证、评审计划，逐步细化适合大型复杂高风险项目，灵活应对需求变化和风险模型复杂管理难度大，需专业风险评估，风险分析不当可能导致失败大型、复杂、高风险，需求不明确或可能发生重大变化的项目 8喷泉模型面向对象，迭代无间隙各开发阶段可重叠反复，以对象为驱动适合面向对象开发，能较好体现OO的迭代和演化特性对过程控制要求高，若缺乏有效管理易导致混乱采用面向对象方法开发的各类项目 9 二、 软件需求工程 (Software Requirements Engineering)软件需求工程是软件开发生命周期的起始阶段，其核心任务是理解并定义用户对新软件系统的期望和约束。一个成功的软件项目始于对需求的准确捕获和清晰描述，任何在需求阶段的疏忽或错误都可能导致后续开发工作的巨大浪费，甚至项目失败 10。因此，需求工程被认为是软件工程中最关键的活动之一。</p><p>2.1 需求工程概述</p><p>定义与重要性：软件需求是指从用户角度（系统外部行为）和开发者角度（内部特性）来阐述系统必须具备的功能、特性、属性以及在开发过程中必须遵循的约束 11。它是用户与开发者之间沟通的桥梁，是后续设计、编码、测试和验收的根本依据。需求分析作为软件项目的关键过程，其质量直接关系到项目的成败 10。 需求工程的子领域：需求工程作为软件工程的一个重要子领域，它系统地研究软件系统的目标、软件系统提供的服务、软件系统运行的约束条件以及软件系统所处的运行环境 11。它不仅关注新产品的开发过程，也同样适用于对已有产品的改造和升级。 需求工程的维度：德国学者Phol提出了需求工程的三个维度：内容维度、共识维度和文档化维度 11。内容维度关注对系统需求的理解程度；共识维度关注相关涉众对已知需求理解的一致性程度；文档化维度则关注将需求信息有效记录下来的程度。</p><p>2.2 需求分类软件需求可以从不同角度进行分类，以便更好地理解和管理。一种常见的分类方法是将其划分为业务需求、用户需求、系统需求（包括功能需求和非功能需求）和技术需求 11。</p><p>业务需求 (Business Requirements)：从组织的战略目标出发，描述开发软件系统的根本原因和预期实现的商业价值。它通常关注的是组织或客户面临的问题和期望达成的目标 11。 用户需求 (User Requirements)：从最终用户的角度描述他们使用系统能够完成的具体任务和目标。通常使用自然语言或简单的图表进行描述。 系统需求 (System Requirements)：是对用户需求的进一步细化和具体化，详细描述了软件系统必须提供的服务和必须满足的约束。系统需求通常分为功能需求和非功能需求：</p><p>功能需求 (Functional Requirements)：定义了系统应该做什么，即系统应具备的具体功能和行为。例如，“系统应允许用户注册账户”，“系统应能生成月度销售报告”。 非功能需求 (Non-functional Requirements)：定义了系统应该如何工作，即系统在提供功能时应具备的质量属性和约束条件。例如，性能（响应时间、吞吐量）、可靠性（平均无故障时间）、安全性（数据加密、访问控制）、易用性（界面友好性、操作便捷性）等。</p><p>技术需求 (Technical Requirements)：指明了实现系统所需遵循的具体技术规范、标准、平台或工具等。</p><p>2.3 需求过程 (Requirements Process)需求工程是一个系统化的过程，通常包括需求获取、需求分析、需求规格说明、需求验证和需求管理等主要活动。</p><p>需求获取 (Elicitation)：这是需求工程的起点，目标是识别所有相关的需求来源（如用户、客户、现有系统文档、领域专家等），并从中抽取出现有的需求，同时开发新的创新性需求 10。</p><p>困难：需求获取过程充满挑战。用户可能不清楚自己真正需要什么，或者难以准确表达；需求本身可能随着时间的推移而发生变化；用户和开发者之间可能存在沟通障碍，使用不同的术语导致误解；开发者也可能倾向于将用户需求修改以适应已有的系统或技术方案，而非完全从用户角度出发 10。 关键信息持有者 (Stakeholders)：成功获取需求的关键在于识别并与所有关键信息持有者进行有效沟通。这不仅包括直接的客户和最终用户，还可能包括组织的管理层、与该系统有交互的其他部门或系统、维护人员等 10。</p><p>需求分析 (Analysis)：在获取到初步的需求信息后，需要对其进行深入分析，以确保需求的合理性、一致性、完整性和可行性。分析过程中需要识别并解决需求之间的冲突和矛盾 10。 需求规格说明 (Specification)：将经过分析和确认的需求清晰、准确、无歧义地记录下来，形成正式的文档，即软件需求规格说明书（SRS）11。SRS是开发团队进行设计、编码和测试的主要依据，也是用户确认系统功能的重要凭证。 需求验证 (Validation)：需求验证的目的是确保SRS中描述的需求能够准确反映用户的真实意图和期望，并且是完整和一致的。常用的验证方法包括评审、原型演示、模拟等。 需求管理 (Management)：需求在软件的整个生命周期中都可能发生变化。需求管理是指建立一套机制来跟踪和控制需求的变更，评估变更带来的影响，并确保所有相关方对变更达成一致。</p><p>2.4 需求分析方法为了有效地进行需求获取和分析，发展了多种方法和技术。</p><p>原型法 (Prototyping)：原型法是通过快速构建一个可工作的系统模型（原型），来帮助用户和开发者更好地理解和澄清需求 10。用户可以通过与原型的交互，更直观地感受系统的功能和界面，从而提出更准确的反馈和修改意见。</p><p>优点：原型法能够促进用户与开发者的沟通，减少因误解导致的需求偏差；用户可以早期看到系统的雏形，有助于尽早发现问题和调整方向；对于需求不明确或易变的项目，原型法尤其有效 10。 缺点：用户可能会对原型的功能和性能产生不切实际的期望，误认为原型就是最终产品；开发者可能会为了快速构建原型而采用一些临时性的技术方案，如果这些原型代码被直接用于最终系统，可能会影响软件质量；原型主要关注用户界面和部分核心功能，可能忽略一些重要的非功能需求或复杂的业务逻辑 10。</p><p>用例技术 (Use Case Technique)：用例是从用户角度描述系统功能的一种有效方法。它通过识别系统的参与者（Actor）和参与者希望系统执行的用例（Use Case），以及它们之间的关系（如关联、包含、扩展、泛化）来捕获和组织功能需求 10。</p><p>核心元素：参与者是与系统交互的外部实体，可以是人、其他系统或设备。用例描述了参与者使用系统完成特定目标的一系列交互步骤。 优点：用例以用户为中心，使用用户易于理解的语言描述系统功能，有助于明确系统范围和边界；用例为后续的系统设计、测试用例编写以及用户手册撰写提供了良好的基础。</p><p>2.5 数据流图 (Data Flow Diagram - DFD)数据流图是结构化分析方法中的核心工具，用于对信息系统的数据流和处理过程进行建模。它以图形化的方式清晰地展现了数据在系统内部的流动路径以及经过的各个处理环节。在软件设计师考试的下午题中，DFD的绘制与分析是一个高频考点 3。</p><p>基本概念：DFD描述了数据从外部输入系统，经过一系列处理（加工）转换，最终输出到外部实体或存储到数据存储中的过程 12。它关注的是数据的逻辑流动，而不是程序的控制流程。 DFD符号：常用的DFD符号体系有Yourdon &amp; DeMarco和Gane &amp; Sarson两种，其基本构成元素含义相似 13。</p><p>外部实体 (External Entity)：通常用矩形框表示，代表系统边界之外的数据源（输入数据的来源）或数据终点（接收数据输出的目的地），如用户、其他系统、硬件设备等。 处理/加工 (Process)：通常用带圆角的矩形框或圆形表示，代表对数据进行的转换或操作。每个处理都应有明确的输入数据流和输出数据流。 数据存储 (Data Store)：通常用两条平行的横线或一个开口的矩形表示，代表系统中数据的静态存储位置，如文件、数据库表等。数据可以从数据存储中读取，也可以写入数据存储。 数据流 (Data Flow)：用带有箭头的直线表示，代表数据在外部实体、处理和数据存储之间的流动方向。数据流线上应标注数据的名称或内容。</p><p>绘制原则：绘制DFD时应遵循一些基本原则，以确保图形的清晰性、准确性和一致性 13：</p><p>清晰易懂：使用标准的符号和简洁明了的命名。 逻辑性：侧重于数据的逻辑流动和处理，而非具体的物理实现细节。 完整性：包含所有必要的数据流、处理、数据存储和外部实体。 一致性：在整个DFD体系中（包括不同层次的图）保持符号、命名和数据流的一致性。 逐步细化：采用自顶向下的分层方法，从高层概览图逐步分解到详细的子图。</p><p>分层DFD：对于复杂的系统，通常采用分层的方式绘制DFD，以控制复杂性并提供不同粒度的系统视图 13。</p><p>顶层图 (上下文图 Context Diagram)：这是DFD的最高层次，用一个单独的处理代表整个系统，描述系统与所有外部实体之间的主要数据输入和输出。 0层图 (Level 0 Diagram)：也称为系统概览图，它是顶层图的分解，将顶层图中的单一处理分解为若干个主要的子处理（或子系统），并显示它们之间的数据流以及与主要数据存储的交互。 子图 (Lower-level Diagrams)：可以对0层图中的每个处理进一步分解，形成1层图、2层图等更详细的DFD。分解的层次取决于描述系统所需的详细程度。 父图与子图的平衡原则：这是分层DFD的一个核心原则，即子图中所有输入数据流的总和必须等于其父图中对应处理的输入数据流，所有输出数据流的总和也必须等于其父图中对应处理的输出数据流。数据存储可以在子图中引入或细化，但不能凭空消失或产生与父图不一致的数据流。</p><p>逻辑DFD与物理DFD：DFD可以分为逻辑DFD和物理DFD两种类型，它们从不同层面描述系统 12。</p><p>逻辑DFD：描述系统“做什么”，即业务层面的数据流动和处理逻辑，不涉及具体的实现技术、人员或物理设备。它关注的是业务流程和数据需求。 物理DFD：描述系统“怎么做”，即系统层面的数据流动和实现方式，会考虑具体的硬件、软件、文件格式、人员操作等物理因素。它是逻辑DFD的具体化。</p><p>需求工程的质量直接决定了软件项目的方向和最终成败。因此，准确理解用户需求，并将其清晰、完整地转化为可供开发团队使用的规格说明，是软件工程师的首要任务。在结构化分析方法中，数据流图（DFD）作为核心建模工具，其绘制、分层和平衡的技巧是考生必须熟练掌握的。特别是在下午的案例分析题中，经常会考察DFD的应用 3。同时，理解需求获取过程中可能遇到的各种困难，例如用户需求表达不清、需求频繁变更、沟通障碍等 10，有助于在分析实际案例时更准确地识别问题并提出解决方案。此外，对需求的正确分类，特别是区分功能需求和非功能需求，对于指导后续的系统设计和测试策略制定具有至关重要的意义 11。表2：DFD基本符号及含义符号图形符号名称 (Yourdon &amp; DeMarco)符号名称 (Gane &amp; Sarson)含义描述矩形框外部实体 (External Entity)外部实体 (Source/Sink)代表系统外部的数据来源或数据去向，是系统与之交互的个体或组织。圆形处理/加工 (Process)处理/加工 (Process)对输入数据流进行某种操作或变换，产生输出数据流。两条平行线或开口矩形数据存储 (Data Store)数据存储 (Data Store)表示系统中用于存放数据的地方，如文件、数据库表等。带箭头的线数据流 (Data Flow)数据流 (Data Flow)表示数据在外部实体、处理和数据存储之间的流动方向，线上通常标注数据名称。表3：逻辑DFD与物理DFD对比比较维度逻辑DFD物理DFD描述对象业务流程和数据需求 (系统“做什么”)系统的具体实现方式 (系统“怎么做”)关注点数据的逻辑流动和转换，独立于技术实现数据的物理流动、存储介质、处理人员/设备、实现技术抽象级别较高较低包含元素示例业务活动、逻辑数据单元具体程序模块、物理文件、数据库表、操作员、硬件设备、通信方式时机通常在需求分析早期阶段，用于理解业务通常在概要设计或详细设计阶段，用于指导系统实现稳定性相对稳定，业务流程变化频率较低相对易变，技术选型、实现方式可能调整三、 软件设计 (Software Design)软件设计是根据需求规格说明，将软件系统的功能和性能要求转化为具体的体系结构、模块划分、接口定义和数据结构描述的过程。它是连接需求分析与软件编码的桥梁，其质量直接影响到软件产品的可维护性、可扩展性、可靠性和性能。本章将重点介绍软件设计的基础概念、核心原则、面向对象设计思想、UML建模语言以及常见的设计模式，这些都是软件设计师考试中的核心考查内容。</p><p>3.1 软件设计基础</p><p>设计过程：软件设计通常分为两个主要阶段：概要设计（也称高层设计或体系结构设计）和详细设计（也称低层设计或模块设计）。概要设计的主要任务是确定软件的总体结构，划分主要的子系统和模块，定义模块间的接口和交互关系，以及选择关键的技术方案 9。详细设计则是在概要设计的基础上，对每个模块进行具体的功能描述、算法设计和数据结构定义，为后续的编码工作提供直接指导 9。结构化开发方法中，设计过程可能包括体系结构设计、数据设计、接口设计和过程设计（包含对数据结构和算法的设计） 9。 设计原则：为了开发出高质量的软件系统，设计过程应遵循一系列基本原则，如模块化、信息隐蔽、抽象化以及追求高内聚和低耦合 9。</p><p>模块化 (Modularity)：将复杂的系统分解为若干个功能相对独立、规模适中的模块，每个模块完成一个特定的子功能。模块化有助于降低系统复杂度，提高可理解性和可维护性。 信息隐蔽 (Information Hiding) / 封装 (Encapsulation)：指将模块的内部实现细节（如数据结构、算法）对其他模块隐藏起来，只暴露有限的、定义良好的接口供外部调用。这有助于减少模块间的依赖，提高模块的独立性和可修改性。 抽象 (Abstraction)：关注事物的主要特征，忽略其次要细节。在软件设计中，通过抽象可以定义出模块的功能接口、数据类型等，而无需关心其具体实现。 高内聚、低耦合 (High Cohesion, Low Coupling)：这是衡量模块独立性的重要标准。“高内聚”指模块内部各个元素（如函数、数据）之间联系紧密，共同完成一个单一的功能。“低耦合”指模块与模块之间的依赖关系尽可能弱，一个模块的修改对其他模块的影响尽可能小。</p><p>3.2 面向对象基本概念 (Object-Oriented Concepts)面向对象（Object-Oriented, OO）是一种重要的软件开发思想和方法，它以对象作为系统构造的基本单位，通过封装、继承和多态等机制来组织和构建软件系统。掌握面向对象的基本概念是理解UML建模和设计模式的前提，也是软件设计师考试的重点内容 3。</p><p>对象 (Object) 与 类 (Class)：类是对具有相同属性（数据）和行为（方法）的一组对象的抽象描述，它是一个模板或蓝图。对象是类的具体实例，拥有类所定义的属性和行为。 封装 (Encapsulation)：封装是将对象的属性（数据）和操作这些属性的方法（函数）捆绑在一个逻辑单元（即类）中，并对对象的内部状态进行保护，只通过明确定义的公共接口（public methods）允许外部访问 14。封装的目的是实现信息隐藏，保护数据不被随意修改，提高代码的模块化程度、安全性和可维护性，同时也有助于代码重用 14。 继承 (Inheritance)：继承允许一个类（子类或派生类）获取另一个类（父类或基类）的属性和方法，并可以在此基础上进行扩展或修改，以满足自身特定的需求 14。继承主要用于表示类之间的“is-a”（是一种）关系，例如，“狗是一种动物”。它的主要目的是实现代码复用，减少冗余代码，并建立类之间的层次化结构 14。 多态 (Polymorphism)：多态的字面意思是“多种形态”，在面向对象编程中，它允许不同类的对象对同一消息（方法调用）做出不同的响应 14。即“一个接口，多种实现”。多态极大地提高了代码的灵活性、可扩展性和可复用性，是许多设计模式、设计原则和编程技巧得以实现的基础 17。</p><p>实现方式：多态通常通过继承和方法重写（子类重新定义父类中已有的虚方法）、接口实现（不同类实现相同的接口并提供各自的实现）等方式来实现。在某些动态语言中，还存在“鸭子类型（Duck Typing）”的多态形式，即“如果它走起来像鸭子，叫起来像鸭子，那么它就是鸭子”，关注对象的行为而非其类型 17。</p><p>3.3 软件设计原则除了上述基础设计原则外，面向对象设计领域还总结出了一系列更具体、更具指导性的设计原则，其中最著名的当属SOLID原则。遵循这些原则有助于构建出更健壮、更易维护、更易扩展的软件系统。</p><p>SOLID 原则 19：</p><p>单一职责原则 (SRP - Single Responsibility Principle)：一个类应该只有一个引起它变化的原因，即一个类只承担一项职责 19。这有助于控制类的粒度，提高类的内聚性，降低其复杂性。 开闭原则 (OCP - Open/Closed Principle)：软件实体（如类、模块、函数等）应该对扩展开放，对修改关闭 19。这意味着当需要增加新功能时，应该通过添加新代码（如创建新的子类或模块）来实现，而不是修改已有的、经过测试的稳定代码。 里氏替换原则 (LSP - Liskov Substitution Principle)：所有引用基类（父类）的地方必须能透明地使用其子类的对象，而不会导致程序出错或行为异常 19。简单来说，子类对象应该能够替换掉父类对象并表现出符合预期的行为。 接口隔离原则 (ISP - Interface Segregation Principle)：客户端不应该被迫依赖于它不使用的方法。一个类对另一个类的依赖应该建立在最小的接口上 19。如果一个接口过于庞大（胖接口），应该将其拆分成更小、更具体的接口。 依赖倒置原则 (DIP - Dependency Inversion Principle)：高层模块不应该依赖于低层模块，两者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象 19。这意味着我们应该面向接口编程，而不是面向实现编程。</p><p>高内聚 (High Cohesion)：内聚性衡量一个模块内部各个元素之间功能相关性的紧密程度 23。理想的设计是追求功能内聚，即模块内的所有元素都为完成一个单一、明确定义的功能而协同工作。</p><p>内聚类型 (由低到高)：偶然内聚（Coincidental）、逻辑内聚（Logical）、时间内聚（Temporal）、过程内聚（Procedural）、通信内聚（Communicational）、顺序内聚（Sequential）、功能内聚（Functional）23。</p><p>低耦合 (Low Coupling)：耦合性衡量模块与模块之间相互依赖的程度 24。理想的设计是追求松散耦合，特别是数据耦合，尽量避免紧密耦合如内容耦合。</p><p>耦合类型 (由高到低)：内容耦合（Content）、公共耦合（Common）、外部耦合（External）、控制耦合（Control）、标记耦合（Stamp）、数据耦合（Data）26。</p><p>迪米特法则 (LoD - Law of Demeter)：也称为最少知识原则，指一个对象应该对其他对象有尽可能少的了解。一个对象不应该直接调用其“朋友的朋友”的方法 21。这有助于降低类之间的耦合度。</p><p>3.4 统一建模语言 (Unified Modeling Language - UML)UML是一种标准化的、通用的可视化建模语言，用于对软件系统进行描述、规范、构造和文档化。它提供了一套丰富的图形符号和规则，帮助软件开发人员、系统分析师和项目干系人就系统的结构和行为达成共识。UML是面向对象分析与设计过程中的重要工具，也是软件设计师考试中的高频考点 3。</p><p>概述：UML并非一种方法论，而是一种语言，它可以与各种软件开发过程（如RUP、敏捷开发）结合使用。 常用UML图的用途和核心元素 28：</p><p>用例图 (Use Case Diagram)：从用户（参与者）的角度描述系统的功能需求。核心元素包括参与者（Actor，用小人表示）、用例（Use Case，用椭圆表示）以及它们之间的关系（如关联、包含《include》、扩展《extend》、泛化）。 类图 (Class Diagram)：描述系统的静态结构，显示系统中的类、接口、它们的属性和操作，以及类之间的静态关系。常见的关系包括：</p><p>关联 (Association)：表示类之间的结构联系，如“一个订单包含多个订单项”。可以是双向或单向的，可以有基数（multiplicity）。 依赖 (Dependency)：表示一个类（客户端）使用了另一个类（供应端）的服务，是一种较弱的关系，通常表现为方法参数、局部变量或静态方法调用。 泛化 (Generalization)：表示类之间的继承关系（is-a），子类继承父类的属性和方法。用带空心三角箭头的实线表示，箭头指向父类。 实现 (Realization)：表示类实现了一个或多个接口。用带空心三角箭头的虚线表示，箭头指向接口。 聚合 (Aggregation)：表示一种“整体-部分”的关联关系（has-a），其中部分可以独立于整体存在。用带空心菱形的实线表示，菱形指向整体。 组合 (Composition)：表示一种更强的“整体-部分”的关联关系，其中部分的生命周期依赖于整体，整体销毁则部分也随之销毁。用带实心菱形的实线表示，菱形指向整体。</p><p>对象图 (Object Diagram)：是类图在特定时间点的一个实例快照，显示了系统中的具体对象及其相互关系。 序列图 (Sequence Diagram)：属于交互图的一种，用于描述对象之间按时间顺序进行的消息传递和交互过程。它强调消息的时间顺序，垂直方向代表时间，水平方向代表不同的对象生命线。 协作图/通信图 (Collaboration/Communication Diagram)：也属于交互图，与序列图类似，用于描述对象间的交互关系，但它更侧重于对象之间的组织结构和连接关系，而不是严格的时间顺序。 活动图 (Activity Diagram)：用于描述系统或业务流程中的活动顺序和控制流，类似于传统的流程图。它可以表示并发活动、分支、合并等，并可以使用泳道（Swimlane）来表示不同角色或部门负责的活动。 状态图 (State Diagram / State Machine Diagram)：用于描述单个对象在其生命周期内可能经历的各种状态，以及导致状态发生变化的事件和条件，以及在状态转换时执行的动作。 构件图 (Component Diagram)：描述系统的物理模块（构件，如DLL、JAR文件、可执行文件等）及其组织和依赖关系。 部署图 (Deployment Diagram)：描述系统中的硬件（处理节点）和软件构件在这些硬件上的物理部署和分布情况。</p><p>3.5 设计模式 (Design Patterns)设计模式是在长期的软件开发实践中总结出来的，针对特定问题上下文的、可复用的、经过验证的优秀解决方案。它们不是具体的代码或算法，而是一种思想和设计的指导。熟练掌握和运用设计模式，可以显著提高软件设计的质量、可维护性和可扩展性。设计模式是软件设计师考试中的重要考点，尤其是在下午的面向对象分析与设计题目中 3。</p><p>基本概念：设计模式描述了在特定情境下，类和对象如何交互以解决一个一般性的设计问题。 设计模式六大原则：这些原则是理解和应用设计模式的基础，已在3.3节中详细介绍，包括单一职责原则、开闭原则、里氏替换原则、接口隔离原则、依赖倒置原则和迪米特法则 21。 分类：设计模式通常根据其目的和范围被分为三大类：创建型模式、结构型模式和行为型模式 21。</p><p>创建型模式 (Creational Patterns)：关注对象的创建过程，旨在将对象的创建与使用分离，提供更灵活、更可控的对象创建机制。</p><p>工厂方法模式 (Factory Method)：定义一个用于创建对象的接口，但让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类 21。 抽象工厂模式 (Abstract Factory)：提供一个接口，用于创建一系列相关或相互依赖的对象，而用户无需指定它们的具体类 21。 单例模式 (Singleton)：确保一个类只有一个实例，并提供一个全局访问点来访问该实例 21。 建造者模式 (Builder)：将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示 21。 原型模式 (Prototype)：用原型实例指定创建对象的种类，并通过拷贝这些原型来创建新的对象 21。</p><p>结构型模式 (Structural Patterns)：关注如何组合类和对象以形成更大的结构，从而获得新的功能。</p><p>适配器模式 (Adapter)：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作 21。 装饰模式 (Decorator)：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活 21。 代理模式 (Proxy)：为其他对象提供一种代理以控制对这个对象的访问 21。 外观模式 (Facade)：为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用 21。 桥接模式 (Bridge)：将抽象部分与它的实现部分分离，使它们都可以独立地变化 21。 组合模式 (Composite)：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性 21。 享元模式 (Flyweight)：运用共享技术有效地支持大量细粒度的对象，以减少系统中对象的数量，从而节省内存 21。</p><p>行为型模式 (Behavioral Patterns)：关注对象之间的交互方式和职责分配。</p><p>观察者模式 (Observer)：定义对象间的一种一对多的依赖关系，当一个对象（主题/被观察者）的状态发生改变时，所有依赖于它的对象（观察者）都得到通知并被自动更新 21。 策略模式 (Strategy)：定义一系列的算法，并将每一个算法封装起来，使它们可以相互替换。策略模式使得算法可独立于使用它的客户而变化 21。 模板方法模式 (Template Method)：在一个方法中定义一个算法的骨架（模板），而将一些步骤延迟到子类中去实现。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤 21。 责任链模式 (Chain of Responsibility)：为解除请求的发送者和接收者之间的耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止 21。 命令模式 (Command)：将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作 21。 迭代器模式 (Iterator)：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示 21。 中介者模式 (Mediator)：用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互 21。 备忘录模式 (Memento)：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态 21。 状态模式 (State)：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类 21。 访问者模式 (Visitor)：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作 21。 解释器模式 (Interpreter)：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子 21。</p><p>常考设计模式详解：</p><p>工厂方法模式 (Factory Method)：</p><p>定义：定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类。 UML类图：通常包含一个抽象工厂（Creator）接口，声明工厂方法；具体工厂（ConcreteCreator）实现工厂方法以创建具体产品；一个抽象产品（Product）接口；具体产品（ConcreteProduct）实现产品接口。 核心代码结构：抽象工厂定义 factoryMethod()，具体工厂实现此方法返回具体产品实例。 适用场景：当一个类不知道它所必须创建的对象的类的时候；当一个类希望由它的子类来指定它所创建的对象的时候；当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</p><p>单例模式 (Singleton)：</p><p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点 31。 UML类图：一个单例类（Singleton），包含一个私有的静态自身实例变量，一个私有的构造函数，一个公有的静态方法（如 getInstance()）用于获取唯一实例 31。 核心代码结构：私有构造函数防止外部实例化；静态方法内部判断实例是否存在，不存在则创建并保存，然后返回实例。常见的实现方式有饿汉式（类加载时即创建）和懒汉式（首次调用getInstance()时创建，需注意线程安全）32。 适用场景：当系统中只需要一个实例对象，例如全局配置管理器、日志记录器、数据库连接池等；客户调用类的单个实例只允许使用一个公共访问点 31。</p><p>观察者模式 (Observer)：</p><p>定义：定义了对象之间的一对多依赖关系，当一个对象（被观察者/主题 Subject）的状态发生改变时，所有依赖于它的对象（观察者 Observer）都将得到通知并自动更新。 UML类图：通常包含一个抽象主题（Subject）接口，定义注册、移除和通知观察者的方法；具体主题（ConcreteSubject）实现主题接口，维护观察者列表，并在状态改变时通知观察者；一个抽象观察者（Observer）接口，定义更新方法；具体观察者（ConcreteObserver）实现观察者接口，在收到通知时执行更新操作。 核心代码结构：主题维护一个观察者列表，提供添加/删除观察者的方法，并在自身状态变化时遍历列表调用观察者的更新方法。 适用场景：当一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时；当一个对象必须通知其他对象，而它又不能假定其他对象是谁的时候（即希望这些对象是松散耦合的）。例如GUI事件处理、消息队列等。</p><p>适配器模式 (Adapter)：</p><p>定义：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作 33。 UML类图：包含目标接口（Target），适配者类（Adaptee，拥有不兼容接口），适配器类（Adapter，实现Target接口并包装Adaptee实例或继承Adaptee）。分为类适配器（通过多重继承）和对象适配器（通过组合） 33。 核心代码结构：适配器实现目标接口的方法，在方法内部调用适配者类的方法来完成功能。 适用场景：希望使用一个已经存在的类，而它的接口不符合你的需求时；想要创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作时；（对象适配器）想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</p><p>装饰模式 (Decorator)：</p><p>定义：动态地给一个对象添加一些额外的职责。就增加功能而言，Decorator模式相比生成子类更为灵活。 UML类图：包含一个抽象构件（Component）接口，定义对象的核心功能；具体构件（ConcreteComponent）实现构件接口；一个抽象装饰者（Decorator）类，实现（或继承）构件接口，并持有一个构件对象的引用；具体装饰者（ConcreteDecorator）继承抽象装饰者，负责给构件对象添加新的职责。 核心代码结构：装饰者和被装饰对象实现相同的接口。装饰者在调用被装饰对象的核心功能前后，可以添加额外的行为。 适用场景：在不想增加很多子类的情况下扩展一个类的功能；动态地给对象添加功能，这些功能可以再动态地撤销；需要用更加灵活的方式来扩展功能时。例如Java IO流的设计。</p><p>策略模式 (Strategy)：</p><p>定义：定义一系列算法，将每一个算法封装起来，并使它们可以相互替换。策略模式让算法独立于使用它的客户而变化。 UML类图：包含一个环境类（Context），持有一个抽象策略（Strategy）接口的引用；抽象策略接口定义了所有支持的算法的公共接口；具体策略类（ConcreteStrategy）实现抽象策略接口，封装了具体的算法。 核心代码结构：环境类通过组合一个策略对象，将算法的实现委托给该策略对象。客户端可以动态地改变环境类所使用的策略。 适用场景：如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为；一个系统需要动态地在几种算法中选择一种；如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p><p>模板方法模式 (Template Method)：</p><p>定义：在一个方法中定义一个算法的骨架（模板），而将一些步骤的实现延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 UML类图：包含一个抽象类（AbstractClass），定义模板方法（templateMethod()）和若干基本操作（primitiveOperation，可以是抽象方法由子类实现，也可以是具体方法或钩子方法）；具体子类（ConcreteClass）继承抽象类并实现其抽象的基本操作。 核心代码结构：模板方法在抽象类中实现，它定义了算法的步骤顺序，并调用基本操作。子类通过实现（或重写）基本操作来定制算法的特定步骤。 适用场景：一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现；各子类中公共的行为应被提取出来并集中到一个公共父类中，以避免代码重复；需要控制子类的扩展。</p><p>面向对象的设计原则，如SOLID，是构建高质量软件的基石，它们指导开发者如何组织类和模块，以达到高内聚、低耦合的目标 21。这些原则并非孤立存在，而是设计模式得以产生的理论基础。例如，开闭原则鼓励通过扩展而非修改来应对变化，而工厂方法模式、策略模式等正是这一原则的体现。UML作为一种通用的可视化建模语言，在面向对象分析与设计中扮演着不可或缺的角色 3。类图能够清晰地展示设计模式的静态结构，而序列图等交互图则能揭示模式中对象间的动态协作关系 28。因此，考生不仅需要理解各种UML图的符号和用途，更要能够通过UML图来理解和表达设计模式。设计模式的考察往往不仅仅停留在定义的记忆层面，更重要的是理解每个模式试图解决的问题（即“模式动机” 33）以及它们在特定场景下的适用性 31。例如，在下午的面向对象分析与设计题中，可能会给出一个具体的业务场景，要求考生选择并应用合适的设计模式来优化系统设计。高内聚和低耦合作为评价软件设计质量的核心标准，贯穿于模块划分、接口设计乃至设计模式的应用等各个方面 24。开发者应时刻以实现高内聚、低耦合为目标来指导自己的设计决策。表4：SOLID设计原则总结原则名称 (英文缩写)核心思想简要解释单一职责原则 (SRP)一个类只负责一项职责就一个类而言，应该仅有一个引起它变化的原因。开闭原则 (OCP)对扩展开放，对修改关闭软件实体应该允许在不修改自身代码的情况下进行行为扩展。里氏替换原则 (LSP)子类型必须能够替换掉它们的基类型程序中任意使用基类对象的地方，都可以用其子类对象替换，且程序的行为不发生改变。接口隔离原则 (ISP)不应强迫客户端依赖于它们不使用的接口类间的依赖关系应该建立在最小的接口上，避免使用“胖接口”。依赖倒置原则 (DIP)高层模块不应依赖低层模块，都应依赖抽象；抽象不应依赖细节要面向接口编程，而不是面向实现编程。模块间的依赖通过抽象（接口或抽象类）发生。表5：常见UML图及其用途UML图名称主要用途核心元素用例图 (Use Case)从用户角度描述系统的功能需求参与者 (Actor), 用例 (Use Case), 关系 (关联, 包含, 扩展, 泛化)类图 (Class)描述系统的静态结构，类、接口及其关系类 (Class), 接口 (Interface), 属性 (Attribute), 操作 (Operation), 关系 (关联, 依赖, 泛化, 实现, 聚合, 组合)对象图 (Object)展示类图在某一特定时刻的实例快照对象 (Object), 链 (Link)序列图 (Sequence)强调对象间消息传递的时间顺序对象生命线 (Lifeline), 消息 (Message), 激活 (Activation)活动图 (Activity)描述系统或业务流程中的活动顺序和控制流活动 (Activity), 动作 (Action), 控制流 (Control Flow), 对象流 (Object Flow), 判断 (Decision), 合并 (Merge), 分叉 (Fork),汇合 (Join), 泳道 (Swimlane)状态图 (State Machine)描述单个对象在其生命周期内的状态以及状态间的转换状态 (State), 转换 (Transition), 事件 (Event), 动作 (Action), 守卫条件 (Guard)构件图 (Component)描述系统的物理模块（构件）及其依赖关系构件 (Component), 接口 (Interface), 依赖关系 (Dependency)部署图 (Deployment)描述系统硬件和软件的物理部署节点 (Node), 制品 (Artifact), 连接 (Communication Path)表6：常考设计模式对比表模式名称所属分类核心思想/解决的问题关键角色典型应用场景工厂方法模式创建型定义创建对象的接口，由子类决定实例化哪个类；将实例化延迟到子类。Creator (抽象工厂), ConcreteCreator (具体工厂), Product (抽象产品), ConcreteProduct (具体产品)需要一个类在其子类中指定创建的对象类型时；客户端不需要知道具体产品类。单例模式创建型保证一个类只有一个实例，并提供一个全局访问点。Singleton (单例类)系统中只需要一个实例对象，如全局配置、日志对象、线程池。观察者模式行为型定义对象间一对多的依赖，当一个对象状态改变时，所有依赖者自动更新。Subject (主题), Observer (观察者), ConcreteSubject, ConcreteObserverGUI事件处理，消息通知机制，当一个对象的改变需要通知其他不确定数量的对象时。适配器模式结构型将一个类的接口转换成客户期望的另一个接口，使不兼容的类可以协同工作。Target (目标接口), Adaptee (适配者), Adapter (适配器)使用现有类但其接口不兼容；复用不相关或不可预见接口的类。装饰模式结构型动态地给一个对象添加额外的职责，比子类化更灵活地扩展功能。Component (抽象构件), ConcreteComponent (具体构件), Decorator (抽象装饰者), ConcreteDecorator (具体装饰者)需要在不修改原有类的基础上动态添加或删除功能；替代继承来扩展功能。策略模式行为型定义一系列算法，封装每个算法，并使它们可以相互替换。Context (环境类), Strategy (抽象策略), ConcreteStrategy (具体策略)系统需要在多种算法中选择一种，且算法可以独立于客户端变化；避免多重条件判断。模板方法模式行为型定义一个操作中的算法骨架，而将一些步骤延迟到子类中实现。AbstractClass (抽象类), ConcreteClass (具体类)算法的整体步骤固定，但某些具体步骤可能变化；提取子类中的公共行为到父类，避免代码重复。四、 软件测试 (Software Testing)软件测试是软件开发生命周期中不可或缺的关键环节，其根本目的是通过执行软件，在规定的条件下发现程序中的错误和缺陷，衡量软件的质量，并对其是否满足设计要求和用户期望进行评估 36。有效的测试能够显著降低软件发布后因缺陷导致的风险和成本。</p><p>4.1 软件测试基础</p><p>定义与目的：软件测试是一个为了评价一个程序或系统的属性或能力，并确定它是否达到其预期结果的过程。其核心目的在于尽可能早地、尽可能多地发现软件中存在的错误和缺陷，从而为软件质量提供保证 36。 测试原则：为了提高测试的有效性和效率，测试工作应遵循一些基本原则 38：</p><p>尽早并持续地进行测试：缺陷发现得越早，修复成本越低。测试应贯穿于整个软件开发生命周期。 程序员应避免测试自己设计的程序：开发者通常难以发现自己代码中的潜在问题，应由独立的测试人员进行测试。 测试应覆盖有效和无效的输入：不仅要验证软件在正常情况下的功能，还要测试其在异常输入或边界条件下的处理能力。 修改后应进行回归测试：在修复缺陷或进行功能变更后，需要重新运行之前的测试用例，以确保修改没有引入新的问题或导致原有功能失效。 缺陷具有集中性（Pareto原则）：通常情况下，软件中80%的缺陷集中在20%的模块中。测试应重点关注这些缺陷高发区域。 测试显示缺陷的存在，但不能证明缺陷不存在：即使经过了充分的测试，也无法保证软件中没有任何缺陷。 杀虫剂悖论：如果同样的测试用例反复执行，最终将不再能发现新的缺陷。测试用例需要定期评审和更新。</p><p>4.2 测试级别 (Testing Levels)软件测试通常按照其在软件开发生命周期中所处的阶段和测试的范围，划分为不同的级别 36。</p><p>单元测试 (Unit Testing)：也称为模块测试，是最低级别的测试活动。它针对软件中最小的可测试单元（如函数、方法、类或模块）进行正确性检验，通常与程序的其他部分隔离进行 36。单元测试的主要目的是验证这些基本单元是否按照设计要求正确工作。 集成测试 (Integration Testing)：在单元测试的基础上，将已经通过测试的模块按照设计要求组装成子系统或完整的系统，然后进行测试 36。集成测试的重点在于检查模块之间的接口是否正确，以及模块组合后能否协同工作，发现与接口、交互相关的问题。 系统测试 (System Testing)：是将经过集成测试的软件，作为计算机系统的一个部分，与系统中其他部分（如硬件、外设、支撑软件、数据等）结合起来，在真实或模拟的运行环境下进行测试 36。系统测试旨在验证整个软件系统是否满足需求规格说明书中定义的功能、性能、可靠性、安全性等所有要求。 验收测试 (Acceptance Testing)：是软件开发完成后、交付给用户之前的最后一个测试阶段。它通常由最终用户、客户或其代表在用户的实际工作环境中进行，目的是确认软件系统是否满足用户的业务需求和期望，以及是否可以接受并投入使用 36。常见的验收测试类型包括Alpha测试（在开发环境下由用户进行）和Beta测试（在用户实际环境下由用户进行）37。</p><p>4.3 测试类型 (按测试技术划分)根据测试时是否关注软件的内部结构和实现细节，可以将测试技术主要分为黑盒测试和白盒测试。</p><p>黑盒测试 (Black-box Testing)：黑盒测试也称为功能测试或数据驱动测试。测试人员不关心被测软件的内部逻辑结构和实现细节，而是将软件看作一个“黑盒子”，仅根据软件的需求规格说明书来设计测试用例，检查软件的功能是否符合预期 38。</p><p>等价类划分法 (Equivalence Partitioning)：这是一种最常用的黑盒测试用例设计方法。它将程序的输入域（或输出域）划分为若干个互不相交的子集，称为等价类。假设同一等价类中的所有输入数据对于揭露程序中的错误是等效的，因此只需从每个等价类中选取一个或少数代表性数据作为测试用例即可 38。等价类分为有效等价类（符合规格说明的合理输入）和无效等价类（不符合规格说明的非法输入）。 边界值分析法 (Boundary Value Analysis)：大量的程序错误发生在输入或输出范围的边界上。边界值分析法是对等价类划分法的补充，它着重选择等价类边界上的值以及刚刚超出边界的值作为测试用例 38。 决策表法/判定表法 (Decision Table Testing)：当软件的功能依赖于多个输入条件的组合时，使用决策表能够清晰地列出所有可能的条件组合以及每种组合下应执行的操作，从而设计出完备的测试用例 40。 因果图法 (Cause-Effect Graphing)：这是一种利用图解法分析输入条件的各种组合以及与输出结果之间的因果关系，从而设计测试用例的方法。它首先将需求转换为因果图，再从因果图导出决策表，最后根据决策表设计测试用例 38。 错误推测法 (Error Guessing)：测试人员基于以往的经验、直觉以及对被测软件的理解，推测程序中可能存在的错误类型和容易出错的环节，并据此设计测试用例 38。</p><p>白盒测试 (White-box Testing)：白盒测试也称为结构测试、逻辑驱动测试或基于代码的测试。测试人员了解并利用被测软件的内部逻辑结构和实现细节来设计测试用例，以检查程序的内部操作是否按规定执行，以及各个部分的功能是否得到充分利用 38。</p><p>逻辑覆盖 (Logical Coverage)：逻辑覆盖是白盒测试中用于衡量测试完整性的一系列标准，通过设计测试用例使得程序中不同程度的逻辑成分被覆盖到 38。常见的逻辑覆盖标准按覆盖强度从弱到强依次为：</p><p>语句覆盖 (Statement Coverage)：设计测试用例，使得程序中的每一个可执行语句至少被执行一次 44。 判定覆盖/分支覆盖 (Decision/Branch Coverage)：设计测试用例，使得程序中每一个判定语句的真分支和假分支都至少被执行一次 44。 条件覆盖 (Condition Coverage)：设计测试用例，使得程序中每一个判定语句中的每一个逻辑条件的可能取值（真或假）都至少被执行一次 44。 判定/条件覆盖 (Decision/Condition Coverage)：设计测试用例，使得程序中每一个判定语句的真假分支至少执行一次，并且判定语句中的每一个逻辑条件的真假取值也至少执行一次 44。 条件组合覆盖 (Condition Combination Coverage / Multiple Condition Coverage)：设计测试用例，使得程序中每一个判定语句中所有逻辑条件的各种可能取值组合都至少被执行一次 44。 修正条件/判定覆盖 (MC/DC - Modified Condition/Decision Coverage)：这是一种更强的覆盖标准，要求对于判定中的每个条件，都存在一组测试用例能够证明该条件独立地影响判定的最终结果 47。即当其他条件保持不变时，该条件的取值变化会导致判定结果的变化。</p><p>基本路径测试法 (Basic Path Testing)：这是一种基于程序控制流图的白盒测试技术。它首先根据程序的源代码或流程图绘制出程序的控制流图，然后计算控制流图的环路复杂度（也称圈复杂度，McCabe度量法），该复杂度给出了程序基本路径集的数量上限，也即是保证程序中每条独立路径至少被执行一次所需的最少测试用例数。最后，根据独立路径设计测试用例 38。</p><p>程序控制流图 (Control Flow Graph)：是一种有向图，图中的节点代表程序的基本代码块（一系列顺序执行的语句），边代表控制流的转向。 环路复杂度/圈复杂度 (Cyclomatic Complexity - McCabe)：计算公式有多种，常用的是 V(G)=E−N+2P，其中E是控制流图中边的数量，N是节点的数量，P是连通分量的数量（对于单个程序通常P=1）。或者 V(G) = 判定区域的数量 + 1 49。</p><p>4.4 其他测试类型除了上述按技术划分的测试类型外，还有一些从其他角度划分的测试类型：</p><p>回归测试 (Regression Testing)：当软件被修改（例如修复缺陷、增加新功能或适应新环境）后，重新执行部分或全部已通过的测试用例，以确保这些修改没有引入新的错误，也没有导致原有的正确功能产生问题 37。 性能测试 (Performance Testing)：评估软件系统在特定工作负载下的响应速度、吞吐量、稳定性和资源利用率等性能指标，以验证其是否满足性能要求 36。 安全测试 (Security Testing)：检查软件系统是否存在安全漏洞，能否抵御恶意攻击，保护数据和系统的机密性、完整性和可用性。 兼容性测试 (Compatibility Testing)：测试软件在不同的硬件平台、操作系统、浏览器或其他第三方软件环境下的运行情况。 易用性测试 (Usability Testing)：评估用户与软件交互的便捷性、舒适度和效率，关注用户体验。 冒烟测试 (Smoke Testing)：在软件构建完成后，对主要功能进行快速、基本的测试，以确认核心功能是否能够正常工作，是否值得进行更全面、更深入的测试 36。如果冒烟测试失败，通常意味着该构建版本存在严重问题，不应继续测试。</p><p>4.5 软件测试文档规范的软件测试文档是测试过程管理和质量保证的重要组成部分，主要包括测试计划、测试用例和测试报告 50。</p><p>测试计划 (Test Plan)：是指导整个测试活动的纲领性文件。它详细定义了测试的目标、范围、策略、方法、资源需求（人员、硬件、软件）、进度安排、风险评估、准入和退出标准等 50。 测试用例 (Test Case)：是为某个特定的测试目标而编制的一组测试输入、执行条件、预期结果以及评估标准。它是执行测试的具体依据，应具备可重复性、清晰性和可追溯性 50。 测试报告 (Test Report)：是对测试活动及其结果的总结和分析。它通常包括测试的执行情况（通过了多少用例、发现了多少缺陷）、缺陷的详细描述和统计分析、对软件质量的评估以及是否达到发布标准的结论和建议 50。</p><p>在白盒测试中，逻辑覆盖的各个层次是考试的常见考点，考生需要清晰理解语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖以及路径覆盖之间的覆盖强度关系及其各自的优缺点 44。例如，语句覆盖最弱，仅保证每条语句被执行，而路径覆盖最强，力图覆盖所有可能的执行路径，但后者在实践中往往因路径数量巨大而难以完全实现。基本路径测试法，特别是环路复杂度的计算（如 V(G)=E−N+2 或 V(G) = 判定区域数 + 1）和独立路径的识别，是下午案例分析题中可能涉及的计算和分析内容 38。对于黑盒测试，等价类划分、边界值分析和决策表法是设计功能测试用例的基础，其实用性强，易于在选择题和案例分析中考察其应用 40。同时，理解单元测试、集成测试、系统测试和验收测试这四个主要测试级别与软件开发各阶段的对应关系，以及它们各自的测试目标和范围，也是非常重要的 36。这种对应关系与V模型的思想一脉相承，都强调了测试活动的系统性和阶段性 8。表7：逻辑覆盖方法对比表覆盖方法名称定义覆盖强度 (递增)优点缺点语句覆盖每个可执行语句至少执行一次。最弱简单直观，易于度量。无法发现逻辑判断错误、分支错误。判定覆盖 (分支覆盖)每个判定的真假分支至少执行一次。弱比语句覆盖强，能发现部分分支错误。无法保证判定内部每个条件的取值都被测试到。条件覆盖每个判定中的每个条件的真假取值至少执行一次。中等能发现条件内部的错误。不一定能覆盖所有判定分支。判定/条件覆盖同时满足判定覆盖和条件覆盖。中强结合了判定覆盖和条件覆盖的优点。未考虑条件之间的组合情况。条件组合覆盖每个判定中所有条件取值的可能组合至少执行一次。强能更全面地测试条件的组合逻辑。测试用例数量可能非常多，特别是条件较多时。修正条件/判定覆盖(MC/DC)每个条件独立影响判定结果。较强在条件组合覆盖和判定/条件覆盖之间取得平衡，用例数适中。设计测试用例相对复杂。路径覆盖程序中所有可能的执行路径至少执行一次。最强理论上最彻底的覆盖。实际中路径数量可能非常庞大，难以完全覆盖，尤其是有循环时。表8：黑盒测试技术对比表技术名称核心思想适用场景主要步骤/关注点等价类划分法将输入域划分为有效和无效等价类，从每个类中选取代表性数据。输入数据量较大，无法进行穷举测试的情况。划分等价类（有效、无效），设计测试用例覆盖所有等价类。边界值分析法重点测试输入/输出范围的边界条件及其附近的值。作为等价类划分的补充，适用于有明确取值范围的输入。确定边界点（上点、内点、离点），设计测试用例覆盖这些边界值。决策表法分析和表达多个逻辑条件组合与对应操作之间的关系。适用于具有复杂逻辑条件组合的功能。识别条件和动作，构建决策表，化简决策表，根据规则设计测试用例。因果图法分析输入条件的组合以及与输出结果之间的因果关系，并转换为决策表。适用于输入条件之间存在约束或组合关系，且输出依赖于这些组合的情况。找出原因和结果，画出因果图，在图上标明约束，将因果图转换为决策表，再设计测试用例。错误推测法基于经验和直觉推测程序中可能存在的错误和容易出错的环节。作为其他测试方法的补充，用于发现一些特殊或遗漏的错误。列出可能的错误类型和易错场景，针对性设计测试用例。五、 软件维护 (Software Maintenance)软件维护是指在软件产品成功交付并投入运行之后，为了纠正错误、适应环境变化、改进性能或增加新功能而对软件进行的修改活动 52。与普遍认知不同的是，软件维护并不仅仅局限于错误修正，研究表明，大约80%的软件维护工作是用在非纠正性的行动上，如功能增强和适应性修改 53。</p><p>5.1 软件维护定义与重要性</p><p>定义：软件维护是在软件交付使用之后，为了改正错误、或满足新的需要（如功能增强、性能提升、适应新环境）而修改软件的过程 52。它是软件生命周期中历时最长、成本最高的阶段，其工作量甚至可能超过软件开发阶段的总和。 重要性：随着软件系统在各行各业的广泛应用和长期服役，有效的软件维护对于保障业务连续性、提升用户满意度、延长软件生命周期以及实现软件资产的持续增值至关重要。</p><p>5.2 软件维护的类型根据维护活动的目的和性质，软件维护通常可以分为以下四种类型 52：</p><p>纠错性维护 (Corrective Maintenance)：这是最常见的维护类型，其目的是诊断和修复在软件运行过程中发现的错误或缺陷，确保软件能够按照规格说明书的要求正确运行。 适应性维护 (Adaptive Maintenance)：当软件的外部运行环境发生变化时（例如操作系统升级、硬件平台更换、依赖的第三方库更新、相关的法律法规或业务规则调整等），需要对软件进行修改以适应这些新的环境，这种维护称为适应性维护。 完善性维护 (Perfective Maintenance)：在软件使用过程中，用户可能会提出新的功能需求，或者要求改进现有功能的性能、易用性或效率。为了满足这些新的或变更的需求而对软件进行的修改和增强，属于完善性维护。这类维护活动通常会扩展软件的功能或提升其质量。 预防性维护 (Preventive Maintenance)：这类维护活动并非直接响应错误报告或用户需求，而是为了提高软件未来的可维护性、可靠性或为未来的改进创造更好的条件而主动进行的修改。例如，代码重构以改善程序结构、更新文档、优化算法以提升潜在性能等，都属于预防性维护。</p><p>5.3 软件可维护性 (Software Maintainability)</p><p>定义：软件可维护性是指维护人员对该软件进行理解、诊断错误、进行修改和改进的难易程度 52。它是衡量软件质量的一个重要属性。 影响因素：影响软件可维护性的因素众多，主要包括：</p><p>可理解性 (Understandability)：软件的结构、逻辑和功能是否清晰易懂。 可测试性 (Testability)：软件是否易于进行测试以验证修改的正确性。 可修改性 (Modifiability)：修改软件某一部分时，对其他部分的影响程度，以及修改的难易程度。 可移植性 (Portability)：软件从一个运行环境迁移到另一个运行环境的难易程度。 文档质量 (Documentation Quality)：需求文档、设计文档、用户手册等是否完整、准确、清晰。 代码规范性与风格 (Coding Standards and Style)：代码是否遵循统一的编码规范，是否具有良好的可读性。 模块化程度与耦合度 (Modularity and Coupling)：系统是否良好模块化，模块间耦合是否松散。</p><p>软件维护的四种类型——纠错性、适应性、完善性和预防性——是考试中常见的辨析点。考生需要能够根据具体的维护活动场景，准确判断其所属的维护类型 52。更深层次地，提高软件的可维护性并非仅是维护阶段的任务，而是贯穿于整个软件开发生命周期的目标。良好的需求分析、清晰的设计（遵循模块化、信息隐蔽、高内聚低耦合等原则）、规范的编码以及完备的文档，都是在开发阶段为后续的维护工作打下坚实基础的关键举措 52。这体现了软件工程各个阶段之间的紧密关联性：前期的质量投入能够显著降低后期的维护成本。六、 软件质量管理 (Software Quality Management)软件质量管理是指为了确保软件产品满足既定的质量标准和用户需求而进行的一系列管理活动和技术手段。它贯穿于软件生命周期的各个阶段，旨在预防缺陷的产生、发现并修复已存在的缺陷，并持续改进软件过程和产品质量。</p><p>6.1 软件质量与质量模型</p><p>软件质量定义：软件质量通常被定义为软件产品满足明确或隐含的用户需求的程度，以及其符合既定规格说明的程度。它是一个多维度的概念，涉及软件的多个方面。 ISO/IEC 9126 质量模型 (后被 ISO/IEC 25010 取代)：为了对软件质量进行更具体和可度量的评估，国际标准化组织（ISO）提出了软件质量模型。其中，ISO/IEC 9126 是一个广泛应用的经典模型，它将软件质量划分为六大特性，每个特性又包含若干子特性 37。</p><p>六大质量特性 (Characteristics) 55：</p><p>功能性 (Functionality)：指软件所实现的功能满足用户明确和隐含需求的程度。子特性包括：适合性（Suitability）、准确性（Accuracy）、互操作性（Interoperability）、保密安全性（Security）、功能性的依从性（Functionality compliance）。 可靠性 (Reliability)：指软件在规定条件下，在规定时间内保持其性能水平的能力。子特性包括：成熟性（Maturity）、容错性（Fault tolerance）、可恢复性（Recoverability）、可靠性的依从性（Reliability compliance）。 易用性 (Usability)：指用户理解、学习、使用以及在美感上喜欢该软件的程度。子特性包括：易理解性（Understandability）、易学性（Learnability）、可操作性（Operability）、吸引性（Attractiveness）、易用性的依从性（Usability compliance）。 效率 (Efficiency)：指在规定条件下，软件的性能水平与所使用资源数量之间的关系。子特性包括：时间特性（Time behavior，如响应时间、处理速度）、资源利用性（Resource utilization，如内存、CPU占用）、效率的依从性（Efficiency compliance）。 可维护性 (Maintainability)：指软件被修改（包括纠错、改进或适应环境变化）的难易程度。子特性包括：易分析性（Analyzability）、易改变性（Changeability）、稳定性（Stability）、易测试性（Testability）、可维护性的依从性（Maintainability compliance）。 可移植性 (Portability)：指软件从一种运行环境转移到另一种运行环境的能力。子特性包括：适应性（Adaptability）、易部署性（Installability）、共存性（Coexistence）、易替换性（Replaceability）、可移植性的依从性（Portability compliance）。</p><p>6.2 软件质量保证 (SQA - Software Quality Assurance)</p><p>基本概念：软件质量保证是一系列有计划、有系统的活动，旨在确保软件产品和开发过程符合预先定义的标准、规程和最佳实践，从而使最终产品能够满足用户的质量期望 1。SQA更侧重于过程的监控和改进，以预防缺陷的产生。 SQA活动范围：SQA活动覆盖软件开发的整个生命周期，从最初的需求定义、软件设计、编码实现，到版本控制、代码审查、软件配置管理、软件测试、发布管理以及最终的产品集成等各个环节 54。 SQA主要内容：SQA的实施通常围绕以下几个核心方面展开 54：</p><p>目标 (Goals)：明确软件质量需要达到的具体目标和标准。 承诺 (Commitment)：组织和管理层对实现质量目标的承诺和资源投入。 能力 (Abilities)：确保组织具备实施SQA活动所需的人员技能、工具和过程能力。 活动 (Activities)：执行具体的质量保证活动，如制定和执行质量计划、进行过程审计、评审工作产品、跟踪缺陷等。 测量 (Measurement)：建立和使用合适的度量指标来监控软件过程和产品的质量，评估SQA活动的有效性。 验证 (Verification)：通过评审、检查、测试等手段，验证软件产品在各个开发阶段是否符合规定的要求。</p><p>6.3 能力成熟度模型集成 (CMMI - Capability Maturity Model Integration)</p><p>概述：CMMI是由美国卡内基梅隆大学软件工程研究所（SEI）开发的一套用于评估和改进组织过程能力和成熟度的模型框架 54。它为组织提供了一个从混乱无序到持续优化过程的演进路径。 两种表示方法：CMMI模型主要有两种表示方法：阶段式（Staged）和连续式（Continuous）56。阶段式表示法将组织的过程改进划分为若干个成熟度级别，组织需要达到某个级别所要求的所有过程域的目标才能获得该级别的认证。连续式表示法则允许组织根据自身的业务需求和优先级，选择特定的过程域进行改进，并评估其在这些过程域上的能力级别。 阶段式成熟度等级 (Maturity Levels)：在阶段式表示法中，CMMI定义了五个成熟度级别 56：</p><p>初始级 (Initial) - ML1：过程通常是混乱的、无序的，项目成功往往依赖于个别英雄人物的努力，结果难以预测。 已管理级 (Managed) - ML2：项目层面的过程得到管理和控制。组织能够对项目进行计划、跟踪和监控，确保项目按照既定计划执行。此级别的关键过程域（KPAs）通常包括：需求管理（REQM）、项目策划（PP）、项目监控与控制（PMC）、供方协议管理（SAM）、度量与分析（MA）、过程与产品质量保证（PPQA）、配置管理（CM）56。 已定义级 (Defined) - ML3：组织层面的标准过程得到定义、文档化和制度化，并在各个项目中推广使用。组织能够根据标准过程裁剪形成适合特定项目的过程。此级别的关键过程域通常包括：需求开发（RD）、技术解决方案（TS）、产品集成（PI）、验证（VER）、确认（VAL）、组织过程焦点（OPF）、组织过程定义（OPD）、组织培训（OT）、集成项目管理（IPM，包含风险管理）、风险管理（RSKM）、决策分析与解决（DAR）56。 量化管理级 (Quantitatively Managed) - ML4：组织和项目使用统计和其他量化技术来理解和控制过程性能。过程性能目标被建立，并根据实际数据进行监控和管理。此级别的关键过程域通常包括：组织过程性能（OPP）、量化项目管理（QPM）56。 优化级 (Optimizing) - ML5：组织能够基于对过程性能的量化理解，持续地进行过程改进和创新，以应对不断变化的业务目标。此级别的关键过程域通常包括：组织绩效管理（OPM）、因果分析与解决（CAR）56。</p><p>过程域 (Process Areas)：过程域是CMMI模型的基本构造块，每个过程域都定义了一组相关的实践，当这些实践被有效实施时，可以实现该过程域所设定的一组目标 56。</p><p>6.4 软件过程改进 (SPI - Software Process Improvement)</p><p>概念：软件过程改进是指组织为了提高其软件开发和维护过程的效率、质量和可预测性而进行的一系列有计划的活动 1。SPI通常基于对现有过程的评估和分析，识别改进机会，并引入新的技术、方法或工具来优化过程。CMMI等模型为SPI提供了重要的指导框架。</p><p>ISO 9126（及其后续版本ISO/IEC 25010）提出的六大质量特性及其子特性是软件质量领域的基础知识，也是考试中常见的考点，考生需要准确记忆和理解每个特性的含义 55。例如，在分析一个软件系统的质量问题时，可能需要判断该问题主要影响了功能性、可靠性还是易用性等。CMMI模型，特别是其成熟度等级（尤其是2级和3级）以及这些等级所对应的关键过程域，是衡量组织软件过程能力的重要标准，也是考试的重点内容 56。考生应理解每个成熟度等级的核心特征，并能识别出达到该等级所必须实施的关键过程活动。软件质量保证（SQA）并非一个孤立的阶段或活动，而是贯穿于整个软件开发生命周期的系统性工作，它与软件测试、配置管理、项目管理等多个方面紧密相连，共同为软件质量保驾护航 54。表9：ISO/IEC 9126 软件质量特性及子特性主要质量特性子特性功能性 (Functionality)适合性 (Suitability), 准确性 (Accuracy), 互操作性 (Interoperability), 保密安全性 (Security), 功能性的依从性 (Functionality compliance)可靠性 (Reliability)成熟性 (Maturity), 容错性 (Fault tolerance), 可恢复性 (Recoverability), 可靠性的依从性 (Reliability compliance)易用性 (Usability)易理解性 (Understandability), 易学性 (Learnability), 可操作性 (Operability), 吸引性 (Attractiveness), 易用性的依从性 (Usability compliance)效率 (Efficiency)时间特性 (Time behavior), 资源利用性 (Resource utilization), 效率的依从性 (Efficiency compliance)可维护性 (Maintainability)易分析性 (Analyzability), 易改变性 (Changeability), 稳定性 (Stability), 易测试性 (Testability), 可维护性的依从性 (Maintainability compliance)可移植性 (Portability)适应性 (Adaptability), 易部署性 (Installability), 共存性 (Coexistence), 易替换性 (Replaceability), 可移植性的依从性 (Portability compliance)表10：CMMI 成熟度等级与关键过程域 (ML2, ML3 示例)成熟度等级等级特征关键过程域 (KPA) - 示例ML2: 已管理级 (Managed)项目级过程得到管理和控制，能够重复已有的成功。需求管理 (REQM), 项目策划 (PP), 项目监控与控制 (PMC), 供方协议管理 (SAM), 度量与分析 (MA), 过程与产品质量保证 (PPQA), 配置管理 (CM)ML3: 已定义级 (Defined)组织级标准过程得到定义、文档化和制度化，并在项目中应用和裁剪。需求开发 (RD), 技术解决方案 (TS), 产品集成 (PI), 验证 (VER), 确认 (VAL), 组织过程焦点 (OPF), 组织过程定义 (OPD), 组织培训 (OT), 集成项目管理 (IPM) (包含风险管理内容), 风险管理 (RSKM), 决策分析与解决 (DAR)七、 软件项目管理 (Software Project Management)软件项目管理是运用管理的知识、技能、工具和技术于项目活动，以满足项目的要求。它涉及对项目范围、时间、成本、质量、人力资源、沟通、风险和采购等方面的综合管理。对于软件设计师而言，理解项目管理的基本概念和方法，有助于更好地参与和贡献于项目成功。</p><p>7.1 软件估算 (Software Estimation)软件估算是指在项目早期对开发软件所需的成本、工作量、时间和资源进行预测。准确的估算是项目计划和控制的基础。</p><p>代码行估算法 (LOC - Lines of Code)：这是一种早期的、基于代码行数的估算方法。通过预测软件最终的代码行数，并结合历史项目的生产率数据（如每人月可编写的代码行数）来估算工作量和成本。其主要缺点是代码行数难以在项目早期准确预测，且不同编程语言、不同开发者风格都会导致代码行数的巨大差异。 功能点分析法 (FPA - Function Point Analysis)：功能点分析法是一种从用户角度度量软件功能规模的方法，它不依赖于具体的编程语言或技术实现 58。</p><p>基本思想：通过识别和量化软件提供给用户的功能（如输入、输出、查询、文件等）来确定其规模。 IFPUG 方法步骤 58：</p><p>识别功能类型：主要包括五种类型：内部逻辑文件（ILF，用户可识别的、系统内部维护的逻辑相关数据组）、外部接口文件（EIF，用户可识别的、由其他系统维护并被本系统引用的逻辑相关数据组）、外部输入（EI，处理来自系统外部的数据或控制信息，并维护一个或多个ILF）、外部输出（EO，向系统外部发送经过处理的数据或控制信息）、外部查询（EQ，一种特殊的外部输出，其主要目的是通过检索ILF或EIF中的数据向用户提供信息，且不改变任何ILF）。 确定功能复杂度：根据每种功能类型所涉及的数据元素类型（DETs）和记录元素类型（RETs）或文件类型引用（FTRs）的数量，将其复杂度划分为低、中、高三个等级。 计算未调整功能点 (UFP)：将每种功能类型中不同复杂度的功能数量乘以相应的权重因子（IFPUG有标准权重表），然后将所有结果相加得到UFP。 评估14个一般系统特性 (GSC) / 调整因子：这14个特性（如数据通信、分布式处理、性能、可重用性、安装简易性等）从0到5进行评分，反映了系统对这些特性的依赖程度或其复杂性。 计算技术复杂度因子 (TCF)：TCF = 0.65 + (0.01 * DI)，其中DI是14个GSC的总评分。 计算调整后的功能点 (AFP)：AFP = UFP * TCF。AFP可以作为软件规模的度量，用于后续的成本和工作量估算。</p><p>COCOMO 模型 (Constructive Cost Model)：COCOMO是由Barry Boehm提出的一系列算法型成本估算模型，用于预测软件开发的工作量、成本和进度 59。</p><p>COCOMO 81：早期版本，包含基本型、中间型和详细型三个层次，主要适用于传统的瀑布式开发项目 59。 COCOMO II：是COCOMO 81的更新版本，旨在适应现代软件开发实践，如面向对象、组件化、迭代开发等 59。它包含三个不同的子模型，分别用于项目生命周期的不同阶段：</p><p>应用组装模型 (Application Composition Model)：适用于项目最早期的原型开发阶段，特别是当软件主要通过组装现有构件（如GUI构建器、脚本语言）来快速构建时。该模型使用“对象点”（Object Points）或后来的“应用点”（Application Points）作为规模度量，而不是代码行或功能点。估算基于屏幕数、报告数和3GL构件数及其复杂度，并考虑开发者的经验和开发环境的能力（生产率PROD）59。 早期设计模型 (Early Design Model)：适用于项目的早期设计阶段，当对系统体系结构的可选方案进行探索或进行增量开发策略规划时。该模型通常使用功能点（Function Points）作为规模输入（需转换为等效的SLOC），并考虑了7个成本驱动因子（如产品复杂性、人员能力、平台经验等）来调整估算结果 59。 后架构模型 (Post-Architecture Model)：适用于项目已经确定了生命周期体系结构，准备进行实际开发和维护的阶段。这是COCOMO II中最详细的模型，通常使用源代码行（SLOC，可以从功能点转换得到）作为规模度量。它采用了17个成本驱动因子（工作量乘数EMi）和5个项目尺度因子（SFj）来精确调整工作量估算。其基本工作量估算公式为：PM=A×(KSLOC)E×∏(EMi​)，其中PM是工作量（人月），A是常数，KSLOC是以千为单位的源代码行数，E是由5个尺度因子计算得到的指数（E=B+0.01×∑SFj​，B为常数），EMi​是17个成本驱动因子的乘积 59。 规模驱动因子 (Scale Factors - SF)：这5个因子（先例性PREC、开发灵活性FLEX、体系结构/风险化解RESL、团队凝聚力TEAM、过程成熟度PMAT）共同决定了指数E的值，反映了项目的规模经济性或不经济性 59。 成本驱动因子 (Cost Drivers - EM)：这17个因子分为产品属性（如要求的可靠性RELY、数据库规模DATA、产品复杂性CPLX）、硬件属性（如执行时间约束TIME、主存约束STOR）、人员属性（如分析员能力ACAP、程序员能力PCAP）和项目属性（如软件工具使用TOOL、开发进度SCED）四大类，它们共同作用，调整标称的工作量估算值 59。</p><p>7.2 项目进度计划 (Project Scheduling)项目进度计划是确定项目各项活动的开始和结束时间，以及它们之间的依赖关系的过程。</p><p>工作分解结构 (WBS - Work Breakdown Structure)：WBS是将项目可交付成果和项目工作分解成更小、更易于管理的组成部分的过程。它是制定项目进度计划、进行资源分配和成本估算的基础。 甘特图 (Gantt Chart)：甘特图是一种简单直观的条形图，用于显示项目活动、活动的持续时间、开始和结束日期，以及活动间的并行和串行关系 61。它的优点是易于理解和制作，便于跟踪项目进度；缺点是难以清晰地表示复杂的活动依赖关系和关键路径。 计划评审技术/项目评估与评审技术 (PERT - Program Evaluation and Review Technique)：PERT图是一种基于事件的网络图，它使用概率时间估算（通常是三点估算法：最乐观时间、最悲观时间和最可能时间）来处理活动持续时间的不确定性 61。PERT图特别适用于研发类项目，因为这类项目的活动持续时间往往难以准确预测。 关键路径法 (CPM - Critical Path Method)：关键路径法是一种用于确定项目最短完成时间以及识别项目中关键活动（即那些如果延迟就会导致整个项目延迟的活动）的网络分析技术 9。</p><p>核心概念：活动（Activity）、事件（Event，活动的开始或结束点）、持续时间（Duration）、最早开始时间（ES）、最早完成时间（EF）、最迟开始时间（LS）、最迟完成时间（LF）、总浮动时间（Total Float，也称总时差，表示在不影响项目总工期的前提下，一个活动可以延迟的时间）、自由浮动时间（Free Float，表示在不影响其紧后活动最早开始时间的前提下，一个活动可以延迟的时间）。 关键活动：总浮动时间为零的活动。这些活动构成了项目网络图中的一条或多条关键路径。 计算方法：首先，从项目开始节点正向推导，计算每个活动的最早开始时间（ES）和最早完成时间（EF）。一个活动的最早开始时间是其所有紧前活动最早完成时间中的最大值；最早完成时间 = 最早开始时间 + 活动持续时间。然后，从项目结束节点（通常将其最迟完成时间设为整个项目的要求完成时间或正向计算得到的项目最早完成时间）反向推导，计算每个活动的最迟完成时间（LF）和最迟开始时间（LS）。一个活动的最迟完成时间是其所有紧后活动最迟开始时间中的最小值；最迟开始时间 = 最迟完成时间 - 活动持续时间。总浮动时间 = 最迟开始时间 - 最早开始时间（或 最迟完成时间 - 最早完成时间）62。</p><p>7.3 风险管理 (Risk Management)风险管理是在项目的整个生命周期中识别、分析、评估潜在风险，并制定和实施应对措施，以最大限度地减少风险的负面影响，并抓住风险可能带来的机遇的过程 63。</p><p>风险识别 (Risk Identification)：这是风险管理的第一步，旨在尽可能全面地找出项目中所有可能发生的潜在风险事件，包括技术风险、管理风险、商业风险、外部风险等。常用的识别方法有头脑风暴、德尔菲技术、检查表法、经验教训总结、SWOT分析等 63。风险既可以是威胁（负面影响），也可以是机遇（正面影响）63。 风险分析/评估 (Risk Analysis/Assessment)：在识别出风险后，需要对每个风险发生的可能性（概率）及其一旦发生可能造成的影响程度（如对项目成本、进度、质量、范围的影响）进行评估。通常采用定性分析（如风险矩阵法，将风险划分为高、中、低等级）或定量分析（如蒙特卡洛模拟、决策树分析）的方法，对风险进行优先级排序，以便集中资源处理最重要的风险 63。 风险应对 (Risk Response Planning)：针对已评估和排序的风险，制定并实施适当的应对策略。</p><p>消极风险（威胁）应对策略 63：</p><p>规避 (Avoidance)：改变项目计划，以完全消除风险或其影响。 转移 (Transfer)：将风险的后果连同应对责任转移给第三方，如购买保险、外包等。 减轻 (Mitigation)：采取措施降低风险发生的概率和/或减轻其影响的严重程度。</p><p>积极风险（机遇）应对策略 64：</p><p>开拓/利用 (Exploit)：采取措施确保机遇得以实现。 分享 (Share)：将机遇的部分或全部所有权分配给最能抓住机遇使项目受益的第三方。 增强 (Enhance)：提高机遇发生的概率和/或扩大其积极影响。</p><p>接受 (Acceptance)：对于某些风险（通常是低优先级或应对成本过高的风险），组织可能决定不采取任何主动措施，而是接受其可能发生的事实。接受可以是主动的（如设立应急储备）或被动的（不采取任何行动）63。</p><p>风险监控 (Risk Monitoring and Control)：在项目执行过程中，持续跟踪已识别的风险，监控残余风险，识别新出现的风险，评估风险应对计划的有效性，并根据需要调整风险管理策略。</p><p>7.4 配置管理 (Configuration Management - SCM)软件配置管理是一套用于在软件的整个生命周期中识别、组织、控制和跟踪软件配置项（如文档、代码、数据等）的修改的技术和规程，目的是保持软件产品的完整性、一致性和可追溯性 65。</p><p>基本概念：SCM通过建立和维护配置项的基线，并对所有变更进行系统化的控制，确保项目团队在开发过程中使用的是正确的、经过批准的版本。 配置项 (Configuration Item - CI)：是指在配置管理过程中需要单独识别和控制的软件工作产品或交付物。例如，需求规格说明书、设计文档、源代码模块、测试计划、测试用例、可执行代码、用户手册等都可以作为配置项 65。 基线 (Baseline)：基线是在软件开发生命周期的特定时间点上，对一组配置项（通常是某个阶段的完整交付物）进行正式评审和批准后形成的、相对稳定的版本。基线一旦建立，其后的任何修改都必须遵循正式的变更控制程序。常见的基线有需求基线、设计基线、代码基线、测试基线等 65。 版本控制 (Version Control)：版本控制是配置管理的核心技术之一，用于管理配置项在不同时间点的不同版本。它能够记录每次修改的内容、时间、修改人等信息，并允许回溯到之前的任何一个稳定版本 65。 变更管理/控制 (Change Management/Control)：当需要对已建立基线的配置项进行修改时，必须遵循严格的变更控制流程。这通常包括提交变更请求、评估变更影响、审批变更、实施变更、验证变更以及更新配置记录等步骤 65。 配置审计 (Configuration Audit)：配置审计是对配置管理活动和配置项本身进行检查和验证，以确保配置管理计划得到遵守，配置项的完整性和一致性得到维护，以及所有的变更都得到了正确的记录和批准 65。</p><p>软件估算方法中，COCOMO II模型因其对现代软件开发实践的适应性而备受关注，特别是其后架构模型中的成本驱动因子和尺度因子，是理解软件成本构成和影响因素的关键，可能成为考试的考点 59。功能点分析法则提供了一种独立于技术的规模度量方法，其基本步骤也需要掌握 58。在项目进度管理方面，关键路径法是核心，考生必须熟练掌握最早开始/完成时间（ES/EF）、最迟开始/完成时间（LS/LF）以及总浮动和自由浮动时间的计算方法，并能准确识别关键路径 9。下午的案例分析题中，经常会出现网络图，要求考生进行相关的计算和分析。风险管理和配置管理作为保障项目顺利进行的重要支撑活动，其基本过程、核心概念（如风险应对策略、配置项、基线、版本控制）是选择题中的常见考点 63。表11：COCOMO II 后架构模型成本驱动因子示例驱动因子分类关键驱动因子名称 (示例)简要说明对成本的影响方向 (高评级通常导致)产品属性要求的可靠性 (RELY)对软件失效可能造成的后果的容忍度，越高则成本越高。成本增加数据库规模 (DATA)测试数据库的规模与程序规模的比率，越大则成本越高。成本增加产品复杂性 (CPLX)产品涉及的控制、计算、设备依赖、用户界面等方面的复杂程度，越高则成本越高。成本增加平台属性执行时间约束 (TIME)对可用执行时间的占用百分比，约束越紧则成本越高。成本增加主存约束 (STOR)对可用主存的占用百分比，约束越紧则成本越高。成本增加人员属性分析员能力 (ACAP)分析人员的能力和经验，能力越强则成本越低。成本降低程序员能力 (PCAP)程序员的能力和经验，能力越强则成本越低。成本降低项目属性软件工具的使用 (TOOL)使用的软件开发工具的集成度和成熟度，越好则成本越低。成本降低开发进度压缩/扩展 (SCED)项目进度要求相对于标称进度的压缩或扩展程度，过度压缩会导致成本急剧增加。成本增加 (压缩时)表12：关键路径法核心术语与计算术语定义计算公式 (或确定方法)最早开始时间 (ES)一项活动能够开始的最早时间。ES = Max (所有紧前活动的EF)；对于起始活动，ES通常为0。最早完成时间 (EF)一项活动能够完成的最早时间。EF = ES + 活动持续时间最迟完成时间 (LF)为了保证项目按期完成，一项活动必须完成的最晚时间。LF = Min (所有紧后活动的LS)；对于结束活动，LF通常为项目要求完成时间或其EF。最迟开始时间 (LS)为了保证项目按期完成，一项活动必须开始的最晚时间。LS = LF - 活动持续时间总浮动时间 (TF)在不影响项目总工期的前提下，一项活动可以延迟的时间。TF = LS - ES 或 TF = LF - EF自由浮动时间 (FF)在不影响其任何紧后活动最早开始时间的前提下，一项活动可以延迟的时间。FF = Min (所有紧后活动的ES) - 本活动的EF (如果结果为负，则取0)关键活动总浮动时间为零的活动。TF = 0关键路径网络图中由一系列关键活动组成的、决定项目总工期的最长路径。连接所有关键活动的路径。八、 软件文档 (Software Documentation)软件文档是在软件开发过程中产生和使用的各种图文材料，它们记录了软件开发的需求、设计、实现、测试、维护以及项目管理等方面的相关信息。规范和完备的软件文档对于软件项目的成功至关重要。</p><p>8.1 软件文档的重要性 67</p><p>沟通与协调的工具：软件文档是项目团队成员之间、团队与用户之间以及不同开发阶段之间进行有效沟通和信息传递的重要媒介。 软件质量的保证：清晰、准确的文档有助于确保软件功能符合需求，设计合理，实现正确，从而提高软件质量。 软件维护的基础：在软件投入运行后，维护人员需要依赖文档来理解系统、定位问题、进行修改和升级。缺乏文档或文档质量低下会极大地增加维护的难度和成本。 培训和用户支持的依据：用户手册、操作指南等文档是用户学习和使用软件的重要参考，也是进行用户培训和提供技术支持的基础。 项目管理和知识积累的载体：项目计划、进度报告、风险分析等文档是项目管理的重要工具。同时，开发过程中的各类文档也是组织知识积累和经验传承的重要方式。</p><p>8.2 软件文档标准 67为了提高软件文档的质量和一致性，通常会采用一定的文档标准或规范。这些标准可能来自国际组织（如ISO）、国家标准或行业规范，也可能是企业内部制定的。标准化的文档有助于提高文档的可读性、可理解性和可维护性，方便不同人员之间的协作和信息共享。</p><p>8.3 软件开发各阶段的主要文档 68在软件开发的不同阶段，会产生不同类型的关键文档，它们记录了该阶段的主要活动和成果。</p><p>项目规划阶段：</p><p>软件开发计划 (Software Development Plan)：描述项目的总体目标、范围、进度、资源、组织结构、开发方法等。 配置管理计划 (Configuration Management Plan)：定义配置管理活动、配置项、基线、变更控制流程等。 质量保证计划 (Quality Assurance Plan)：阐述质量目标、质量保证活动、评审和审计安排等。 风险分析表和风险评估报告 (Risk Analysis Table and Risk Assessment Report)：记录已识别的风险及其分析评估结果。</p><p>需求分析阶段：</p><p>《软件需求规格说明书》 (Software Requirement Specification, SRS)：这是最重要的文档之一，详细描述了软件的功能需求、性能需求、接口需求、数据需求、质量属性以及约束条件等。它是后续设计、实现和测试的根本依据。 系统测试计划、测试大纲、测试用例 (System Test Plan, Test Outline, Test Cases)：初步规划系统测试的策略和具体用例。 需求跟踪矩阵 (Requirements Traceability Matrix)：用于跟踪需求在后续开发阶段的实现情况。</p><p>概要设计阶段：</p><p>《概要设计说明书》 (Software Preliminary Design Specification)：描述软件的总体架构、模块划分、模块间的接口和数据传递关系、关键技术选型等。 集成测试用例 (Integration Test Cases)：针对模块集成测试设计的用例。</p><p>详细设计阶段：</p><p>《详细设计说明书》（包括数据结构设计） (Software Detailed Design Specification)：对每个模块进行详细的功能描述、算法设计、数据结构定义、接口细节等，为编码提供直接指导。</p><p>软件编码与单元测试阶段：</p><p>源代码、编译的目标代码 (Source Code, Compiled Object Code)：软件的最终实现。 代码审查表 (Code Review Form)：记录代码审查的结果。 单元测试计划、单元测试报告 (Unit Test Plan, Unit Test Report)：记录单元测试的计划、执行过程和结果。 产品使用手册 (Product Manual) (初稿)。</p><p>测试阶段：</p><p>集成测试计划、集成测试报告 (Integration Test Plan, Integration Test Report)。 系统测试报告 (System Test Report)。 验收测试报告 (Acceptance Test Report)。 用户使用手册（包括安装手册） (User Manual, including Installation Manual) (最终版)。</p><p>项目配置管理阶段：</p><p>此阶段主要强调对前面各阶段产生的文档、代码等所有配置项进行持续的版本控制、变更管理和状态跟踪，确保其一致性和可追溯性。相关的记录和报告也是配置管理过程的产物。</p><p>软件文档作为软件工程实践规范性的重要体现，其内容和质量直接反映了开发过程的管理水平。在软件设计师考试中，虽然不会直接要求考生编写完整的大型文档，但对各类文档的用途、主要内容以及它们在软件生命周期不同阶段所扮演的角色，考生应有清晰的认识 3。例如，需求规格说明书（SRS）是需求分析阶段的核心产出，也是后续设计、编码和系统测试的主要依据；而概要设计说明书则为详细设计和集成测试提供了蓝图 68。理解这些关键文档之间的关联和在项目管理、质量保证中的作用，对于分析案例和回答相关选择题都非常有帮助。九、 高频考点回顾与应试技巧为了帮助考生更有效地备考软件设计师（中级）考试中的软件工程部分，本章将对前述各章节的核心知识点进行梳理，并结合考试特点给出一些应试技巧。</p><p>上午选择题高频考点总结：</p><p>软件过程模型：各种主流模型（瀑布、迭代、V模型、敏捷、螺旋、喷泉）的定义、核心思想、特点、优缺点及适用场景的对比与选择 3。 需求工程：需求分类（业务、用户、系统、功能、非功能）、需求过程（获取、分析、规格、验证、管理）、需求分析方法（原型、用例）、数据流图（DFD）的基本符号、绘制原则、分层思想、逻辑与物理DFD的区别 3。 面向对象基础：封装、继承、多态三大特性的定义、作用和理解 3。 软件设计原则：SOLID原则（单一职责、开闭、里氏替换、接口隔离、依赖倒置）、高内聚（类型）、低耦合（类型）、迪米特法则等核心概念的理解 3。 UML建模：常用UML图（用例图、类图、序列图、活动图、状态图等）的用途、核心元素以及它们所表达的含义的识别 3。 设计模式：设计模式的分类（创建型、结构型、行为型），常见设计模式（如工厂方法、单例、观察者、适配器、装饰器、策略、模板方法等）的定义、核心作用、解决的问题及典型适用场景的识别 3。 软件测试：测试级别（单元、集成、系统、验收）、测试类型（黑盒、白盒）、黑盒测试技术（等价类划分、边界值分析、决策表、因果图）、白盒测试的逻辑覆盖标准（语句、判定、条件、判定/条件、条件组合、MC/DC覆盖）的理解和比较、基本路径测试法的概念（控制流图、环路复杂度）3。 软件维护：软件维护的定义、四种类型（纠错性、适应性、完善性、预防性）的区分 3。 软件质量管理：ISO/IEC 9126软件质量模型的六大特性及其子特性，CMMI的成熟度等级（特别是ML2、ML3）及其关键过程域（KPA）3。 软件项目管理：软件估算方法（如功能点分析法、COCOMO II模型的基本概念和适用场景）、项目进度计划工具（甘特图、PERT图）、关键路径法的基本概念（ES, EF, LS, LF, 浮动时间）、风险管理过程（识别、分析、应对）、配置管理的核心概念（配置项、基线、版本控制、变更控制）3。</p><p>下午案例分析/设计题备考重点：</p><p>数据流图 (DFD) 的绘制与分析 3：这是下午第一题的常见形式。考生务必熟练掌握DFD的基本符号、绘制规则，特别是分层DFD的绘制方法，以及父图与子图之间数据流的平衡原则。能够根据文字描述的业务场景，准确绘制出相应的DFD（通常是0层图和必要的子图），并能对给定的DFD进行分析和纠错。 面向对象分析与设计 (OOAD) 3：这是下午的另一道重要题目。通常会给出一个具体的业务场景或系统需求描述，要求考生：</p><p>根据描述识别出系统中的主要类、它们的属性和核心方法。 绘制类图来表达这些类以及它们之间的关系（如关联、继承、实现、聚合、组合等）。 能够运用面向对象的设计原则（如SOLID）和常见的设计模式（如工厂模式、单例模式、策略模式、观察者模式等）来优化系统设计，解决特定的设计问题。 有时可能还会要求绘制简单的序列图来描述关键用例的交互流程，或者绘制状态图来描述某个对象的状态变迁。</p><p>数据库设计 3：虽然本报告主要关注软件工程，但下午题中数据库设计与软件工程紧密相关。例如，从需求分析阶段识别出的数据需求，会直接影响到后续的概念结构设计（E-R图）和逻辑结构设计（关系模式）。考生应掌握数据库设计的基本步骤和方法。 算法设计与分析 3：在详细设计阶段，会涉及到具体算法的设计。下午题中可能会有专门的算法题目，或者在面向对象设计题中要求对某个关键方法的算法进行描述。</p><p>应试技巧：</p><p>仔细审题，明确考点：无论是选择题还是案例分析题，首先要仔细阅读题目要求，准确理解问题所考察的具体知识点或能力。 选择题策略：对于概念辨析题，要注意区分易混淆的概念（如不同过程模型的特点、不同逻辑覆盖的强度）。可以运用排除法，先排除明显错误的选项。对于计算题（如环路复杂度），要熟悉公式和计算步骤。 案例分析题策略：</p><p>结合场景，灵活运用：下午题的核心在于将所学的理论知识灵活应用于题目给出的具体场景中。切忌死记硬背，要能活学活用。 条理清晰，表达规范：在阐述分析和设计过程时，</p></div></div></main><footer class="VPDocFooter" data-v-e29a6008 data-v-e56c0bb0><!--[--><!--[--><!--[--><!--[--><div class="doc-comments"><!----></div><!--]--><!--]--><!--]--><!--]--><div class="edit-info" data-v-e56c0bb0><!----><div class="last-updated" data-v-e56c0bb0><p class="VPLastUpdated" data-v-e56c0bb0 data-v-6942ea57>上次更新: <time datetime="2025-05-07T15:36:19.000Z" data-v-6942ea57></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-e56c0bb0><span class="visually-hidden" id="doc-footer-aria-label" data-v-e56c0bb0>Pager</span><div class="pager" data-v-e56c0bb0><!----></div><div class="pager" data-v-e56c0bb0><a class="VPLink link pager-link next" href="/Lyc-notes/softExame/index" data-v-e56c0bb0><!--[--><span class="desc" data-v-e56c0bb0>下一篇</span><span class="title" data-v-e56c0bb0>软考-软件设计师</span><!--]--></a></div></nav></footer><!--[--><!--[--><!--[--><div style="" class="m-doc-footer" data-v-694eb995><div class="m-doc-footer-message" data-v-694eb995><img class="visitor" src="https://visitor-badge.laobi.icu/badge?page_id=LynnCen.Lyc-notes./softExame/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%82%B9" title="当前页面累计访问数" onerror="this.style.display=&#39;none&#39;" data-v-694eb995><p data-v-694eb995>如有转载或 CV 的请标注本站原文地址</p></div><p class="m-doc-footer-copyright" data-v-694eb995>Copyright © 2024-present LynnCen</p></div><!--]--><!--]--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-ae963f28 data-v-e8722afb><div class="container" data-v-e8722afb><p class="message" data-v-e8722afb>如有转载或 CV 的请标注本站原文地址</p><p class="copyright" data-v-e8722afb>Copyright © 2024-present LynnCen</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"408_2009.md\":\"Efq88DHI\",\"408_2010.md\":\"zx2NaYJQ\",\"408_2011.md\":\"DxWg8Niq\",\"408_2012.md\":\"C2tA-4rt\",\"408_2013.md\":\"B_2UKR7-\",\"408_2014.md\":\"CP9Ccu62\",\"408_2015.md\":\"Cg9-5k78\",\"408_2016.md\":\"D94P6Wpc\",\"408_2017.md\":\"Cdr7oj-M\",\"408_2018.md\":\"DX_bA3G1\",\"408_2019.md\":\"BgeW69F-\",\"ai_dify_index.md\":\"BYZ7xqf1\",\"ai_index.md\":\"DwTkm11m\",\"ai_mcp_browsertools.md\":\"DlCk7lKK\",\"ai_mcp_cursor-mcp.md\":\"DJRISUa2\",\"ai_mcp_figma.md\":\"C6eX5OGg\",\"ai_mcp_gitlab-mcp.md\":\"5jcwJcCH\",\"algorithm_dp.md\":\"Cy3J7fVx\",\"algorithm_index.md\":\"BsgQXAbe\",\"algorithm_lru.md\":\"B3QGnfjc\",\"algorithm_退避算法.md\":\"CY3emHvs\",\"architecture_base.md\":\"Gr-u5Fbh\",\"architecture_iconfont.md\":\"0RACbhFn\",\"architecture_jp架构.md\":\"J_-qPtre\",\"architecture_modern-frontend-architecture.md\":\"BEH-L_c5\",\"browser_ introduce.md\":\"9UOrvOml\",\"browser_async_await.md\":\"rc-BJwIc\",\"browser_chrome开发者工具.md\":\"B3ZILVAe\",\"browser_chrome架构.md\":\"DJAuXzvP\",\"browser_csrf攻击.md\":\"CC722Krd\",\"browser_dom树.md\":\"BTz73d4E\",\"browser_http.md\":\"BFCh-fBj\",\"browser_http1.md\":\"BD0m_Wtk\",\"browser_http2.md\":\"DONijrvA\",\"browser_http3.md\":\"DYs710MK\",\"browser_https.md\":\"Du-_mAKl\",\"browser_performance.md\":\"lNNt1aOL\",\"browser_performance中的main指标.md\":\"COK9Ukjz\",\"browser_promise.md\":\"D2bfnZcX\",\"browser_renderfirst.md\":\"C2hkGS7W\",\"browser_rendersec.md\":\"BwYgWJHv\",\"browser_settimeout如何实现.md\":\"BR6rwzt1\",\"browser_tcp协议.md\":\"CJnl4luu\",\"browser_this.md\":\"BUfOjtUw\",\"browser_xmlhttprequest.md\":\"CmoduCEU\",\"browser_任务调度.md\":\"6_VbbnQ-\",\"browser_作用域链和闭包.md\":\"Bx1HGM4b\",\"browser_分层和合成.md\":\"CvibN3L6\",\"browser_加载阶段性能.md\":\"DrxYL6Py\",\"browser_变量提升.md\":\"DbYJ9I18\",\"browser_同源策略.md\":\"CEQgKg6r\",\"browser_块级作用域.md\":\"HGwq3Wtg\",\"browser_垃圾回收.md\":\"CV8gHoiF\",\"browser_安全沙箱.md\":\"hclApTCu\",\"browser_宏任务和微任务.md\":\"BtmhvWKA\",\"browser_导航流程.md\":\"DNRrcm0G\",\"browser_栈和堆.md\":\"CSnwLnyI\",\"browser_浏览上下文组.md\":\"B_16Mt85\",\"browser_消息队列和事件循环.md\":\"Cl3ccvKV\",\"browser_渐进式网页应用pwa.md\":\"Bfvmc1Rc\",\"browser_渲染流水线.md\":\"B_GnDvhT\",\"browser_编译器和解释器.md\":\"CNSfO_bD\",\"browser_虚拟dom.md\":\"Dczv_Hn8\",\"browser_调用栈.md\":\"BQmpCuQk\",\"browser_跨站脚本攻击xss.md\":\"Dy3dHqPs\",\"browser_页面性能.md\":\"mTTgiIL4\",\"computerbasics_index.md\":\"CzbB7pAC\",\"datastructure_chapter1.md\":\"CBtte25Y\",\"datastructure_chapter1_ex.md\":\"B0nrcpDU\",\"datastructure_chapter2.md\":\"BApyOAtp\",\"datastructure_chapter2_ex.md\":\"8BOi6ikL\",\"datastructure_chapter3.md\":\"BLtBamrY\",\"datastructure_chapter4.md\":\"CAWKg8j_\",\"datastructure_chapter5.md\":\"o8Te39uy\",\"datastructure_chapter6.md\":\"CwinkDua\",\"datastructure_chapter7.md\":\"BZxKvJcS\",\"datastructure_chapter8.md\":\"P7K9w0U3\",\"datastructure_强化.md\":\"C7CZP3IY\",\"designpatterns_behavioral_chain-of-responsibility.md\":\"CP35BQEa\",\"designpatterns_behavioral_command.md\":\"B5Igha8-\",\"designpatterns_behavioral_interpreter.md\":\"CwcaFqP0\",\"designpatterns_behavioral_iterator.md\":\"BMuNX9vm\",\"designpatterns_behavioral_mediator.md\":\"BUJOSUj5\",\"designpatterns_behavioral_memento.md\":\"BZgQ4_ut\",\"designpatterns_behavioral_observer.md\":\"DY4sHnqv\",\"designpatterns_behavioral_state.md\":\"rL78i_2g\",\"designpatterns_behavioral_strategy.md\":\"DYQgceIM\",\"designpatterns_behavioral_template-method.md\":\"BOGxIyXQ\",\"designpatterns_behavioral_visitor.md\":\"ByTUOkSQ\",\"designpatterns_creational_abstract-factory.md\":\"B5Pt7Q3X\",\"designpatterns_creational_builder.md\":\"B8xeIiHE\",\"designpatterns_creational_factory-method.md\":\"DHzWZh5r\",\"designpatterns_creational_prototype.md\":\"DoXOwiPM\",\"designpatterns_creational_singleton.md\":\"CSVFF24-\",\"designpatterns_index.md\":\"PqPAYADu\",\"designpatterns_microservices_api-gateway.md\":\"HLPekP-B\",\"designpatterns_microservices_circuit-breaker.md\":\"DzrSq4E3\",\"designpatterns_microservices_cqrs.md\":\"8fDXzuNM\",\"designpatterns_microservices_event-sourcing.md\":\"DglYvIpK\",\"designpatterns_microservices_service-discovery.md\":\"Do4tH-Ht\",\"designpatterns_modern_dependency-injection.md\":\"DfT7IpOt\",\"designpatterns_modern_mvc.md\":\"BDUk41t0\",\"designpatterns_modern_mvp.md\":\"C1s1JPLQ\",\"designpatterns_modern_mvvm.md\":\"CvIbtXoH\",\"designpatterns_modern_pub-sub.md\":\"NAtVvbE6\",\"designpatterns_structural_adapter.md\":\"BwwR3sgt\",\"designpatterns_structural_bridge.md\":\"DfguoK-f\",\"designpatterns_structural_composite.md\":\"CTMC7pFf\",\"designpatterns_structural_decorator.md\":\"D5leDtI-\",\"designpatterns_structural_facade.md\":\"DcyEe1UY\",\"designpatterns_structural_flyweight.md\":\"Cbyv4sp9\",\"designpatterns_structural_proxy.md\":\"D-waVBpd\",\"designpatterns_模版方法.md\":\"a5OXjVHQ\",\"docs_hello.md\":\"DfMTU40s\",\"git_basic.md\":\"D4WY1brS\",\"git_index.md\":\"uQSUVBF0\",\"index.md\":\"BM3KP3aQ\",\"interview_2025.md\":\"6QVmqRat\",\"interview_browser.md\":\"CdAgYveh\",\"interview_coding.md\":\"DCug0VC0\",\"interview_css.md\":\"D5nChPM9\",\"interview_html.md\":\"BmgPItOt\",\"interview_js.md\":\"Dns2Jrn0\",\"interview_network.md\":\"CNJaCtrq\",\"interview_project.md\":\"B-6YqRuM\",\"interview_react.md\":\"Cc0pxpFG\",\"interview_typescript.md\":\"Cjb9NF9N\",\"interview_webpack.md\":\"BQBcfL_5\",\"java_schedu.md\":\"Bhl1RNKJ\",\"javascript_advance_browser.md\":\"D8p-M56M\",\"javascript_advance_execution.md\":\"BMdz6rZo\",\"javascript_advance_executioncontext.md\":\"DvntKl_k\",\"javascript_advance_executionstack.md\":\"HNRH_imC\",\"javascript_basic_你不知道的js.md\":\"Tz9wLSW9\",\"linux_index.md\":\"Dh6-Okox\",\"mine_about.md\":\"CNd4tKWv\",\"mine_resume.md\":\"o2qJvqkP\",\"mine_resume_fudan.md\":\"bE81_i6W\",\"mobile_pha.md\":\"DOMJml2Z\",\"nav_index.md\":\"CDhXKvQk\",\"node_packages.md\":\"CMNOKVfW\",\"os_chapter1.md\":\"vxfCC6ua\",\"os_chapter2.md\":\"BNyAxBrG\",\"os_chapter3.md\":\"CX4waOSs\",\"os_chapter4.md\":\"D-mfA8o-\",\"os_chapter5.md\":\"CCclysgY\",\"os_强化.md\":\"iRy6DNu1\",\"password_github.md\":\"eP1llEYY\",\"postgraduate_school.md\":\"ChJcz8gM\",\"posts_communicationmechanisms.md\":\"DsaKsXui\",\"posts_compareviteandwebpack.md\":\"P5y29NDt\",\"posts_dataprefetch.md\":\"BnlKRzh_\",\"posts_im多端一致性.md\":\"CKvBQm__\",\"posts_index.md\":\"BDdCcjpd\",\"posts_rendermode.md\":\"CLQiXtBV\",\"posts_rpxtovw.md\":\"BwAhK21-\",\"posts_seo.md\":\"DTL255gG\",\"posts_skelon.md\":\"NFx99rPI\",\"posts_uno-css-jp.md\":\"D6UdBoGk\",\"posts_vuetopdf.md\":\"C4YdvRIX\",\"posts_埋点.md\":\"B7JAYVeo\",\"posts_性能优化.md\":\"D4puBB-r\",\"project_aem.md\":\"jzDDr7zM\",\"project_component_ssr.md\":\"CiQcP1dD\",\"project_cross_border.md\":\"BsEAsXKY\",\"project_generate_icon.md\":\"De35Jgv-\",\"project_index.md\":\"DbBcuhD4\",\"project_lerna_monorepo.md\":\"BC2bvOUw\",\"project_linyang.md\":\"VJbdpi0G\",\"project_local_return.md\":\"S7VZGsC4\",\"project_odin_document.md\":\"DWA5EAws\",\"project_platform_ai-service.md\":\"BJ3nr1GR\",\"project_platform_video-architecture.md\":\"C3gh1cq1\",\"project_react-intl.md\":\"CTKR7Uld\",\"project_ssr_operate.md\":\"FBQalOdW\",\"project_taojp.md\":\"Clc_jqDx\",\"project_tmm_architecture.md\":\"Dxp-fR7o\",\"project_tmm_index.md\":\"DW4rz8dP\",\"project_tmm_local_search.md\":\"BUyWta46\",\"project_tmm_mention.md\":\"s2Yyy62A\",\"project_tmm_partfileupload.md\":\"mEfeGzoW\",\"project_tmm_performance_optimization.md\":\"DYj4eP2k\",\"project_tmm_rbac.md\":\"ro3AwsoT\",\"project_tmm_resources_manner.md\":\"aFKr3TwT\",\"react_core_createelement.md\":\"BrWAzNmS\",\"react_core_intro.md\":\"PzVX8TTk\",\"react_core_stream.md\":\"DkYzLFq9\",\"react_customhook_hooks.md\":\"DIB94rcs\",\"react_customhook_usesetstate.md\":\"Ch3k2Dim\",\"react_record_thinking.md\":\"Dp5mHeuv\",\"react_utils_type.md\":\"CxQjdxIs\",\"record_amap.md\":\"fuZyr3Hm\",\"record_nvm.md\":\"Drkp-qux\",\"record_tallking.md\":\"DywLciRo\",\"shell_index.md\":\"DRMNs2oi\",\"softexame_2016上半年上午.md\":\"CG563W-H\",\"softexame_2020下半年下午.md\":\"CkyFzqMs\",\"softexame_database.md\":\"BFu8nS4b\",\"softexame_index.md\":\"ZNQ3-nuf\",\"softexame_schedule.md\":\"CVQWw4BB\",\"softexame_软件工程.md\":\"CJuOdroT\",\"softexame_软件工程必备知识点.md\":\"DDrchgB8\",\"softexame_面向对象.md\":\"DI4v1uoB\",\"test.md\":\"D8Gadys7\",\"todo_2025.md\":\"CfPlwBRI\",\"todo_index.md\":\"lNVB6ycf\",\"typescript_advance.md\":\"B4YTe0Ma\",\"typescript_class.md\":\"DNKtzdRz\",\"typescript_costums.md\":\"HsEzvGFT\",\"typescript_记录.md\":\"BOmYNkdr\",\"utils_throttle.md\":\"CBlD4gQ0\",\"utils_utils.md\":\"DyEL9IrE\",\"vite_basic.md\":\"CeTvOIEm\",\"vue_advanced_animation.md\":\"CCAirK8Y\",\"vue_advanced_directive.md\":\"CM3cW_q-\",\"vue_advanced_generic.md\":\"DSXnrRaD\",\"vue_advanced_hooks.md\":\"C1I_NUYy\",\"vue_advanced_index.md\":\"DTYKUVq1\",\"vue_advanced_performance.md\":\"zOrVt8VJ\",\"vue_basic.md\":\"B8EDoSCE\",\"vue_basic_component-communication.md\":\"BA3VjYnG\",\"vue_basic_composition-api.md\":\"UrxwoSxR\",\"vue_basic_index.md\":\"B6JLN9JH\",\"vue_basic_reactivity.md\":\"CHJkAxGm\",\"vue_basic_template.md\":\"Dp2UxGAX\",\"vue_ecosystem_build.md\":\"B7lqkAt9\",\"vue_ecosystem_devtools.md\":\"JPqNYuHF\",\"vue_ecosystem_index.md\":\"DmaCyt4g\",\"vue_ecosystem_pinia.md\":\"tD9c80LX\",\"vue_ecosystem_router.md\":\"a-K8qMgn\",\"vue_ecosystem_test.md\":\"50OACDEw\",\"vue_ecosystem_ui.md\":\"GtiPQMDa\",\"vue_index.md\":\"DHZE7TWs\",\"vue_principle_compiler.md\":\"YkpP5qlc\",\"vue_principle_index.md\":\"dIy3-O9e\",\"vue_principle_reactivity.md\":\"TR4shSm8\",\"vue_schudle.md\":\"CT3pMMdv\",\"webpack_basic.md\":\"k-8s9cMh\",\"webpack_index.md\":\"DFzWsC3U\",\"webpack_optimization.md\":\"DJso-3_c\",\"webpack_performance.md\":\"BLegp2hR\",\"webpack_practice.md\":\"sX01M81P\",\"webpack_principle.md\":\"Dwe9mC9d\",\"webpack_unocss.md\":\"Cbr8IbB2\",\"webpack_埋点.md\":\"Cke4JTuR\",\"welcome.md\":\"CfJlx2-F\",\"组成原理_chapter1.md\":\"D2zbrKga\",\"组成原理_chapter2.md\":\"Chmrns_t\",\"组成原理_chapter3.md\":\"BRaPGgls\",\"组成原理_chapter4.md\":\"DKAlu954\",\"组成原理_chapter5.md\":\"BuR7RIIB\",\"组成原理_chapter6.md\":\"DY6o1ZSI\",\"组成原理_chapter7.md\":\"CEjWrRfS\",\"组成原理_强化.md\":\"6YUH_Ydx\",\"计网_chapter1.md\":\"CkoHWmBy\",\"计网_chapter2.md\":\"DY-45I1x\",\"计网_chapter3.md\":\"BNjvGaOr\",\"计网_http.md\":\"Dbm2b3bB\",\"计网_https.md\":\"DamrGgVo\",\"计网_websocket.md\":\"BfpCbI31\",\"计网_强化.md\":\"DETcnj9X\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"zh-CN\",\"dir\":\"ltr\",\"title\":\"林岑LynnCenʘᴗʘ \",\"description\":\"林岑的成长之路，包含前端常用知识、源码阅读笔记、各种奇淫技巧、日常提效工具等\",\"base\":\"/Lyc-notes/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"i18nRouting\":false,\"logo\":\"/LynnCenLogo.png\",\"nav\":[{\"text\":\"WebFront\",\"items\":[{\"text\":\"前端基础\",\"items\":[{\"text\":\"Javascript基础\",\"activeMatch\":\"Javascript/basic/\",\"link\":\"Javascript/basic/你不知道的js\"},{\"text\":\"Javascript进阶\",\"activeMatch\":\"Javascript/Advance/\",\"link\":\"Javascript/Advance/executionContext\"},{\"text\":\"Typescript\",\"activeMatch\":\"/typescript/\",\"link\":\"/typescript/记录\"}]},{\"text\":\"Framework\",\"items\":[{\"text\":\"React\",\"activeMatch\":\"/react/\",\"link\":\"react/core/intro\"},{\"text\":\"Vue\",\"activeMatch\":\"/Vue/\",\"link\":\"Vue/basic\"}]},{\"text\":\"Engineering\",\"items\":[{\"text\":\"WebPack\",\"activeMatch\":\"/webpack/\",\"link\":\"webpack/performance\"},{\"text\":\"Node\",\"activeMatch\":\"/node/\",\"link\":\"node/packages\"},{\"text\":\"Vite\",\"activeMatch\":\"/vite/\",\"link\":\"vite/basic\"},{\"text\":\"Git\",\"activeMatch\":\"/git/\",\"link\":\"git/basic\"}]},{\"text\":\"浏览器\",\"items\":[{\"text\":\"浏览器原理\",\"activeMatch\":\"/browser/\",\"link\":\"/browser/Chrome架构\"}]}]},{\"text\":\"ComputerBasics\",\"items\":[{\"text\":\"计算机组成原理\",\"items\":[{\"text\":\"计算机组成原理基础\",\"link\":\"/组成原理/chapter1\"}]},{\"text\":\"数据结构\",\"items\":[{\"text\":\"数据结构基础\",\"link\":\"/dataStructure/chapter1\"},{\"text\":\"课后习题\",\"link\":\"/dataStructure/chapter1_ex\"}]},{\"text\":\"操作系统OS\",\"items\":[{\"text\":\"操作系统基础\",\"link\":\"/os/chapter1\"}]},{\"text\":\"计算机网络\",\"items\":[{\"text\":\"计算机网络基础\",\"link\":\"/计网/chapter1\"}]},{\"text\":\"408\",\"items\":[{\"text\":\"408真题\",\"link\":\"/408/2009\"}]},{\"text\":\"设计模式\",\"link\":\"/designPatterns/index\"}]},{\"text\":\"AI\",\"items\":[{\"text\":\"MCP\",\"items\":[{\"text\":\"BrowserTools MCP\",\"link\":\"/AI/mcp/browserTools\"},{\"text\":\"Figma Dev Mode MCP\",\"link\":\"/AI/mcp/figma\"}]},{\"text\":\"Dify\",\"items\":[{\"text\":\"Dify\",\"link\":\"/AI/Dify/index\"}]}]},{\"text\":\"SoftExame\",\"items\":[{\"text\":\"软考-软件设计师\",\"link\":\"/softExame/index\"}]},{\"text\":\"Interview\",\"activeMatch\":\"/interview/\",\"link\":\"/interview/js\"}],\"sidebar\":{\"/Javascript/\":[{\"text\":\"JS引擎\",\"link\":\"Javascript/Advance/execution\"},{\"text\":\"调用堆栈\",\"items\":[{\"text\":\"执行上下文和执行栈\",\"link\":\"Javascript/Advance/executionContext\"},{\"text\":\"执行上下文栈和变量对象\",\"link\":\"Javascript/Advance/executionStack\"}]}],\"/Vue/\":[{\"text\":\"Vue学习规划\",\"link\":\"/Vue/schudle\"},{\"text\":\"Vue基础\",\"items\":[{\"text\":\"响应式系统\",\"link\":\"/Vue/basic/reactivity\"},{\"text\":\"模板语法与指令\",\"link\":\"/Vue/basic/template\"},{\"text\":\"组件通信\",\"link\":\"/Vue/basic/component-communication\"},{\"text\":\"Composition API\",\"link\":\"/Vue/basic/composition-api\"}]},{\"text\":\"Vue进阶\",\"items\":[{\"text\":\"hooks\",\"link\":\"/Vue/advanced/hooks\"},{\"text\":\"自定义指令\",\"link\":\"/Vue/advanced/directive\"},{\"text\":\"动画\",\"link\":\"/Vue/advanced/animation\"},{\"text\":\"性能优化\",\"link\":\"/Vue/advanced/performance\"},{\"text\":\"项目架构设计\",\"link\":\"/Vue/advanced/architecture\"}]},{\"text\":\"Vue 生态篇\",\"items\":[{\"text\":\"Vue Router\",\"link\":\"/Vue/ecosystem/router\"},{\"text\":\"Pinia状态管理\",\"link\":\"/Vue/ecosystem/pinia\"},{\"text\":\"构建工具\",\"link\":\"/Vue/ecosystem/build\"},{\"text\":\"Vue Devtools\",\"link\":\"/Vue/ecosystem/devtools\"},{\"text\":\"UI库\",\"link\":\"/Vue/ecosystem/ui\"},{\"text\":\"测试\",\"link\":\"/Vue/ecosystem/test\"}]},{\"text\":\"Vue原理\",\"items\":[{\"text\":\"深入响应式系统\",\"link\":\"/Vue/principle/reactivity\"},{\"text\":\"编译器原理\",\"link\":\"/Vue/principle/compiler\"}]}],\"/typescript/\":[{\"text\":\"TypeScript\",\"link\":\"/typescript/记录\"},{\"text\":\"TypeScript进阶\",\"link\":\"/typescript/advance\"},{\"text\":\"Class\",\"link\":\"/typescript/class\"}],\"/react/\":[{\"text\":\"React源码详解\",\"items\":[{\"text\":\"第一篇 React运行全流程\",\"link\":\"/react/core/intro\"},{\"text\":\"第二篇 JSX 是如何转换为 React.createElement\",\"link\":\"/react/core/createElement\"}]},{\"text\":\"React实践\",\"items\":[{\"text\":\"思考\",\"link\":\"/react/record/thinking\"},{\"text\":\"自定义Hooks\",\"link\":\"/react/customHook/hooks\"},{\"text\":\"React with TS\",\"link\":\"/react/utils/type\"}]}],\"/interview/\":[{\"text\":\"HTML\",\"link\":\"/interview/html\"},{\"text\":\"CSS\",\"link\":\"/interview/css\"},{\"text\":\"Javascript\",\"link\":\"/interview/js\"},{\"text\":\"React\",\"link\":\"/interview/react\"},{\"text\":\"Typescript\",\"link\":\"/interview/typescript\"},{\"text\":\"WebPack\",\"link\":\"/interview/webpack\"},{\"text\":\"浏览器\",\"link\":\"/interview/browser\"},{\"text\":\"网络\",\"link\":\"/interview/network\"},{\"text\":\"项目总结\",\"link\":\"/project/index\"},{\"text\":\"笔试题\",\"link\":\"/interview/coding\"}],\"/os/\":[{\"text\":\"操作系统基础\",\"items\":[{\"text\":\"第一章 操作系统引论\",\"link\":\"/os/chapter1\"},{\"text\":\"第二章 进程与线程\",\"link\":\"/os/chapter2\"},{\"text\":\"第三章 内存管理\",\"link\":\"/os/chapter3\"},{\"text\":\"第四章 文件管理\",\"link\":\"/os/chapter4\"},{\"text\":\"第五章 磁盘和固态硬盘\",\"link\":\"/os/chapter5\"},{\"text\":\"强化\",\"link\":\"/os/强化\"}]}],\"/408/\":[{\"text\":\"2009真题\",\"link\":\"/408/2009\"},{\"text\":\"2010真题\",\"link\":\"/408/2010\"},{\"text\":\"2011真题\",\"link\":\"/408/2011\"},{\"text\":\"2012真题\",\"link\":\"/408/2012\"},{\"text\":\"2013真题\",\"link\":\"/408/2013\"},{\"text\":\"2014真题\",\"link\":\"/408/2014\"},{\"text\":\"2015真题\",\"link\":\"/408/2015\"},{\"text\":\"2016真题\",\"link\":\"/408/2016\"},{\"text\":\"2017真题\",\"link\":\"/408/2017\"},{\"text\":\"2018真题\",\"link\":\"/408/2018\"},{\"text\":\"2019真题\",\"link\":\"/408/2019\"}],\"计网\":[{\"text\":\"强化\",\"link\":\"/计网/强化\"}],\"/dataStructure/\":[{\"text\":\"数据结构\",\"items\":[{\"text\":\"第一章 绪论\",\"link\":\"/dataStructure/chapter1\"},{\"text\":\"第二章 线性表\",\"link\":\"/dataStructure/chapter2\"},{\"text\":\"第三章 栈、队列和数组\",\"link\":\"/dataStructure/chapter3\"},{\"text\":\"第四章 串\",\"link\":\"/dataStructure/chapter4\"},{\"text\":\"第五章 树与二叉树\",\"link\":\"/dataStructure/chapter5\"},{\"text\":\"第六章 图\",\"link\":\"/dataStructure/chapter6\"},{\"text\":\"第七章 查找\",\"link\":\"/dataStructure/chapter7\"},{\"text\":\"第八章 排序\",\"link\":\"/dataStructure/chapter8\"}]},{\"text\":\"课后习题\",\"items\":[{\"text\":\"第一章 绪论\",\"link\":\"/dataStructure/chapter1_ex\"},{\"text\":\"第二章 线性表\",\"link\":\"/dataStructure/chapter2_ex\"},{\"text\":\"强化\",\"link\":\"/dataStructure/强化\"}]}],\"/组成原理/\":[{\"text\":\"计算机组成原理\",\"items\":[{\"text\":\"第一章 计算机系统概述\",\"link\":\"/组成原理/chapter1\"},{\"text\":\"第二章 数据的表示和运算\",\"link\":\"/组成原理/chapter2\"},{\"text\":\"第三章 存储系统\",\"link\":\"/组成原理/chapter3\"},{\"text\":\"第四章 指令系统\",\"link\":\"/组成原理/chapter4\"},{\"text\":\"第五章 中央处理器\",\"link\":\"/组成原理/chapter5\"},{\"text\":\"第六章 总线\",\"link\":\"/组成原理/chapter6\"},{\"text\":\"第七章 输入/输出系统\",\"link\":\"/组成原理/chapter7\"},{\"text\":\"强化\",\"link\":\"/组成原理/强化\"}]}],\"/webpack/\":[{\"text\":\"WebPack\",\"items\":[{\"text\":\"基础篇\",\"link\":\"/webpack/basic\"},{\"text\":\"实战篇\",\"link\":\"/webpack/practice\"},{\"text\":\"优化篇\",\"link\":\"/webpack/optimization\"},{\"text\":\"原理篇\",\"link\":\"/webpack/principle\"},{\"text\":\"性能优化\",\"link\":\"/webpack/performance\"}]}],\"/browser/\":[{\"text\":\"宏观视角下的浏览器\",\"items\":[{\"text\":\"Chorme架构\",\"link\":\"/browser/Chrome架构\"},{\"text\":\"TCP协议\",\"link\":\"/browser/TCP协议\"},{\"text\":\"HTTP协议\",\"link\":\"/browser/HTTP\"},{\"text\":\"导航流程\",\"link\":\"/browser/导航流程\"},{\"text\":\"渲染流程（上）\",\"link\":\"/browser/renderfirst\"},{\"text\":\"渲染流程（下）\",\"link\":\"/browser/rendersec\"}]},{\"text\":\"Javascript中的执行机制\",\"items\":[{\"text\":\"变量提升\",\"link\":\"/browser/变量提升\"},{\"text\":\"调用栈\",\"link\":\"/browser/调用栈\"},{\"text\":\"块级作用域\",\"link\":\"/browser/块级作用域\"},{\"text\":\"作用域链和闭包\",\"link\":\"/browser/作用域链和闭包\"},{\"text\":\"This\",\"link\":\"/browser/this\"}]},{\"text\":\"V8工作原理\",\"items\":[{\"text\":\"栈空间和堆空间\",\"link\":\"/browser/栈和堆\"},{\"text\":\"垃圾回收\",\"link\":\"/browser/垃圾回收\"},{\"text\":\"编译器和解释器\",\"link\":\"/browser/编译器和解释器\"}]},{\"text\":\"浏览器中的页面循环系统\",\"items\":[{\"text\":\"消息队列和事件循环\",\"link\":\"/browser/消息队列和事件循环\"},{\"text\":\"setTimeout 是如何实现的？\",\"link\":\"/browser/setTimeout如何实现\"},{\"text\":\"XMLHttpRequest 是怎么实现的？\",\"link\":\"/browser/XMLHttpRequest\"},{\"text\":\"宏任务和微任务\",\"link\":\"/browser/宏任务和微任务\"},{\"text\":\"Promise\",\"link\":\"/browser/Promise\"},{\"text\":\"async/await\",\"link\":\"/browser/async&await\"}]},{\"text\":\"浏览器中的页面\",\"items\":[{\"text\":\"Chrome开发者工具\",\"link\":\"/browser/Chrome开发者工具\"},{\"text\":\"DOM树\",\"link\":\"/browser/DOM树\"},{\"text\":\"渲染流水线\",\"link\":\"/browser/渲染流水线\"},{\"text\":\"分层和合成机制\",\"link\":\"/browser/分层和合成\"},{\"text\":\"页面性能\",\"link\":\"/browser/页面性能\"},{\"text\":\"虚拟DOM\",\"link\":\"/browser/虚拟DOM\"},{\"text\":\"渐进式网页应用PWA\",\"link\":\"/browser/渐进式网页应用PWA\"}]},{\"text\":\"浏览器中的网络\",\"items\":[{\"text\":\"HTTP1\",\"link\":\"/browser/HTTP1\"},{\"text\":\"HTTP2\",\"link\":\"/browser/HTTP2\"},{\"text\":\"HTTP3\",\"link\":\"/browser/HTTP3\"}]},{\"text\":\"浏览器安全\",\"items\":[{\"text\":\"同源策略\",\"link\":\"/browser/同源策略\"},{\"text\":\"跨站脚本攻击XSS\",\"link\":\"/browser/跨站脚本攻击XSS\"},{\"text\":\"CSRF攻击\",\"link\":\"/browser/CSRF攻击\"},{\"text\":\"安全沙箱\",\"link\":\"/browser/安全沙箱\"},{\"text\":\"HTTPS\",\"link\":\"/browser/HTTPS\"}]},{\"text\":\"浏览上下文组\",\"link\":\"/browser/浏览上下文组\"},{\"text\":\"任务调度\",\"link\":\"/browser/任务调度\"},{\"text\":\"加载阶段性能\",\"link\":\"/browser/加载阶段性能\"},{\"text\":\"Performance\",\"link\":\"/browser/Performance\"},{\"text\":\"Performance中的Main指标\",\"link\":\"/browser/Performance中的Main指标\"}],\"/计网/\":[{\"text\":\"计算机网络基础\",\"items\":[{\"text\":\"第一章 计算机网络体系结构\",\"link\":\"/计网/chapter1\"},{\"text\":\"第二章 物理层\",\"link\":\"/计网/chapter2\"},{\"text\":\"第三章 数据链路层\",\"link\":\"/计网/chapter3\"}]},{\"text\":\"HTTPS\",\"link\":\"/计网/https\"},{\"text\":\"WebSocket\",\"link\":\"/计网/webSocket\"}],\"/project/\":[{\"text\":\"项目总结\",\"link\":\"/project/index\"},{\"text\":\"TMM\",\"link\":\"/project/tmm\",\"items\":[{\"text\":\"TMM模块重构与架构设计\",\"link\":\"/project/tmm/architecture\"},{\"text\":\"本地化搜索引擎实现\",\"link\":\"/project/tmm/local_search\"},{\"text\":\"@功能的高效实现\",\"link\":\"/project/tmm/mention\"},{\"text\":\"ELectron大文件分片上传、断点续传、并行上传\",\"link\":\"/project/tmm/partFileUpload\"},{\"text\":\"TMM性能优化\",\"link\":\"/project/tmm/performance_optimization\"},{\"text\":\"基于RBAC模型的群组权限体系设计与实现\",\"link\":\"/project/tmm/RBAC\"},{\"text\":\"基于AWS和Node流式大文件下载\",\"link\":\"/project/tmm/resources_manner\"}]}],\"/algorithm/\":[{\"text\":\"退避算法\",\"link\":\"/algorithm/退避算法\"},{\"text\":\"LRU算法\",\"link\":\"/algorithm/LRU\"}],\"/softExame/\":[{\"text\":\"软考-软件设计师\",\"link\":\"/softExame/index\"},{\"text\":\"时间规划\",\"link\":\"/softExame/schedule\"},{\"text\":\"软件工程\",\"link\":\"/softExame/软件工程\"},{\"text\":\"面向对象\",\"link\":\"/softExame/面向对象\"},{\"text\":\"数据库\",\"link\":\"/softExame/database\"},{}],\"/AI/\":[{\"text\":\"AI\",\"link\":\"/AI/index\"},{\"text\":\"MCP\",\"items\":[{\"text\":\"BrowserTools MCP\",\"link\":\"/AI/mcp/browserTools\"},{\"text\":\"Figma Dev Mode MCP\",\"link\":\"/AI/mcp/figma\"}]},{\"text\":\"Dify\",\"items\":[{\"text\":\"Dify介绍\",\"link\":\"/AI/Dify/index\"}]}],\"/designPatterns/\":[{\"text\":\"设计模式\",\"link\":\"/designPatterns/index\"},{\"text\":\"模版方法\",\"link\":\"/designPatterns/模版方法\"}]},\"search\":{\"provider\":\"local\"},\"outline\":{\"level\":\"deep\",\"label\":\"本页目录\"},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/LynnCen\"}],\"footer\":{\"message\":\"如有转载或 CV 的请标注本站原文地址\",\"copyright\":\"Copyright © 2024-present LynnCen\"},\"darkModeSwitchLabel\":\"外观\",\"returnToTopLabel\":\"返回顶部\",\"lastUpdatedText\":\"上次更新\",\"docFooter\":{\"prev\":\"上一篇\",\"next\":\"下一篇\"},\"visitor\":{\"badgeId\":\"LynnCen.Lyc-notes\"},\"comment\":{\"repo\":\"LynnCen/Lyc-notes\",\"repoId\":\"R_kgDOLsOwUg\",\"category\":\"Announcements\",\"categoryId\":\"DIC_kwDOLsOwUs4CenzY\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":true}");</script>
    
  </body>
</html>